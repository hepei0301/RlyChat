webpackJsonp([1],{

/***/ "+Jap":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "+Uo2":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "2oL2":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "3zMA":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "5Xk0":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-runtime/helpers/defineProperty.js
var defineProperty = __webpack_require__("bOdI");
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty);

// EXTERNAL MODULE: ./node_modules/babel-runtime/core-js/object/keys.js
var keys = __webpack_require__("fZjL");
var keys_default = /*#__PURE__*/__webpack_require__.n(keys);

// EXTERNAL MODULE: ./node_modules/babel-runtime/core-js/object/assign.js
var object_assign = __webpack_require__("woOf");
var assign_default = /*#__PURE__*/__webpack_require__.n(object_assign);

// EXTERNAL MODULE: ./node_modules/babel-runtime/core-js/json/stringify.js
var stringify = __webpack_require__("mvHQ");
var stringify_default = /*#__PURE__*/__webpack_require__.n(stringify);

// EXTERNAL MODULE: ./node_modules/babel-runtime/core-js/object/get-own-property-names.js
var get_own_property_names = __webpack_require__("aFK5");
var get_own_property_names_default = /*#__PURE__*/__webpack_require__.n(get_own_property_names);

// EXTERNAL MODULE: ./node_modules/babel-runtime/helpers/extends.js
var helpers_extends = __webpack_require__("Dd8w");
var extends_default = /*#__PURE__*/__webpack_require__.n(helpers_extends);

// EXTERNAL MODULE: ./node_modules/md5/md5.js
var md5 = __webpack_require__("L6bb");
var md5_default = /*#__PURE__*/__webpack_require__.n(md5);

// CONCATENATED MODULE: ./public/SDK/mediaMeeting.js

var hex_md5 = md5_default.a;
window.hex_md5 = md5_default.a;

function MediaMeet() {
  this.status = 0;
  //  this._appid = "ff8080815dbc080c015dbc0f88dd0001";
  // this._appToken = '0c7f757cc763462ba99f3bf2b9aae6f0';
  this._appid = "ff8080815dbc080c015dbc9d7cd40003"; //公司的账号  17环境
  this._appToken = "7f4fa6d320ab49739183af1d498adb6b"; //公司的秘钥
  this.g_confId = "";
  this.login_type = 1;
  this.user_account = null;
  this.callId = null;
  this.called = null;
  this.caller = null;
  //lll
  this.flag = false;
  this.YHuserId = null;
  this.YHappId = null;
  this.YHconfId = null;
  this.serverIp = null;
  this.lvsServer = null;
  this.fileSig = null;
  this.meetingServer = null;
  this.ClientSecretKey = null;
  this.invitedAttendees = []; //全局受邀参会
  this.meetingInvitedAttendees = []; //全局新增参会
}
var mediaMeeting_RL_Media = window.RL_Media || window.souce && window.souce.RL_Media;
MediaMeet.prototype = {
  //lll 预约会议需要的默认时间
  getFormatDate: function getFormatDate(now) {
    now = now || new Date();
    nowDate = now.getTime() + 1000 * 60 * 15; //预约会议推迟15分钟
    nowDate = new Date(nowDate);
    var year = nowDate.getFullYear();
    var month = nowDate.getMonth() + 1 < 10 ? "0" + (nowDate.getMonth() + 1) : nowDate.getMonth() + 1;
    var date = nowDate.getDate() < 10 ? "0" + nowDate.getDate() : nowDate.getDate();
    var hour = nowDate.getHours() < 10 ? "0" + nowDate.getHours() : nowDate.getHours();
    var minute = nowDate.getMinutes() < 10 ? "0" + nowDate.getMinutes() : nowDate.getMinutes();
    var seconds = nowDate.getSeconds() < 10 ? "0" + nowDate.getSeconds() : nowDate.getSeconds();
    return year + "-" + month + "-" + date + " " + hour + ":" + minute + ":" + seconds;
  },
  //创建会议
  createMeet: function createMeet(data, immediately) {
    var conferenceMsgBuilder = new mediaMeeting_RL_Media.ConferenceMsgBuilder();
    conferenceMsgBuilder.setPath("/REST/Conference/Create?source=SDK");
    conferenceMsgBuilder.setContent({
      mediaType: 1,
      confName: data.confName,
      reserveEnable: data.reserveEnable
    });
    mediaMeeting_RL_Media.ConferenceMsg(conferenceMsgBuilder, function (e) {
      daa = JSON.parse(e.result);
      console.log(daa, "创建会议信息");
      console.log(globalRouting);
      globalRouting.$router.push({
        path: "/meeting",
        query: {
          immediately: immediately,
          dataObj: daa
        }
      });
      //创建会议给个标志
      var confId = daa.confId;
      sessionStorage.setItem("meetingID", confId);
    }, function (err) {
      alert("error");
      console.log(err);
    });
  },
  //SDK登录
  Login: function Login(value, callback) {
    this.getSig(value, "", callback);
  },
  getTimeStamp: function getTimeStamp() {
    var now = new Date();
    return now.getFullYear() + "" + (now.getMonth() + 1 >= 10 ? "" + (now.getMonth() + 1) : "0" + (now.getMonth() + 1)) + (now.getDate() >= 10 ? now.getDate() : "0" + now.getDate()) + (now.getHours() >= 10 ? now.getHours() : "0" + now.getHours()) + (now.getMinutes() >= 10 ? now.getMinutes() : "0" + now.getMinutes()) + (now.getSeconds() >= 10 ? now.getSeconds() : "0" + now.getSeconds());
  },
  getSig: function getSig(account_number, pwd, callback) {
    var pass = pwd ? pwd : "";
    var timestamp = this.getTimeStamp();
    if (this.flag) {
      this.privateLogin(account_number, timestamp, function (obj) {
        this.EV_login(account_number, pass, obj.sig, timestamp, callback);
      }, function (obj) {
        console.log("错误码：" + obj.code + "; 错误描述：" + obj.msg);
      });
    } else {
      //仅用于本地测试，官方不推荐这种方式应用在生产环境
      //没有服务器获取sig值时，可以使用如下代码获取sig
      var sig = hex_md5(this._appid + account_number + timestamp + this._appToken);
      // console.log("本地计算sig：" + sig);
      this.EV_login(account_number, pass, sig, timestamp, callback);
    }
  },
  EV_login: function EV_login(user_account, pwd, sig, timestamp, callback) {
    // console.log("EV_login");
    var loginBuilder = {
      type: this.login_type,
      userName: user_account,
      timestamp: timestamp
    };
    if (1 == this.login_type) {
      //1是自定义账号，2是voip账号
      loginBuilder.sig = sig;
    } else {
      loginBuilder.password = pwd;
    }
    RL_YTX_NEW.login(loginBuilder, function (obj) {
      Meet.user_account = user_account;
      Meet.is_online = true;
      // console.log("EV_login succ...");

      // var conferenceMsgBuilder = new RL_Media.ConferenceMsgBuilder();
      // conferenceMsgBuilder.setPath("/REST/Conference/AppSetting/Get?source=SDK");
      // conferenceMsgBuilder.setContent(
      //   {"appId":RL_MEET.appId,"userId":RL_MEET.userId}
      // );
      // RL_Media.ConferenceMsg(conferenceMsgBuilder,function (e) {
      //   var resp = JSON.parse(e.result);
      //   console.log(resp,"AppSetting resp");
      //   if(resp.statusCode=="000000"){
      //
      //
      //   }
      // },function (err) {
      //   console.log(err)
      // });

      // RL_Media.onConferenceNotifyLinstener(
      //     // Meet.conferenceNotifyLinstener
      // Meet.conferenceMsgLinstener
      // );
      // 注册群组通知事件监听
      window.parent.RL_Chat.onNoticeReceiveListener(function (obj) {});
      // 服务器连接状态变更时的监听
      // RL_Media.onConnectStateChangeLisenter(function(obj) {
      //     // obj.code;//变更状态 1 断开连接 2 重练中 3 重练成功 4 被踢下线 5 断开连接，需重新登录
      //     // 断线需要人工重连
      //     if(1 == obj.code) {
      //         console.log('onConnectStateChangeLisenter obj.code:' + obj.msg);
      //     } else if(2 == obj.code) {
      //         console.log('网络状况不佳，正在试图重连服务器');
      //     } else if(3 == obj.code) {
      //         console.log('连接成功', console.console.TYPE_OK);
      //     } else if(4 == obj.code) {
      //       //被踢  登出
      //         console.log(obj.msg);
      //     } else if(5 == obj.code) {
      //         console.log('网络状况不佳，正在试图重连服务器');
      //         this.getSig(this.user_account);
      //     } else {
      //         console.log('onConnectStateChangeLisenter obj.code:' + obj.msg);
      //     }
      // });
      if (callback) callback();
      //Meet.QueryMeetList();
    }, function (obj) {
      console.log("错误码： " + obj.code + "; 错误描述：" + obj.msg);
    });
  },
  privateLogin: function privateLogin(user_account, timestamp, callback, onError) {
    console.log("privateLogin");
    var data = {
      appid: this._appid,
      username: user_account,
      timestamp: timestamp
    };
    var url = this._3rdServer + "genSig";
    $.ajax({
      type: "POST",
      url: url,
      dataType: "jsonp",
      data: data,
      contentType: "application/x-www-form-urlencoded",
      jsonp: "cb",
      success: function success(result) {
        if (result.code != "000000") {
          var resp = {};
          resp.code = result.code;
          resp.msg = "Get SIG fail from 3rd server!...";
          onError(resp);
          return;
        } else {
          var resp = {};
          resp.code = result.code;
          resp.sig = result.sig;
          callback(resp);
          return;
        }
      },
      error: function error(e) {
        var resp = {};
        console.log(e);
        resp.msg = "Get SIG fail from 3rd server!";
        onError(resp);
      },
      timeout: 5000
    });
  },
  init: function init() {},
  //会议提示通知
  conferenceNotifyLinstener: function conferenceNotifyLinstener(msg) {
    console.log(msg, ": conference notice ");
    // if(msg.msgType === 50){
    //     // aa();
    //     var msgContent= JSON.parse(msg.msgContent);
    //     console.log(msgContent,'msgContent');
    //     var creator = msgContent.creator;
    //     if(msgContent.noteType === 6){
    //         if(youconfId!="" && youconfId != msgContent.confId){
    //             alert("您有一个新的会议邀请，但是您当前正在会议中");
    //             return false;
    //         }
    //         Meet.validateConference(msgContent.confId);
    //     }
    // }
  },
  //会议提示通知后操作
  validateConference: function validateConference(confId) {
    var conferenceMsgBuilder = new mediaMeeting_RL_Media.ConferenceMsgBuilder();
    conferenceMsgBuilder.setPath("/REST/Conference/Info?source=SDK");
    conferenceMsgBuilder.setContent({
      confId: confId
    });

    mediaMeeting_RL_Media.ConferenceMsg(conferenceMsgBuilder, function (e) {
      console.log(e);
      var result = JSON.parse(e.result);
      var statusCode = result.statusCode;
      if ("000000" == statusCode) {
        tips = result;
        $(".conference-reminding").show();
      }
    }, function (err) {
      console.log(err);
    });
  },
  //成员操作通知
  conferenceMsgLinstener: function conferenceMsgLinstener(obj) {
    var resp = JSON.parse(obj["2"]);
    console.log("conferenceMsgLinstener", resp);
    /*console.log(resp,'监听通知')
        listen = resp;
        allMembers = resp.members;
        console.log(allMembersList,'allmemberList');
        console.log("-----------------------conferenceNotify---------------------------");
        console.log(resp);
        console.log(listen,'listen');
        //踢出成员
        if(resp.noteType==4){
            for(var i=0;i<memberJoin.length;i++){
                //循环kickedMembers...
                for(var k=0;k<resp.kickedMembers.length;k++){
                    if(resp.kickedMembers[k].memberId===memberJoin[i].memberId && memberJoin[i].videoSource!=undefined){
                        console.log('谁被踢出了会议')
                        $(".message").append("<li style='list-style: none;background: #ccc'><span>"+memberJoin[i].userName+"</span>被踢出会议</li>");
                        //后面加上释放视频流..
                        $('#'+resp.kickedMembers[k].memberId).parent().remove();
                        Meet.ReleaseMemberSource(resp.kickedMembers[k].memberId);
                        memberJoin.splice(i,1);
                        allMembersList.splice(i,1);
                        setTimeout(function(){
                            $('.message li').remove();
                        },2000);
                    }
                }
            }
        }
        //成员加入(邀请加入以及主动加入)
        if (resp.noteType==2) {
            for(var i=0;i<resp.members.length;i++){
                console.log('成员加入----------------------')
                console.log(resp.members[i],'membersmembers');
                console.log(resp.members[i].inviter,'membersmembers');
                Jion = true;
                allMembersList.push(resp.members[i]);
                if(!resp.members[i].inviter){
                    console.log(memberJoin.length)
                    if(memberJoin.length==0){
                        console.log('是不是进到这个里面了')
                        $(".message").append("<li style='list-style: none;background: #ccc'><span>"+resp.members[i].userName+"</span>加入会议</li>");
                        memberJoin.push(resp.members[i]);
                        setTimeout(function(){
                            $('.message li').remove();
                        },2000);
                    }else {
                        console.log(memberJoin,'看看memeberJoin')
                        for(var k=0;k<memberJoin.length;k++){
                            console.log(resp.members[i].memberId!=memberJoin[k].memberId)
                            console.log(resp.members[i])
                            if(resp.members[i].memberId!=memberJoin[k].memberId && resp.members[i].videoSource!=undefined){
                                console.log(memberJoin[k],'kkkkiokioik')
                                $(".message").append("<li style='list-style: none;background: #ccc'><span>"+resp.members[i].userName+"</span>加入会议</li>");
                                memberJoin.push(resp.members[i]);
                                setTimeout(function(){
                                    $('.message li').remove();
                                },2000);
                                  //请求视频流放在infoMemberList里面执行
                                Meet.infoMemberList(youconfId,resp.members[i].memberId);
                            }else {
                                console.log('发生错误!有的位置是空的.')
                            }
                        }
                    }
                }else{
                    //判断状态  确定显示内容(图标)
                    Meet.memberListDisplay(resp.members[i]);
                }
                //请求视频流...应该是在成员确认加入后再请求视频流?
                setTimeout(function(){
                    $('.message li').hide();
                },2000);
            }
        } else if (resp.noteType==3) {//成员离开
            console.log(resp,'ewrqteryertu')
            for(var i=0;i<memberJoin.length;i++){
                if(resp.memberId===memberJoin[i].memberId){
                    Jion = false;
                    $(".message").append("<li style='list-style: none;background: #ccc'><span>"+memberJoin[i].userName+"</span>离开会议</li>");
                      //将离开会议的成员移除参会中的列表
                    memberJoin.splice(i,1);
                    console.log(memberJoin,'看一下新数组')
                    allMembersList.splice(i,1);
                    setTimeout(function(){
                        $('.message li').remove();
                    },2000);
                    //后面加上释放视频流..
                    $('#'+resp.memberId).parent().remove();
                    Meet.ReleaseMemberSource(resp.memberId);
                }
                console.log(memberJoin[i],'membersnoteType=3');
            }
        }else if (resp.noteType==5) {//更新成员信息
            console.log(resp,'noteType===5')
            Meet.memberListDisplay(resp.members);
        }else if (resp.noteType==7) {//更新成员信息
            Jion==true
            if(resp.action===56){//拒绝邀请
                console.log(resp.members,'respresp')
                for(var k=0;k<resp.members.length;k++){
                    for(var i=0;i<allMembersList.length;i++){
                        if(memberUnjoin.length==0){
                            if(allMembersList[i].memberId === resp.members[k].memberId){
                                memberUnjoin.push(allMembersList[i]);
                            }
                        }else {
                            for(var x in memberUnjoin){
                                if(allMembersList[i].memberId === resp.members[k].memberId && memberUnjoin[x].memberId != resp.members[k].memberId){
                                    memberUnjoin.push(allMembersList[i]);
                                }
                            }
                        }
                    }
                }
            }else if (resp.action===57){//接受邀请
                Meet.memberListDisplay(resp.members);
            }
            console.log(resp,'noteType===7')
        }else {
            console.log("will not process for this noteType=" + resp.noteType);
            console.log(resp,'其他的内容')
        }*/
  },
  //成员状态
  memberListDisplay: function memberListDisplay(members) {
    console.log(members, "membersaaswdsadasdwe");
    var arr = [members];
    for (var i = 0; i < members.length; i++) {
      //首先判断媒体是否在线->
      console.log(members[i], "members[i].state & UserStateMediaOnline");
      if ((members[i].state & UserStateMediaOnline) == UserStateMediaOnline && UserStateAcceptInvite == (members[i].state & UserStateAcceptInvite)) {
        console.log("判断媒体在线");
        if (memberJoin.length < 6) {
          for (var k = 0; k < memberJoin.length; k++) {
            console.log(memberJoin, "xiangkankan");
            console.log(memberJoin[k]);
            if (members[i].memberId != memberJoin[k].memberId && members[i].videoSource != memberJoin[k].videoSource && members[i].videoSource != undefined && members[i].userName != undefined) {
              $(".message").append("<li style='list-style: none;background: #ccc'><span>" + members[i].userName + "</span>加入会议</li>");
              memberJoin.push(members[i]);
              window.b = document.createElement("video");
              window.c = document.createElement("li");
              //                            window.b.controls = true;暂时不需要
              window.b.autoplay = true;
              window.b.id = members[i].memberId;
              window.b.style.width = "100%";
              window.b.style.height = "100%";
              window.c.style.width = "315px";
              window.c.style.height = "250px";
              window.c.style.float = "left";
              //                            window.c.style.minWidth = '326px';//测试写成固定值
              window.c.style.display = "inline-block";
              window.c.style.background = "#8187b0";
              window.b.style.objectFit = "fill";
              window.c.appendChild(b);
              $(".startmeeting-wrap").append(c);
              //请求视频流放在infoMemberList里面执行
              Meet.infoMemberList(youconfId, members[i].memberId);
            }
          }
        } else {
          alert("对不起,已经超过邀请成员上限!");
        }
        console.log(arr[i].state & UserStateMediaOnline, "members[i].state & UserStateMediaOnline");
        if (arr[i].state & UserStateAllowSpeak == UserStateAllowSpeak) {
          //成员可讲话将静音标识置为true
          joinMic = true;
          console.log("---------------成员可以讲话-------------");
        } else {
          //成员不可讲话将静音标识置为false
          joinMic = false;
          console.log("---------------成员不可以讲话-------------");
        }
      } else if ((members[i].state & UserStateRejectInvite) == UserStateRejectInvite) {
        //是否拒绝邀请
        memberUnjoin.push(members[i]);
        //挂断之后应该有什么操作
      } else if ((members[i].state & UserStateBeCalling) == UserStateBeCalling) {
        //正在接通
        //挂断之后应该有什么操作
      } else {}
    }
  },
  //加入会议
  JoinMeet: function JoinMeet(confId, userName) {
    var conferenceMsgBuilder = new mediaMeeting_RL_Media.ConferenceMsgBuilder();
    conferenceMsgBuilder.setPath("/REST/Conference/Member/Join?source=SDK");
    conferenceMsgBuilder.setContent({
      confId: confId,
      userName: userName
    });
    mediaMeeting_RL_Media.ConferenceMsg(conferenceMsgBuilder, function (e) {
      var resp = JSON.parse(e.result);
      if (resp.statusCode == "000000") {
        console.log(resp);
        console.log("用户加入会议成功");
        Meet.starVoice(resp.conf.confId);
      } else {
        alert(resp.statusMsg);
      }
    });
  },
  //媒体相关（静音、视频。。。）
  unMute: function unMute(confId, action) {
    var conferenceMsgBuilder = new mediaMeeting_RL_Media.ConferenceMsgBuilder();
    conferenceMsgBuilder.setPath("/REST/Conference/Member/MediaControl?source=SDK");
    conferenceMsgBuilder.setContent({
      confId: confId,
      allMember: 1,
      unchangable: 1,
      action: action
    });
    mediaMeeting_RL_Media.ConferenceMsg(conferenceMsgBuilder, function (e) {
      var result = JSON.parse(e.result);
      //创建会议给个标志
      console.log("----------------全体静音--------------------");
      console.log(result);
      if (result.statusCode == "000000") {
        $(".mute").attr("disabled", null);
        $(".mute").addClass("mute1");
        $(".mute").addClass("mute2");
        $(".mute").css("border", "1px solid #405aff");

        $(".un-mute").css("border", "1px solid #aaaaaa");
        $(".un-mute").attr("disabled", "disabled");
        $(".un-mute").removeClass("mute1");
        $(".un-mute").removeClass("mute2");
      }
      console.log("----------------------全体静音--------------");
    }, function (err) {
      console.log(err);
    });
  },
  //全体静音
  mute: function mute(confId, action) {
    var conferenceMsgBuilder = new mediaMeeting_RL_Media.ConferenceMsgBuilder();
    conferenceMsgBuilder.setPath("/REST/Conference/Member/MediaControl?source=SDK");
    conferenceMsgBuilder.setContent({
      confId: confId,
      allMember: 1,
      unchangable: 1,
      action: action
    });
    mediaMeeting_RL_Media.ConferenceMsg(conferenceMsgBuilder, function (e) {
      var result = JSON.parse(e.result);
      //创建会议给个标志
      console.log("----------------全体静音--------------------");
      console.log(result);
      if (result.statusCode == "000000") {
        $(".mute").attr("disabled", "disabled");
        $(".mute").removeClass("mute1");
        $(".mute").removeClass("mute2");
        $(".mute").css("border", "1px solid #aaaaaa");

        $(".un-mute").css("border", "1px solid #405aff");
        $(".un-mute").attr("disabled", null);
        $(".un-mute").addClass("mute1");
        $(".un-mute").addClass("mute2");
      }
      console.log("----------------------全体静音--------------");
    }, function (err) {
      console.log(err);
    });
  },
  //麦克风静音
  MicMute: function MicMute(confId, action) {
    var conferenceMsgBuilder = new mediaMeeting_RL_Media.ConferenceMsgBuilder();
    conferenceMsgBuilder.setPath("/REST/Conference/Member/MediaControl?source=SDK");
    conferenceMsgBuilder.setContent({
      confId: confId,
      action: action
    });
    mediaMeeting_RL_Media.ConferenceMsg(conferenceMsgBuilder, function (e) {
      var result = JSON.parse(e.result);
      //创建会议给个标志
      console.log("----------------麦克风会中点击事件--------------------");
      console.log(result);
      console.log("----------------------麦克风会中点击事件--------------");
    }, function (err) {
      console.log(err);
    });
  },
  //摄像头
  CameraMute: function CameraMute(confId, action) {
    var conferenceMsgBuilder = new mediaMeeting_RL_Media.ConferenceMsgBuilder();
    conferenceMsgBuilder.setPath("/REST/Conference/Member/MediaControl?source=SDK");
    conferenceMsgBuilder.setContent({
      confId: confId,
      action: action
    });
    mediaMeeting_RL_Media.ConferenceMsg(conferenceMsgBuilder, function (e) {
      var result = JSON.parse(e.result);
      //创建会议给个标志
      console.log("----------------静音会议成员--------------------");
      console.log(result);
      console.log("----------------------静音会议成员--------------");
    }, function (err) {
      console.log(err);
    });
  },
  //声音
  VoiceMute: function VoiceMute(confId, action) {
    var conferenceMsgBuilder = new mediaMeeting_RL_Media.ConferenceMsgBuilder();
    conferenceMsgBuilder.setPath("/REST/Conference/Member/MediaControl?source=SDK");
    conferenceMsgBuilder.setContent({
      confId: confId,
      action: action
    });
    mediaMeeting_RL_Media.ConferenceMsg(conferenceMsgBuilder, function (e) {
      var result = JSON.parse(e.result);
      console.log("----------------静音会议成员--------------------");
      console.log(result);
      console.log("----------------------静音会议成员--------------");
    }, function (err) {
      console.log(err);
    });
  },
  //成员信息更新（改名）
  updateName: function updateName(confId, memberId, memberIdType, username) {
    var conferenceMsgBuilder = new mediaMeeting_RL_Media.ConferenceMsgBuilder();
    conferenceMsgBuilder.setPath("/REST/Conference/Member/Update?source=SDK");
    conferenceMsgBuilder.setContent({
      confId: confId,
      memberId: memberId,
      idType: memberIdType,
      userName: username
    });
    mediaMeeting_RL_Media.ConferenceMsg(conferenceMsgBuilder, function (e) {
      var result = JSON.parse(e.result);
      console.log("----------------更新会议成员信息--------------------");
      console.log(result, "修改姓名操作");
      console.log("----------------------更新会议成员信息--------------");
      //infoMemberList(confId);
    }, function (err) {
      alert("error");
      console.log(err);
    });
  },
  //点击移除操作
  deletePerson: function deletePerson(confId, member) {
    var conferenceMsgBuilder = new mediaMeeting_RL_Media.ConferenceMsgBuilder();
    conferenceMsgBuilder.setPath("/REST/Conference/Member/Kickout?source=SDK");
    conferenceMsgBuilder.setContent({
      confId: confId,
      kickMembers: member
    });
    mediaMeeting_RL_Media.ConferenceMsg(conferenceMsgBuilder, function (e) {
      var result = JSON.parse(e.result);
      //创建会议给个标志
      console.log("----------------移除会议成员--------------------");
      console.log(result);
      console.log("----------------------移除会议成员--------------");
    }, function (err) {
      alert("error");
      console.log(err);
    });
  },
  //静音按钮单个
  quiet: function quiet(confId, member) {
    var conferenceMsgBuilder = new mediaMeeting_RL_Media.ConferenceMsgBuilder();
    conferenceMsgBuilder.setPath("/REST/Conference/Member/MediaControl?source=SDK");
    conferenceMsgBuilder.setContent({
      confId: confId,
      allmember: 0,
      unchanggeable: 0,
      members: member,
      action: 2
    });
    mediaMeeting_RL_Media.ConferenceMsg(conferenceMsgBuilder, function (e) {
      var result = JSON.parse(e.result);
      //创建会议给个标志
      console.log("----------------静音会议成员--------------------");
      console.log(result);
      console.log("----------------------静音会议成员--------------");
    }, function (err) {
      alert("error");
      console.log(err);
    });
  },
  //关闭视频单个
  closeVideo: function closeVideo(confId, member) {
    var conferenceMsgBuilder = new mediaMeeting_RL_Media.ConferenceMsgBuilder();
    conferenceMsgBuilder.setPath("/REST/Conference/Member/MediaControl?source=SDK");
    conferenceMsgBuilder.setContent({
      confId: tconfId,
      allmember: 0,
      unchanggeable: 0,
      members: member,
      action: action
    });
    mediaMeeting_RL_Media.ConferenceMsg(conferenceMsgBuilder, function (e) {
      var result = JSON.parse(e.result);
      //创建会议给个标志
      console.log("----------------静音会议成员--------------------");
      console.log(result);
      window.clearInterval(timer1);
      console.log("----------------------静音会议成员--------------");
    }, function (err) {
      alert("error");
      console.log(err);
    });
  },
  //页面跳转至开会页面时，在组件完成之前调用
  jiru: function jiru(routeData) {
    if (routeData.immediately == true && routeData.dataObj.statusCode == "000000") {
      mediaMeeting_RL_Media.setMeetingLocalView(null, a);
      var connectMediaBuilder = new mediaMeeting_RL_Media.ConnectMediaBuilder();
      connectMediaBuilder.setCallType(1);
      connectMediaBuilder.setCalled(that.meetingID);
      mediaMeeting_RL_Media.ConnectMedia(connectMediaBuilder, function (e) {
        //计入成功
        console.log("计入成功了");
      }, function (err) {
        console.log(err);
        alert(err); //将错误信息抛出来
      });
      Meet.JoinMeet(confId);
    }
  }
};

var Meet = new MediaMeet();
// Meet.init();
/* harmony default export */ var mediaMeeting = (Meet);
// EXTERNAL MODULE: ./node_modules/vuex/dist/vuex.esm.js
var vuex_esm = __webpack_require__("NYxO");

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./src/components/meeting/meetingHeader.vue

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var meetingHeader = ({
  props: ['netStatus', 'roomInfo', 'isHost', 'isLogin', 'showShareBtn'],
  data: function data() {
    return {
      meetingTime: 0,
      meetTimeHour: 0,
      meetTimeMinute: 0,
      meetTimeSecond: 0,
      timerTips: false,
      isShowTime: false
    };
  },

  computed: extends_default()({}, Object(vuex_esm["b" /* mapGetters */])(['user_info'])),
  watch: {
    roomInfo: function roomInfo(val) {
      var time = new Date().getTime() + (parseInt(this.user_info.timeDifference) || 0);
      console.log('===time===', time, this.user_info.timeDifference);
      this.meetingTime = parseInt((time - new Date(val.startTime).getTime()) / 1000) < 0 ? 0 : parseInt((time - new Date(val.startTime).getTime()) / 1000);
    }
  },
  created: function created() {
    this.autoTime();
    // console.log(this.roomInfo)

  },

  methods: {
    showTimerTips: function showTimerTips() {
      this.timerTips = true;
    },
    joinWbRoom: function joinWbRoom() {
      this.$parent.joinWhiteBoardRoom(Number(this.$parent.whiteBoardRoomId), this.$parent.whiteBoardUserId);
    },
    autoTime: function autoTime() {
      var _this = this;

      setInterval(function () {
        _this.meetingTime = _this.meetingTime + 1;
        _this.meetTimeHour = parseInt(_this.meetingTime / 3600) > 9 ? parseInt(_this.meetingTime / 3600) : "0" + parseInt(_this.meetingTime / 3600);
        _this.meetTimeMinute = parseInt((_this.meetingTime - _this.meetTimeHour * 3600) / 60) > 9 ? parseInt((_this.meetingTime - _this.meetTimeHour * 3600) / 60) : "0" + parseInt((_this.meetingTime - _this.meetTimeHour * 3600) / 60);
        _this.meetTimeSecond = _this.meetingTime - _this.meetTimeHour * 3600 - _this.meetTimeMinute * 60 > 9 ? _this.meetingTime - _this.meetTimeHour * 3600 - _this.meetTimeMinute * 60 : "0" + (_this.meetingTime - _this.meetTimeHour * 3600 - _this.meetTimeMinute * 60);

        // var endTimeTip = this.roomInfo.duration * 60 - this.meetingTime

        // if (!this.isShowTime) {
        //   if (endTimeTip <= 180&&endTimeTip>0) {
        //     this.timerTips = true;
        //   }else{
        //      this.timerTips = false;
        //   }
        //
        // }
      }, 1000);
    },
    leaveMeet: function leaveMeet() {
      this.$parent.LeaveMeetBtn();
    },
    minimizePage: function minimizePage() {
      this.$bus.emit('fullscreen');
      this.$bus.emit("updateMeetingList");
    }
  }
});
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-79692946","hasScoped":true,"transformToRequire":{"video":["src","poster"],"source":"src","img":"src","image":"xlink:href"},"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/meeting/meetingHeader.vue
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"headerBg"},[_c('header',[_c('el-row',{attrs:{"type":"flex","align":'middle'}},[_c('el-col',{attrs:{"span":8}},[_c('span',{staticClass:"meetTime"},[_vm._v(_vm._s(_vm.meetTimeHour + ":" + _vm.meetTimeMinute + ":" + _vm.meetTimeSecond))])]),_vm._v(" "),_c('el-col',{staticClass:"tc",attrs:{"span":8}},[_c('span',[_vm._v(_vm._s(_vm.roomInfo.confName)+"    "+_vm._s(_vm.$t('meeting.meetingNumber'))+":"+_vm._s(_vm.roomInfo.confId))])]),_vm._v(" "),_c('el-col',{staticClass:"tr",attrs:{"span":8}},[_c('el-tooltip',{attrs:{"effect":"dark","content":_vm.isHost?_vm.$t('meeting.leaveEndTheMeeting'):_vm.$t('group.leaveMeet'),"placement":"top"}},[_c('div',{staticClass:"CLoseBtnBg",on:{"click":_vm.leaveMeet}},[_c('i',{staticClass:"RSIcon RSIcon-guaduan",staticStyle:{"font-size":"28px"}})])]),_vm._v(" "),(_vm.isLogin)?_c('el-tooltip',{attrs:{"effect":"dark","placement":"top","content":_vm.$t('meeting.minimizeTheWindow')}},[_c('div',{staticClass:"minimizePage",on:{"click":_vm.minimizePage}},[_c('i',{staticClass:"iconfont icon-zuidahua",staticStyle:{"font-size":"28px"}})])]):_vm._e(),_vm._v(" "),(_vm.showShareBtn)?_c('el-tooltip',{attrs:{"effect":"dark","content":_vm.$t('meeting.whiteSharing'),"placement":"top"}},[_c('div',{staticClass:"screen-share",on:{"click":_vm.joinWbRoom}},[_c('i',{staticClass:"el-icon el-icon-s-platform",staticStyle:{"font-size":"28px"}})])]):_vm._e()],1)],1)],1),_vm._v(" "),(_vm.timerTips)?_c('div',{staticClass:"timerTip"},[_vm._v("\n    "+_vm._s(_vm.$t('meeting.ApproachingMeetingEndTime'))+_vm._s(_vm.roomInfo.duration*60 - _vm.meetingTime)+_vm._s(_vm.$t('collection.seconds'))+"\n    "),_c('i',{staticClass:"el-icon-close",on:{"click":function($event){_vm.timerTips= false;_vm.isShowTime=true}}})]):_vm._e()])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var meeting_meetingHeader = (esExports);
// CONCATENATED MODULE: ./src/components/meeting/meetingHeader.vue
function injectStyle (ssrContext) {
  __webpack_require__("HrYf")
  __webpack_require__("wA+2")
}
var normalizeComponent = __webpack_require__("VU/8")
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = "data-v-79692946"
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  meetingHeader,
  meeting_meetingHeader,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ var components_meeting_meetingHeader = (Component.exports);

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./src/components/meeting/meetInfo.vue

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ var meeting_meetInfo = ({
  props: ['isShow', 'browserInfo', 'roomInfo', 'isHost'],
  data: function data() {
    return {
      edit: false,
      editConfTopics: [],
      confTopic: []
    };
  },

  watch: {
    roomInfo: function roomInfo(val) {
      if (val.confTopic) {
        this.confTopic = JSON.parse(val.confTopic).topics;
      }
    }
  },
  created: function created() {},

  methods: {
    handleClose: function handleClose() {
      this.$parent.closeDialog('meetInfoDialog');
    },
    saveTopicBtn: function saveTopicBtn() {
      var _this = this;

      var self = this;
      for (var i = 0; i < self.editConfTopics.length; i++) {
        if (!self.editConfTopics[i].topic) {
          self.$message({
            message: this.$t('last.topicTip'),
            type: "error"
          });
          return;
        }
      }
      var contentTopics = {
        topics: self.editConfTopics
      };

      var ConferenceUpdateBuilder = new RL_MEET.ConferenceUpdateBuilder();
      ConferenceUpdateBuilder.setConfTopic(stringify_default()(contentTopics));
      RL_MEET.ConferenceUpdate(ConferenceUpdateBuilder, function (e) {
        if (e.statusCode == "000000") {
          self.$message({
            message: _this.$t('last.changeTopic'),
            type: "success"
          });
          self.edit = false;
        }
      }, function (err) {
        console.log(err);
      });
    },
    addTopic: function addTopic() {
      this.editConfTopics.push({
        topic: ''
      });
    },
    editTopicBtn: function editTopicBtn() {
      this.editConfTopics = this.confTopic;
      this.edit = true;
    }
  }
});
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-5d1e231e","hasScoped":true,"transformToRequire":{"video":["src","poster"],"source":"src","img":"src","image":"xlink:href"},"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/meeting/meetInfo.vue
var meetInfo_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('el-dialog',{directives:[{name:"dialogDrag",rawName:"v-dialogDrag"}],staticStyle:{"line-height":"30px"},attrs:{"title":_vm.$t('meeting.meetingDetail'),"custom-class":"meetInfoDialog","visible":_vm.isShow,"width":"400px","modal":false,"close-on-click-modal":false,"before-close":_vm.handleClose},on:{"update:visible":function($event){_vm.isShow=$event}}},[_c('h4',[_vm._v(_vm._s(_vm.$t('meeting.conferenceTheme')))]),_vm._v(" "),_c('p',[_vm._v(_vm._s(_vm.roomInfo.confName))]),_vm._v(" "),_c('h4',[_vm._v(_vm._s(_vm.$t('last.confTopic'))+" "),(!_vm.edit&&_vm.isHost)?_c('span',{staticClass:"fr col2a5 cp",on:{"click":function($event){return _vm.editTopicBtn()}}},[_vm._v(_vm._s(_vm.$t('connect.edit')))]):_vm._e(),(_vm.edit)?_c('span',{staticClass:"fr col2a5 cp",staticStyle:{"margin-left":"10px"},on:{"click":_vm.saveTopicBtn}},[_vm._v(_vm._s(_vm.$t('last.compelete')))]):_vm._e()]),_vm._v(" "),(!_vm.edit)?_c('ul',{staticStyle:{"margin-bottom":"60px"}},[(_vm.confTopic&&_vm.confTopic.length==0)?_c('div',{staticClass:"emptyMeetTopic"},[_c('p',[_c('img',{attrs:{"src":__webpack_require__("YxoK"),"alt":""}})]),_vm._v(" "),_c('p',[_vm._v(_vm._s(_vm.$t('last.createTopic')))])]):_vm._e(),_vm._v(" "),_vm._l((_vm.confTopic),function(item,index){return _c('li',{key:index},[_c('p',[_vm._v(_vm._s(item.topic))])])})],2):_vm._e(),_vm._v(" "),(_vm.edit)?_c('ul',[_vm._l((_vm.editConfTopics),function(item,index){return _c('li',{key:index,staticStyle:{"margin-bottom":"3px"}},[_c('el-row',[_c('el-col',{attrs:{"span":1}}),_vm._v(" "),_c('el-col',{attrs:{"span":22}},[_c('el-input',{attrs:{"placeholder":_vm.$t('last.chatTip'),"maxlength":"20","clearable":""},model:{value:(item.topic),callback:function ($$v) {_vm.$set(item, "topic", (typeof $$v === 'string'? $$v.trim(): $$v))},expression:"item.topic"}})],1),_vm._v(" "),_c('el-col',{attrs:{"span":1}},[_c('i',{staticClass:"el-icon-remove-outline fl colred",staticStyle:{"cursor":"pointer","font-size":"20px","margin-top":"20px","margin-left":"5px"},on:{"click":function($event){return _vm.editConfTopics.splice(index, 1)}}})])],1)],1)}),_vm._v(" "),(_vm.editConfTopics.length<3)?_c('li',{staticClass:"tc",on:{"click":function($event){return _vm.addTopic()}}},[_c('el-row',{staticStyle:{"margin-top":"25px"}},[_c('el-col',{staticStyle:{"margin-left":"36%"},attrs:{"span":6,"offset":1}},[_c('p',{staticClass:"addTopic",staticStyle:{"cursor":"pointer","margin-bottom":"150px"}},[_vm._v(_vm._s(_vm.$t('last.addTopic')))])])],1)],1):_vm._e()],2):_vm._e()])],1)}
var meetInfo_staticRenderFns = []
var meetInfo_esExports = { render: meetInfo_render, staticRenderFns: meetInfo_staticRenderFns }
/* harmony default export */ var components_meeting_meetInfo = (meetInfo_esExports);
// CONCATENATED MODULE: ./src/components/meeting/meetInfo.vue
function meetInfo_injectStyle (ssrContext) {
  __webpack_require__("sFoK")
  __webpack_require__("w+Fn")
}
var meetInfo_normalizeComponent = __webpack_require__("VU/8")
/* script */


/* template */

/* template functional */
var meetInfo___vue_template_functional__ = false
/* styles */
var meetInfo___vue_styles__ = meetInfo_injectStyle
/* scopeId */
var meetInfo___vue_scopeId__ = "data-v-5d1e231e"
/* moduleIdentifier (server only) */
var meetInfo___vue_module_identifier__ = null
var meetInfo_Component = meetInfo_normalizeComponent(
  meeting_meetInfo,
  components_meeting_meetInfo,
  meetInfo___vue_template_functional__,
  meetInfo___vue_styles__,
  meetInfo___vue_scopeId__,
  meetInfo___vue_module_identifier__
)

/* harmony default export */ var src_components_meeting_meetInfo = (meetInfo_Component.exports);

// EXTERNAL MODULE: ./src/components/meeting/meetShare.vue + 2 modules
var meetShare = __webpack_require__("8vhj");

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./src/components/meeting/delayed.vue
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ var delayed = ({
  props: ['isshow', 'isHostT', 'willNextEndTime'],
  data: function data() {
    return {
      prolongTimes: 15,
      delayDisabled15: false,
      delayDisabled30: false,
      delayDisabled45: false,
      delayDisabled60: false,
      prolongTimeRadio: 15,

      tryMinDuration: 0,
      tryMaxDuration: 0,
      nextEndTime: 0
    };
  },

  watch: {
    isHostT: function isHostT(val) {
      this.isHost = val;
    },
    willNextEndTime: function willNextEndTime(val) {
      this.nextEndTime = val;
    }
  },
  methods: {
    handleClose: function handleClose() {
      this.$parent.closeDialog('prolongDialogVisible');
    },
    prolongTimesChange: function prolongTimesChange(val) {
      console.log('选择的会议延长时间', val);
      this.prolongTimes = val;
    },
    prolongMeet: function prolongMeet() {
      var _this = this;

      var self = this;
      if (self.prolongTimes == 0) {
        self.handleClose();
        self.$message.error(self.$t('last.showMeetTime'));
        // return;
      }
      // else {
      this.tryMinDuration = this.prolongTimes;
      RL_MEET.prolongMeetTime(this.tryMinDuration, this.tryMinDuration, function (e) {
        console.log(e, "会议延长时间设置成功");
        if (self.prolongTimes !== 0) {
          _this.handleClose();
          self.$message.success(_this.$t('last.delaySuccess'));
        }
      }, function (err) {
        console.log(err);
        self.$message.error(err.statusMsg);
      });
      // }
      // tryMinDuration tryMaxDuration
    },
    chooseDelayTime: function chooseDelayTime(nextEndTime) {
      var endTimes = new Date(nextEndTime.toString()).getTime();
      var startTimes = new Date(this.meetInfo.endTime.toString()).getTime();
      console.log(endTimes, startTimes, "startTimes");
      this.tryMaxDuration = (endTimes - startTimes) / (1000 * 60);
      // this.tryMaxDuration = 9;   // 测试disable的数据;
      if (this.tryMaxDuration > 0 && this.tryMaxDuration < 14) {
        // disabled
        this.delayDisabled15 = this.delayDisabled30 = this.delayDisabled45 = this.delayDisabled60 = true;
      } else if (this.tryMaxDuration > 15 && this.tryMaxDuration < 29) {
        this.delayDisabled30 = this.delayDisabled45 = this.delayDisabled60 = true;
      } else if (this.tryMaxDuration > 30 && this.tryMaxDuration < 44) {
        this.delayDisabled45 = this.delayDisabled60 = true;
      } else if (this.tryMaxDuration > 45 && this.tryMaxDuration < 59) {
        this.delayDisabled60 = true;
      }
    },
    ConferenceNotify: function ConferenceNotify(obj) {
      var self = this;

      // 因为延长会议的通知走的是pushMsg; 所以单独做处理;
      if (obj.msgContent) {
        var delayMeetNoti = JSON.parse(obj.msgContent);
        if (delayMeetNoti.noteType == 26) {
          // 会议结束前的通知;
          console.log("会议结束前的通知", delayMeetNoti);
          self.chooseDelayTime(delayMeetNoti.nextEndTime);
        }
      }
    }
  }
});
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-983479f0","hasScoped":true,"transformToRequire":{"video":["src","poster"],"source":"src","img":"src","image":"xlink:href"},"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/meeting/delayed.vue
var delayed_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('el-dialog',{directives:[{name:"dialogDrag",rawName:"v-dialogDrag"}],attrs:{"title":_vm.$t('last.meetDelay'),"visible":_vm.isshow,"width":"500px","modal":false,"close-on-click-modal":false,"before-close":_vm.handleClose,"custom-class":"delayDialog"},on:{"update:visible":function($event){_vm.isshow=$event}}},[_c('p',{staticClass:"prolongTips"},[_c('span',{staticStyle:{"color":"#FF3B3B"}},[_vm._v(_vm._s(_vm.$t('last.tenMinu')))]),_vm._v(_vm._s(_vm.$t('last.delayTip')))]),_vm._v(" "),_c('el-radio-group',{on:{"change":_vm.prolongTimesChange},model:{value:(_vm.prolongTimeRadio),callback:function ($$v) {_vm.prolongTimeRadio=$$v},expression:"prolongTimeRadio"}},[_c('el-radio',{attrs:{"label":0}},[_vm._v(_vm._s(_vm.$t('last.noDelay')))]),_vm._v(" "),_c('el-radio',{attrs:{"label":15,"disabled":_vm.delayDisabled15}},[_vm._v(_vm._s(_vm.$t('last.minu15')))]),_vm._v(" "),_c('el-radio',{attrs:{"label":30,"disabled":_vm.delayDisabled30}},[_vm._v(_vm._s(_vm.$t('last.minu30')))]),_vm._v(" "),_c('el-radio',{attrs:{"label":45,"disabled":_vm.delayDisabled45}},[_vm._v(_vm._s(_vm.$t('last.minu45')))]),_vm._v(" "),_c('el-radio',{attrs:{"label":60,"disabled":_vm.delayDisabled60}},[_vm._v(_vm._s(_vm.$t('last.minu60')))])],1),_vm._v(" "),_c('span',{staticClass:"dialog-footer",attrs:{"slot":"footer"},slot:"footer"},[_c('el-button',{on:{"click":_vm.handleClose}},[_vm._v(_vm._s(_vm.$t('btn.cancel')))]),_vm._v(" "),_c('el-button',{attrs:{"type":"primary"},on:{"click":function($event){return _vm.prolongMeet()}}},[_vm._v(_vm._s(_vm.$t('btn.determine')))])],1)],1)],1)}
var delayed_staticRenderFns = []
var delayed_esExports = { render: delayed_render, staticRenderFns: delayed_staticRenderFns }
/* harmony default export */ var meeting_delayed = (delayed_esExports);
// CONCATENATED MODULE: ./src/components/meeting/delayed.vue
function delayed_injectStyle (ssrContext) {
  __webpack_require__("MTFV")
  __webpack_require__("3zMA")
}
var delayed_normalizeComponent = __webpack_require__("VU/8")
/* script */


/* template */

/* template functional */
var delayed___vue_template_functional__ = false
/* styles */
var delayed___vue_styles__ = delayed_injectStyle
/* scopeId */
var delayed___vue_scopeId__ = "data-v-983479f0"
/* moduleIdentifier (server only) */
var delayed___vue_module_identifier__ = null
var delayed_Component = delayed_normalizeComponent(
  delayed,
  meeting_delayed,
  delayed___vue_template_functional__,
  delayed___vue_styles__,
  delayed___vue_scopeId__,
  delayed___vue_module_identifier__
)

/* harmony default export */ var components_meeting_delayed = (delayed_Component.exports);

// EXTERNAL MODULE: ./src/assets/img/auth/defaultAvatar.png
var defaultAvatar = __webpack_require__("ae99");
var defaultAvatar_default = /*#__PURE__*/__webpack_require__.n(defaultAvatar);

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./src/components/meeting/merberlist.vue

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

 //默认头像

/* harmony default export */ var merberlist = ({
	props: ['isshow', 'isHost', 'SelfMeetUserId', 'screenUserId', 'voiceIncentiveId'],
	data: function data() {
		return {
			defaultImg: defaultAvatar_default.a,
			merberList: [],
			merberCount: 0,
			active: '1',
			muteAllChecked: false,
			isMuteAllDialog: false,
			isAllmuet: false,
			isAllCloseCamera: false

		};
	},

	computed: extends_default()({}, Object(vuex_esm["b" /* mapGetters */])(['memberInObj', 'meetInfo', 'memberOutObj'])),
	beforeDestroy: function beforeDestroy() {
		this.bus.$off('updateMediaStatus');
	},
	mounted: function mounted() {
		var _this2 = this;

		console.log('mounted---memberlist', this.meetInfo);
		var joinState = this.meetInfo.joinState;
		console.log(joinState & 0x000040, joinState & 0x000004 == 0);
		if (joinState & 0x000040) {
			this.isAllmuet = false;
		} else {
			this.isAllmuet = true;
		}
		if (joinState & 0x000004) {
			this.isAllCloseCamera = false;
		} else {
			this.isAllCloseCamera = true;
		}
		this.bus.$on('updateMediaStatus', function (content) {
			if (content === 'isOpenVideo' && _this2.isAllCloseCamera) {
				// this.isAllCloseCamera = false;
			} else if (content === 'isOpenAudio' && _this2.isAllmuet) {
				// this.isAllmuet = false;
			}
		});
	},

	methods: {
		isAllCloseCameraClick: function isAllCloseCameraClick() {
			var _this3 = this;

			var action = '';
			var message = '';
			if (this.isAllCloseCamera) {
				action = 13;
				message = this.$t('last.unOpenCamera') + this.$t('last.success');
			} else {
				action = 12;
				message = this.$t('last.closeCamera') + this.$t('last.success');
			}
			var self = this;
			var mediaControlBuilder = new RL_MEET.MediaControlBuilder();
			mediaControlBuilder.setConfId(this.meetInfo.confId);
			mediaControlBuilder.setAction(action);
			mediaControlBuilder.setUnchangable(1);
			mediaControlBuilder.setAllMember(1);
			RL_MEET.MediaControl(mediaControlBuilder, function (e) {
				console.log(e);
				_this3.$message({
					message: message
				});
				self.$parent.isAllCloseCamera = !self.isAllCloseCamera;
				self.isAllCloseCamera = !self.isAllCloseCamera;
			}, function (err) {
				console.log(err);
			});
		},
		allMuteClick: function allMuteClick() {
			this.isAllmuet ? this.unmuteAll() : this.isMuteAllDialog = true;
		},
		hostTransfer: function hostTransfer(user) {
			var _this4 = this;

			this.$confirm(this.$t('btn.determine') + user.userName + this.$t('last.setHoster') + "？", this.$t('modelMessage.prompt'), {
				confirmButtonText: this.$t('btn.determine'),
				cancelButtonText: this.$t('btn.cancel'),
				// iconClass: "iconfont icon-danchuang-tanhao",
				customClass: "error",
				roundButton: true,
				center: true
			}).then(function () {
				var that = _this4;
				var transferModeratorBuilder = new RL_MEET.TransferModeratorBuilder();
				transferModeratorBuilder.setConfId(_this4.meetInfo.confId);
				transferModeratorBuilder.setMembers([{
					memberId: user.memberId,
					idType: 2
				}]);

				RL_MEET.TransferModerator(transferModeratorBuilder, function (e) {
					console.log(e);
					var resp = JSON.parse(e.result);
					if (resp.statusCode == '000000') {
						that.$message.success(user.userName + that.$t('last.beenHoster'));
					}
				});
			});
		},
		noImgFind: function noImgFind(event) {
			console.log("未正确加载到图片;");
			var img = event.srcElement;
			img.src = this.defaultImg;
			img.οnerrοr = null; //控制不要一直跳动
		},
		kictout: function kictout(user) {
			//踢人

			var name = user.userName;
			this.$confirm(this.$t('btn.determine') + name + this.$t('meeting.removedFromMeeting') + "？", this.$t('modelMessage.prompt'), {
				confirmButtonText: this.$t('btn.determine'),
				cancelButtonText: this.$t('btn.cancel'),
				// iconClass: "iconfont icon-danchuang-tanhao",
				customClass: "error",
				roundButton: true,
				center: true
			}).then(function () {
				var kickMeetMemberBuilder = new RL_MEET.KickMeetMemberBuilder();
				kickMeetMemberBuilder.setKickMembers([{
					memberId: user.memberId,
					idType: 2
				}]);
				RL_MEET.KickMeetMember(kickMeetMemberBuilder, function (e) {
					console.log(e, "kick member success");
				}, function (err) {
					console.log(err);
				});
			});
		},
		handleClose: function handleClose() {
			this.$parent.closeDialog('merberDialog');
		},
		memberAudio: function memberAudio(member, Booleans) {
			var self = this;

			var memberId = member.memberId;
			if (memberId === self.SelfMeetUserId) {
				if (Booleans) {
					self.$parent.closeMicrophone();
				} else {
					self.$parent.openMicrophone(); //解除禁言
				}
				return;
			}
			if (!self.isHost) {
				return;
			}
			var mediaControlBuilder = new RL_MEET.MediaControlBuilder();

			if (Booleans) {
				mediaControlBuilder.setAction(2); //禁言
			} else {
				mediaControlBuilder.setAction(3); //解除禁言
			}
			mediaControlBuilder.setConfId(self.meetInfo.confId);
			mediaControlBuilder.setAllMember(0);
			mediaControlBuilder.setUnchangable(0);
			mediaControlBuilder.setMembers([{
				memberId: memberId,
				idType: 2
			}]);

			RL_MEET.MediaControl(mediaControlBuilder, function (e) {
				console.log(e);
				console.log("控制成员状态更新");
			}, function (err) {
				console.log(err);
				console.log("控制成员状态更新失败");
			});
		},
		kictoutBefore: function kictoutBefore(user, index) {
			var _this = this;
			var kickMeetMemberBuilder = new RL_MEET.KickMeetMemberBuilder();
			kickMeetMemberBuilder.setKickMembers([{
				memberId: user.memberId,
				idType: 2
			}]);
			RL_MEET.KickMeetMember(kickMeetMemberBuilder, function (e) {
				console.log(e, "kick member success");
			}, function (err) {
				console.log(err);
			});
		},
		Reinviting: function Reinviting(value) {
			//重新邀请
			console.log(value);

			var userlist = [{
				userName: value.userName,
				memberId: value.memberId,
				idType: 2
			}];
			var _this = this;
			var inviteMemberBuilder = new RL_MEET.InviteMemberBuilder();
			inviteMemberBuilder.setInviteMembers(userlist);
			RL_MEET.InviteMember(inviteMemberBuilder, function (e) {
				console.log("invite success ", e);
				_this.$message({
					message: _this.$t('last.reInviteTip'),
					type: "success"
				});
			}, function (err) {
				console.log("invite error ", err);
				_this.$message({
					message: err.statusMsg,
					type: "error"
				});
			});
		},
		YHkictout: function YHkictout(user) {
			var name = user.userName;
			this.$confirm("您想让" + name + "断开会议？", this.$t('modelMessage.prompt'), {
				confirmButtonText: this.$t('btn.determine'),
				cancelButtonText: this.$t('btn.cancel'),
				type: "error"
			}).then(function () {
				var member = [{
					memberId: user.memberId,
					idType: 2
				}];
				RL_MEET.disconnectMember(member);
			});
		},
		memberVideo: function memberVideo(member, Booleans) {
			// 摄像头控制
			var self = this;
			var memberId = member.memberId;
			if (memberId === self.SelfMeetUserId) {
				// 设置自己的摄像头状态
				if (Booleans) {
					self.$parent.closeCameraAndPubVideo();
				} else {
					self.$parent.openCamera(); //打开自己本地摄像头并推流
				}
				return;
			}
			if (!self.isHost) {
				return;
			}
			var mediaControlBuilder = new RL_MEET.MediaControlBuilder();
			mediaControlBuilder.setConfId(self.meetInfo.confId);
			mediaControlBuilder.setAllMember(0);
			mediaControlBuilder.setUnchangable(0);
			mediaControlBuilder.setMembers([{
				memberId: memberId,
				idType: 2
			}]);
			if (Booleans) {
				mediaControlBuilder.setAction(12);
			} else {
				self.$message.warning(this.$t('last.inviteOpenCamera'));
				mediaControlBuilder.setAction(13);
			}

			RL_MEET.MediaControl(mediaControlBuilder, function (e) {
				console.log(e);
			}, function (err) {
				console.log(err);
			});
			console.log(mediaControlBuilder, "mediaControlBuilder");
		},
		isMuteAll: function isMuteAll() {
			var unChangeable;
			if (this.muteAllChecked) {
				unChangeable = 1;
			} else {
				unChangeable = 0;
			}
			this.muteAll(unChangeable);
		},
		muteAll: function muteAll(val) {
			//静音
			var unChangeable;
			if (this.muteAllChecked) {
				unChangeable = 1;
			} else {
				unChangeable = 0;
			}
			var self = this;
			var mediaControlBuilder = new RL_MEET.MediaControlBuilder();
			mediaControlBuilder.setConfId(self.meetInfo.confId);
			mediaControlBuilder.setAction(2);
			mediaControlBuilder.setAllMember(2);
			mediaControlBuilder.setUnchangable(unChangeable);
			RL_MEET.MediaControl(mediaControlBuilder, function (e) {
				console.log(e);
				self.$message({
					message: self.$t('last.muteTip')
				});
				self.$parent.isAllmuet = true;
				self.isAllmuet = true;
				self.isMuteAllDialog = false;
			}, function (err) {
				console.log(err);
			});
		},
		unmuteAll: function unmuteAll() {
			var _this5 = this;

			//解除静音
			var self = this;
			var mediaControlBuilder = new RL_MEET.MediaControlBuilder();
			mediaControlBuilder.setConfId(self.meetInfo.confId);
			mediaControlBuilder.setAction(3);
			mediaControlBuilder.setUnchangable(1);
			mediaControlBuilder.setAllMember(2);
			RL_MEET.MediaControl(mediaControlBuilder, function (e) {
				console.log(e);
				_this5.$message({
					message: self.$t('last.unmuteTip')
				});
				self.$parent.isAllmuet = false;
				self.isAllmuet = false;
				// self.unmuteAllUnchangable()
			}, function (err) {
				console.log(err);
			});
		},
		unmuteAllUnchangable: function unmuteAllUnchangable() {
			var self = this;
			var mediaControlBuilder = new RL_MEET.MediaControlBuilder();
			mediaControlBuilder.setConfId(self.meetInfo.confId);
			mediaControlBuilder.setAction(3);
			mediaControlBuilder.setUnchangable(0);
			mediaControlBuilder.setAllMember(2);
			RL_MEET.MediaControl(mediaControlBuilder, function (e) {
				console.log(e);

				self.$parent.isAllmuet = false;
			}, function (err) {
				console.log(err);
			});
		},
		updateListUserName: function updateListUserName(item) {
			var self = this;
			if (this.isHost || this.SelfMeetUserId == item.memberId) {
				self.$prompt("请输入想要更改名字", "更改名字", {
					confirmButtonText: "确定",
					cancelButtonText: "取消",
					inputValidator: self.checkName
				}).then(function (_ref) {
					var value = _ref.value;

					if (item.memberId == self.SelfMeetUserId) {
						// room.selfUser.updateUserName(value);
					} else {
							// var user = room.getUser(item.id);
							// user.updateUserName(value);
						}
				}).catch(function () {});
			}
		},

		//检查名字是否符合
		checkName: function checkName(val) {
			var len = 0;
			var reg = /\s/g;
			if (reg.test(val)) {
				return "不允许输入空格";
			}
			for (var i = 0; i < val.length; i++) {
				if (val.charCodeAt(i) > 127 || val.charCodeAt(i) == 94) {
					len += 2;
				} else {
					len++;
				}
			}
			if (len == 0 || len > 16) {
				return "请输入1-16个字符长度";
			} else {
				return true;
			}
		}
	},
	filters: {
		FMTState: function FMTState(v) {
			if (v & 0x000200) {
				return "已拒绝";
			} else if (v & 0x000400) {
				return "接通中";
			} else if (v & 0x000800) {
				return "已挂断";
			} else if ((v & 0x000000) == 0) {
				return "已退出";
			} else {
				return v;
			}
		}
	}
});
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-48d10f8b","hasScoped":true,"transformToRequire":{"video":["src","poster"],"source":"src","img":"src","image":"xlink:href"},"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/meeting/merberlist.vue
var merberlist_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"merberDialog"},[_c('el-drawer',{directives:[{name:"drag",rawName:"v-drag"}],attrs:{"title":_vm.$t('meeting.participant'),"visible":_vm.isshow,"direction":"rtl","width":"500px","modal":false,"wrapperClosable":false,"before-close":_vm.handleClose},on:{"update:visible":function($event){_vm.isshow=$event}}},[(_vm.memberInObj)?_c('el-tabs',{staticClass:"MerberListBg",model:{value:(_vm.active),callback:function ($$v) {_vm.active=$$v},expression:"active"}},[_c('el-tab-pane',{attrs:{"label":_vm.$t('last.memberIn') + '('+Object.getOwnPropertyNames(_vm.memberInObj).length+')',"name":"1"}},[_c('div',{staticClass:"userList"},[_c('ul',_vm._l((_vm.memberInObj),function(user){return _c('li',{key:user.memberId},[_c('el-row',{attrs:{"type":"flex","align":"middle"}},[_c('el-col',{attrs:{"span":4}},[_c('div',{staticClass:"img"},[(user.photourl)?_c('span',[_c('img',{attrs:{"src":user.photourl,"alt":""}})]):_c('span',{style:({backgroundImage:_vm.getcolor(user.account)})},[_vm._v(_vm._s(_vm._f("nameslice")(user.userName)))])])]),_vm._v(" "),_c('el-col',{staticClass:"tl",attrs:{"span":10}},[_c('p',[_vm._v(_vm._s(user.userName)+" "),_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.IsHost(user.roleId)),expression:"IsHost(user.roleId)"}]},[_vm._v("("+_vm._s(_vm.$t('meeting.moderator'))+")")])]),_vm._v(" "),_c('p',[_vm._v(_vm._s(_vm._f("getTerminalUA")(user.memberId)))])]),_vm._v(" "),_c('el-col',{staticClass:"tr IconBg",attrs:{"span":10}},[(user.state & 0x000008)?_c('i',{staticClass:"RSIcon RSIcon-gongxiang colaf84",staticStyle:{"font-size":"40px"}}):_vm._e(),_vm._v(" "),_c('i',{directives:[{name:"show",rawName:"v-show",value:((user.state&0x00020000)&&user.roleId==11),expression:"(user.state&0x00020000)&&user.roleId==11"}],staticClass:"RSIcon RSIcon-jushou colred",staticStyle:{"font-size":"20px"}}),_vm._v(" "),_c('i',{directives:[{name:"show",rawName:"v-show",value:(!user.isOpenAudio),expression:"!user.isOpenAudio"}],staticClass:"RSIcon RSIcon-guanbimaikefeng colred",staticStyle:{"font-size":"22px"}}),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(user.isOpenAudio && user.memberId !== _vm.voiceIncentiveId),expression:"user.isOpenAudio && user.memberId !== voiceIncentiveId"}],staticClass:"IconDivBg"},[_c('svg',{staticClass:"icon",attrs:{"aria-hidden":"true"}},[_c('use',{attrs:{"xlink:href":"#RSIcon-kaiqimaikefeng1"}})])]),_vm._v(" "),_c('i',{directives:[{name:"show",rawName:"v-show",value:(user.isOpenAudio && user.memberId === _vm.voiceIncentiveId),expression:"user.isOpenAudio && user.memberId === voiceIncentiveId"}],staticClass:"iconfont icon-yuyinzhengzaishuohua colaf84"}),_vm._v(" "),_c('i',{directives:[{name:"show",rawName:"v-show",value:(user.isOpenVideo),expression:"user.isOpenVideo"}],staticClass:"RSIcon RSIcon-kaiqishexiangtou colaf84",staticStyle:{"font-size":"35px"}}),_vm._v(" "),_c('i',{directives:[{name:"show",rawName:"v-show",value:(!(user.isOpenVideo)),expression:"!(user.isOpenVideo)"}],staticClass:"RSIcon RSIcon-guanbishexiangtou colred",staticStyle:{"font-size":"35px"}}),_vm._v(" "),_c('el-dropdown',{directives:[{name:"show",rawName:"v-show",value:((_vm.isHost || user.memberId === _vm.SelfMeetUserId)),expression:"(isHost || user.memberId === SelfMeetUserId)"}],staticClass:"hoverMenu isHoverShow fr"},[_c('span',{staticClass:"el-dropdown-link"},[_c('i',{staticClass:"RSIcon RSIcon-gengduo",staticStyle:{"font-size":"20px"}})]),_vm._v(" "),_c('el-dropdown-menu',{attrs:{"slot":"dropdown"},slot:"dropdown"},[(user.isOpenAudio)?_c('el-dropdown-item',[_c('p',{on:{"click":function($event){return _vm.memberAudio(user,true)}}},[_vm._v("\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t"+_vm._s(_vm.$t('btn.close'))),_c('span',{directives:[{name:"show",rawName:"v-show",value:(user.memberId!=_vm.SelfMeetUserId),expression:"user.memberId!=SelfMeetUserId"}]},[_vm._v(_vm._s(_vm.$t('connect.otherSide')))]),_vm._v(_vm._s(_vm.$t('meeting.microphone'))+"\n\t\t\t\t\t\t\t\t\t\t\t\t\t")])]):_vm._e(),_vm._v(" "),((!user.isOpenAudio&&user.roleId!=11))?_c('el-dropdown-item',[_c('p',{on:{"click":function($event){return _vm.memberAudio(user,false)}}},[_vm._v("\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t"+_vm._s(_vm.$t('last.open'))),_c('span',{directives:[{name:"show",rawName:"v-show",value:(user.memberId!=_vm.SelfMeetUserId),expression:"user.memberId!=SelfMeetUserId"}]},[_vm._v(_vm._s(_vm.$t('connect.otherSide')))]),_vm._v(_vm._s(_vm.$t('meeting.microphone'))+"\n\t\t\t\t\t\t\t\t\t\t\t\t\t")])]):_vm._e(),_vm._v(" "),(user.isOpenVideo)?_c('el-dropdown-item',[_c('p',{on:{"click":function($event){return _vm.memberVideo(user,true)}}},[_vm._v("\n                            "+_vm._s(_vm.$t('btn.close'))),(user.memberId!=_vm.SelfMeetUserId)?_c('span',[_vm._v(_vm._s(_vm.$t('connect.otherSide')))]):_vm._e(),_vm._v(_vm._s(_vm.$t('meeting.camera'))+"\n\t\t\t\t\t\t\t\t\t\t\t\t\t")])]):_vm._e(),_vm._v(" "),(!user.isOpenVideo)?_c('el-dropdown-item',[_c('p',{on:{"click":function($event){return _vm.memberVideo(user,false)}}},[_vm._v("\n                            "+_vm._s(_vm.$t('last.open'))),_c('span',{directives:[{name:"show",rawName:"v-show",value:(user.memberId!=_vm.SelfMeetUserId),expression:"user.memberId!=SelfMeetUserId"}]},[_vm._v(_vm._s(_vm.$t('connect.otherSide')))]),_vm._v(_vm._s(_vm.$t('meeting.camera'))+"\n\t\t\t\t\t\t\t\t\t\t\t\t\t")])]):_vm._e(),_vm._v(" "),_c('el-dropdown-item',{directives:[{name:"show",rawName:"v-show",value:(_vm.isHost&&_vm.SelfMeetUserId!=user.memberId && !_vm.IsHost(user.roleId)),expression:"isHost&&SelfMeetUserId!=user.memberId && !IsHost(user.roleId)"}]},[_c('p',{on:{"click":function($event){return _vm.hostTransfer(user)}}},[_vm._v(_vm._s(_vm.$t('last.setHoster')))])]),_vm._v(" "),_c('el-dropdown-item',{directives:[{name:"show",rawName:"v-show",value:(_vm.isHost&&_vm.SelfMeetUserId!=user.memberId),expression:"isHost&&SelfMeetUserId!=user.memberId"}]},[_c('p',{on:{"click":function($event){return _vm.kictout(user)}}},[_vm._v(_vm._s(_vm.$t('meeting.removedFromMeeting')))])])],1)],1)],1)],1)],1)}),0)])]),_vm._v(" "),(Object.getOwnPropertyNames(_vm.memberOutObj).length > 0)?_c('el-tab-pane',{attrs:{"label":_vm.$t('meeting.waitingForEnter')+'('+Object.getOwnPropertyNames(_vm.memberOutObj).length+')',"name":"3"}},[_c('div',{staticClass:"userList"},[_c('ul',_vm._l((_vm.memberOutObj),function(item){return _c('li',[_c('el-row',{attrs:{"type":"flex","align":"middle"}},[_c('el-col',{attrs:{"span":4}},[_c('div',{staticClass:"img"},[(item.photourl)?_c('span',[_c('img',{attrs:{"src":item.photourl,"alt":""}})]):_c('span',{style:({backgroundImage:_vm.getcolor(item.account)})},[_vm._v(_vm._s(_vm._f("nameslice")(item.userName)))])])]),_vm._v(" "),_c('el-col',{staticClass:"tl",attrs:{"span":10}},[_c('p',[_vm._v(_vm._s(item.userName))]),_vm._v(" "),_c('p',[_vm._v(_vm._s(item.stateContent))])]),_vm._v(" "),_c('el-col',{staticClass:"tr IconBg",attrs:{"span":10}},[_c('el-dropdown',{directives:[{name:"show",rawName:"v-show",value:(_vm.isHost),expression:"isHost"}],staticClass:"hoverMenu isHoverShow fr"},[_c('span',{staticClass:"el-dropdown-link"},[_c('i',{staticClass:"RSIcon RSIcon-gengduo",staticStyle:{"font-size":"20px"}})]),_vm._v(" "),_c('el-dropdown-menu',{attrs:{"slot":"dropdown"},slot:"dropdown"},[_c('el-dropdown-item',{directives:[{name:"show",rawName:"v-show",value:(_vm.isHost&&_vm.SelfMeetUserId!=item.memberId),expression:"isHost&&SelfMeetUserId!=item.memberId"}]},[_c('p',{on:{"click":function($event){return _vm.kictout(item)}}},[_vm._v(_vm._s(_vm.$t('meeting.removedFromMeeting')))])])],1)],1)],1)],1)],1)}),0)])]):_vm._e(),_vm._v(" "),(_vm.isHost&&false)?_c('el-tab-pane',{attrs:{"label":"未静音","name":"2"}},[_c('div',{staticClass:"userList"},[_c('ul',_vm._l((_vm.memberInObj),function(user){return _c('li',{directives:[{name:"show",rawName:"v-show",value:((user.isOpenAudio)),expression:"(user.isOpenAudio)"}],key:'1'+user.memberId},[_c('el-row',{attrs:{"type":"flex","align":"middle"}},[_c('el-col',{attrs:{"span":4}},[_c('div',{staticClass:"img"},[(user.photourl)?_c('span',[_c('img',{attrs:{"src":user.photourl,"alt":""}})]):_c('span',{style:({backgroundImage:_vm.getcolor(user.account)})},[_vm._v(_vm._s(_vm._f("nameslice")(user.userName)))])])]),_vm._v(" "),_c('el-col',{staticClass:"tl",attrs:{"span":10}},[_c('p',[_vm._v(_vm._s(user.userName)+" "),_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.IsHost(user.roleId)),expression:"IsHost(user.roleId)"}]},[_vm._v("(主持人)")])]),_vm._v(" "),_c('p',[_vm._v(_vm._s(_vm._f("getTerminalUA")(user.memberId)))])]),_vm._v(" "),_c('el-col',{staticClass:"tr IconBg",attrs:{"span":10}},[_c('i',{directives:[{name:"show",rawName:"v-show",value:(user.memberId==_vm.screenUserId),expression:"user.memberId==screenUserId"}],staticClass:"RSIcon RSIcon-gongxiang colaf84",staticStyle:{"font-size":"40px"}}),_vm._v(" "),_c('i',{directives:[{name:"show",rawName:"v-show",value:((user.state&0x00020000)&&user.roleId==11),expression:"(user.state&0x00020000)&&user.roleId==11"}],staticClass:"RSIcon RSIcon-jushou colred",staticStyle:{"font-size":"20px"}}),_vm._v(" "),_c('i',{directives:[{name:"show",rawName:"v-show",value:(!user.isOpenAudio),expression:"!user.isOpenAudio"}],staticClass:"RSIcon RSIcon-guanbimaikefeng colred",staticStyle:{"font-size":"22px"}}),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(user.isOpenAudio),expression:"user.isOpenAudio"}],staticClass:"IconDivBg"},[_c('svg',{staticClass:"icon",attrs:{"aria-hidden":"true"}},[_c('use',{attrs:{"xlink:href":"#RSIcon-kaiqimaikefeng1"}})])]),_vm._v(" "),_c('i',{directives:[{name:"show",rawName:"v-show",value:(user.isOpenVideo),expression:"user.isOpenVideo"}],staticClass:"RSIcon RSIcon-kaiqishexiangtou colaf84",staticStyle:{"font-size":"35px"}}),_vm._v(" "),_c('i',{directives:[{name:"show",rawName:"v-show",value:(!(user.isOpenVideo)),expression:"!(user.isOpenVideo)"}],staticClass:"RSIcon RSIcon-guanbishexiangtou colred",staticStyle:{"font-size":"35px"}}),_vm._v(" "),_c('el-dropdown',{directives:[{name:"show",rawName:"v-show",value:((_vm.isHost||user.memberId==_vm.SelfMeetUserId)),expression:"(isHost||user.memberId==SelfMeetUserId)"}],staticClass:"hoverMenu isHoverShow fr"},[_c('span',{staticClass:"el-dropdown-link"},[_c('i',{staticClass:"RSIcon RSIcon-gengduo",staticStyle:{"font-size":"20px"}})]),_vm._v(" "),_c('el-dropdown-menu',{attrs:{"slot":"dropdown"},slot:"dropdown"},[_c('el-dropdown-item',{directives:[{name:"show",rawName:"v-show",value:((_vm.isHost||user.memberId==_vm.SelfMeetUserId)&&(user.isOpenAudio)),expression:"(isHost||user.memberId==SelfMeetUserId)&&(user.isOpenAudio)"}]},[_c('p',{on:{"click":function($event){return _vm.memberAudio(user,true)}}},[_vm._v("\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t关闭"),_c('span',{directives:[{name:"show",rawName:"v-show",value:(user.memberId!=_vm.SelfMeetUserId),expression:"user.memberId!=SelfMeetUserId"}]},[_vm._v("对方")]),_vm._v("麦克风 ")])]),_vm._v(" "),(user.memberId==_vm.SelfMeetUserId)?_c('el-dropdown-item',{directives:[{name:"show",rawName:"v-show",value:((!user.isOpenAudio&&user.roleId!=11)),expression:"(!user.isOpenAudio&&user.roleId!=11)"}]},[_c('p',{on:{"click":function($event){return _vm.memberAudio(user,false)}}},[_vm._v("打开麦克风")])]):_vm._e(),_vm._v(" "),(user.memberId!=_vm.SelfMeetUserId)?_c('el-dropdown-item',{directives:[{name:"show",rawName:"v-show",value:((_vm.isHost||user.memberId==_vm.SelfMeetUserId) &&(!(user.isOpenAudio))||(_vm.isHost||user.memberId==_vm.SelfMeetUserId)&&((user.state&0x00020000))),expression:"(isHost||user.memberId==SelfMeetUserId) &&(!(user.isOpenAudio))||(isHost||user.memberId==SelfMeetUserId)&&((user.state&0x00020000))"}]},[_c('p',{on:{"click":function($event){return _vm.memberAudio(user,false)}}},[_vm._v("\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t打开"),_c('span',{directives:[{name:"show",rawName:"v-show",value:(user.memberId!=_vm.SelfMeetUserId),expression:"user.memberId!=SelfMeetUserId"}]},[_vm._v("对方")]),_vm._v("麦克风 ")])]):_vm._e(),_vm._v(" "),_c('el-dropdown-item',{directives:[{name:"show",rawName:"v-show",value:((_vm.isHost||user.memberId==_vm.SelfMeetUserId)&&(user.isOpenVideo)),expression:"(isHost||user.memberId==SelfMeetUserId)&&(user.isOpenVideo)"}]},[_c('p',{on:{"click":function($event){return _vm.memberVideo(user,true)}}},[_vm._v("关闭"),_c('span',{directives:[{name:"show",rawName:"v-show",value:(user.memberId!=_vm.SelfMeetUserId),expression:"user.memberId!=SelfMeetUserId"}]},[_vm._v("对方")]),_vm._v("摄像头")])]),_vm._v(" "),_c('el-dropdown-item',{directives:[{name:"show",rawName:"v-show",value:((_vm.isHost||user.memberId==_vm.SelfMeetUserId)&&!(user.isOpenVideo)),expression:"(isHost||user.memberId==SelfMeetUserId)&&!(user.isOpenVideo)"}]},[_c('p',{on:{"click":function($event){return _vm.memberVideo(user,false)}}},[_vm._v("\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t打开"),_c('span',{directives:[{name:"show",rawName:"v-show",value:(user.memberId!=_vm.SelfMeetUserId),expression:"user.memberId!=SelfMeetUserId"}]},[_vm._v("对方")]),_vm._v("摄像头")])]),_vm._v(" "),(false)?_c('el-dropdown-item',{directives:[{name:"show",rawName:"v-show",value:((_vm.isHost||user.memberId==_vm.SelfMeetUserId)),expression:"(isHost||user.memberId==SelfMeetUserId)"}]},[_c('p',{on:{"click":function($event){return _vm.updateListUserName(user)}}},[_vm._v("改名")])]):_vm._e(),_vm._v(" "),(false)?_c('el-dropdown-item',{directives:[{name:"show",rawName:"v-show",value:(user.memberId!=_vm.SelfMeetUserId),expression:"user.memberId!=SelfMeetUserId"}]},[_c('p',{on:{"click":function($event){return _vm.addFriend(user)}}},[_vm._v("添加至联系人")])]):_vm._e(),_vm._v(" "),_c('el-dropdown-item',{directives:[{name:"show",rawName:"v-show",value:(user.memberId==_vm.screenUserId),expression:"user.memberId==screenUserId"}]},[_c('p',{on:{"click":function($event){return _vm.stopScreen(user)}}},[_vm._v("关闭共享")])]),_vm._v(" "),_c('el-dropdown-item',{directives:[{name:"show",rawName:"v-show",value:(_vm.isHost&&_vm.SelfMeetUserId!=user.memberId),expression:"isHost&&SelfMeetUserId!=user.memberId"}]},[_c('p',{on:{"click":function($event){return _vm.hostTransfer(user)}}},[_vm._v("设为主持人")])]),_vm._v(" "),(false)?_c('el-dropdown-item',{directives:[{name:"show",rawName:"v-show",value:(_vm.isHost&&_vm.SelfMeetUserId!=user.memberId),expression:"isHost&&SelfMeetUserId!=user.memberId"}]},[_c('p',{on:{"click":function($event){return _vm.YHkictout(user)}}},[_vm._v("断开")])]):_vm._e(),_vm._v(" "),_c('el-dropdown-item',{directives:[{name:"show",rawName:"v-show",value:(_vm.isHost&&_vm.SelfMeetUserId!=user.memberId),expression:"isHost&&SelfMeetUserId!=user.memberId"}]},[_c('p',{on:{"click":function($event){return _vm.kictout(user)}}},[_vm._v("踢出会议")])])],1)],1)],1)],1)],1)}),0)])]):_vm._e()],1):_vm._e(),_vm._v(" "),(_vm.isHost)?_c('div',{staticClass:"MuteBtnBg"},[_c('el-row',[_c('el-col',{staticStyle:{"padding":"0px"},attrs:{"span":12}},[_c('el-button',{staticClass:"tc",staticStyle:{"width":"100%","border-right":"1px solid white","border-radius":"0"},attrs:{"type":"primary"},on:{"click":_vm.allMuteClick}},[_vm._v(_vm._s(_vm.isAllmuet?_vm.$t('last.unMute'):_vm.$t('last.mute')))])],1),_vm._v(" "),_c('el-col',{staticStyle:{"padding":"0px"},attrs:{"span":12}},[_c('el-button',{staticClass:" tc",staticStyle:{"width":"100%","border-radius":"0"},attrs:{"type":"primary"},on:{"click":_vm.isAllCloseCameraClick}},[_vm._v("\n\t\t\t\t\t\t\t"+_vm._s(_vm.isAllCloseCamera?_vm.$t('last.unOpenCamera'):_vm.$t('last.closeCamera')))])],1),_vm._v(" "),_c('div',{staticClass:"cb"})],1)],1):_vm._e()],1),_vm._v(" "),_c('el-dialog',{attrs:{"title":_vm.$t('modelMessage.prompt'),"visible":_vm.isMuteAllDialog,"width":"400px"},on:{"update:visible":function($event){_vm.isMuteAllDialog=$event}}},[_c('p',[_vm._v(_vm._s(_vm.$t('last.confirmMute')))]),_vm._v(" "),_c('span',{staticClass:"dialog-footer",attrs:{"slot":"footer"},slot:"footer"},[_c('el-button',{on:{"click":function($event){_vm.isMuteAllDialog = false}}},[_vm._v(_vm._s(_vm.$t('btn.cancel')))]),_vm._v(" "),_c('el-button',{attrs:{"type":"primary"},on:{"click":function($event){return _vm.isMuteAll()}}},[_vm._v(_vm._s(_vm.$t('btn.determine')))])],1)])],1)}
var merberlist_staticRenderFns = []
var merberlist_esExports = { render: merberlist_render, staticRenderFns: merberlist_staticRenderFns }
/* harmony default export */ var meeting_merberlist = (merberlist_esExports);
// CONCATENATED MODULE: ./src/components/meeting/merberlist.vue
function merberlist_injectStyle (ssrContext) {
  __webpack_require__("yE1H")
  __webpack_require__("N7PQ")
}
var merberlist_normalizeComponent = __webpack_require__("VU/8")
/* script */


/* template */

/* template functional */
var merberlist___vue_template_functional__ = false
/* styles */
var merberlist___vue_styles__ = merberlist_injectStyle
/* scopeId */
var merberlist___vue_scopeId__ = "data-v-48d10f8b"
/* moduleIdentifier (server only) */
var merberlist___vue_module_identifier__ = null
var merberlist_Component = merberlist_normalizeComponent(
  merberlist,
  meeting_merberlist,
  merberlist___vue_template_functional__,
  merberlist___vue_styles__,
  merberlist___vue_scopeId__,
  merberlist___vue_module_identifier__
)

/* harmony default export */ var components_meeting_merberlist = (merberlist_Component.exports);

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./src/components/meeting/setMainHall.vue

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

 //默认头像


/* harmony default export */ var setMainHall = ({
  props: ['isShow', 'SelfMeetUserId'],
  data: function data() {
    return {
      defaultImg: defaultAvatar_default.a,
      mainHall: ''
    };
  },

  computed: extends_default()({}, Object(vuex_esm["b" /* mapGetters */])(['memberInObj', 'meetInfo', 'mainVenue'])),
  watch: {
    mainVenue: function mainVenue(value) {
      this.mainHall = value;
    }
  },
  mounted: function mounted() {
    if (this.mainVenue) {
      this.mainHall = this.mainVenue;
    }
    console.log('this.mainVenue===', this.mainVenue);
  },

  methods: {
    checkChange: function checkChange(e, user) {
      console.log('===e', e, user);
      if (e) {
        this.mainHall = user.memberId;
      } else {
        this.mainHall = '';
      }
    },
    handleClose: function handleClose() {
      this.$parent.closeDialog('setMainHallDialog');
    },
    setMainHallEvent: function setMainHallEvent() {
      var _this = this;

      var data = {
        LayoutIdx: "1_3",
        MainVenue: this.mainHall,
        confId: this.meetInfo.confId
      };
      RL_MEET.SetConfLayout(data, function (res) {
        _this.handleClose();
        var resp = JSON.parse(res.result);
        if (resp.statusCode == '000000') {} else {
          _this.$message.error(resp.statusMsg);
        }
      }, function (error) {
        console.info(error);
      });
    },
    noImgFind: function noImgFind(event) {
      console.log("未正确加载到图片;");
      var img = event.srcElement;
      img.src = this.defaultImg;
      img.οnerrοr = null; //控制不要一直跳动
    }
  }
});
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-6188cde9","hasScoped":true,"transformToRequire":{"video":["src","poster"],"source":"src","img":"src","image":"xlink:href"},"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/meeting/setMainHall.vue
var setMainHall_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('el-dialog',{directives:[{name:"dialogDrag",rawName:"v-dialogDrag"}],attrs:{"title":_vm.$t('meeting.setMainVenue'),"visible":_vm.isShow,"center":"","width":"500px","modal":false,"close-on-click-modal":false,"modal-append-to-body":false,"custom-class":"merberDialog","before-close":_vm.handleClose},on:{"update:visible":function($event){_vm.isShow=$event}}},[_c('div',{staticClass:"userList"},[_c('ul',{staticClass:"main-hall"},_vm._l((_vm.memberInObj),function(user){return _c('li',{key:'hostLiBg'+user.memberId},[_c('el-row',{attrs:{"type":"flex","align":"middle"}},[_c('el-col',{attrs:{"span":4}},[_c('img',{attrs:{"src":user.photoUrl?user.photoUrl:_vm.defaultImg,"alt":""},on:{"error":_vm.noImgFind}})]),_vm._v(" "),_c('el-col',{staticClass:"tl",attrs:{"span":10}},[_c('p',[_vm._v(_vm._s(user.userName)+" "),(user.memberId)?_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.IsHost(user.roleId)),expression:"IsHost(user.roleId)"}]},[_vm._v("(主持人)")]):_vm._e()]),_vm._v(" "),_c('p',[_vm._v(_vm._s(_vm._f("getTerminalUA")(user.memberId)))])]),_vm._v(" "),_c('el-col',{staticClass:"tr IconBg",attrs:{"span":5}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(user.isOpenAudio),expression:"user.isOpenAudio"}],staticClass:"IconDivBg"},[_c('svg',{staticClass:"icon",attrs:{"aria-hidden":"true"}},[_c('use',{attrs:{"xlink:href":"#RSIcon-kaiqimaikefeng1"}})])]),_vm._v(" "),_c('i',{directives:[{name:"show",rawName:"v-show",value:(user.isOpenVideo),expression:"user.isOpenVideo"}],staticClass:"RSIcon RSIcon-kaiqishexiangtou colaf84",staticStyle:{"font-size":"35px"}}),_vm._v(" "),_c('i',{directives:[{name:"show",rawName:"v-show",value:(!(user.isOpenVideo)),expression:"!(user.isOpenVideo)"}],staticClass:"RSIcon RSIcon-guanbishexiangtou colred",staticStyle:{"font-size":"35px"}})]),_vm._v(" "),_c('el-col',{staticClass:"tr IconBg",attrs:{"span":5}},[_c('el-checkbox',{on:{"change":function($event){return _vm.checkChange($event, user)}},model:{value:(user.memberId === _vm.mainHall),callback:function ($$v) {_vm.$set(user, "memberId === mainHall", $$v)},expression:"user.memberId === mainHall"}})],1)],1)],1)}),0)]),_vm._v(" "),_c('span',{staticClass:"dialog-footer",attrs:{"slot":"footer"},slot:"footer"},[_c('el-button',{on:{"click":_vm.handleClose}},[_vm._v(_vm._s(_vm.$t('btn.cancel')))]),_vm._v(" "),_c('el-button',{staticStyle:{"margin-left":"30px"},attrs:{"type":"primary"},on:{"click":_vm.setMainHallEvent}},[_vm._v(_vm._s(_vm.$t('btn.determine')))])],1)])}
var setMainHall_staticRenderFns = []
var setMainHall_esExports = { render: setMainHall_render, staticRenderFns: setMainHall_staticRenderFns }
/* harmony default export */ var meeting_setMainHall = (setMainHall_esExports);
// CONCATENATED MODULE: ./src/components/meeting/setMainHall.vue
function setMainHall_injectStyle (ssrContext) {
  __webpack_require__("CoeO")
  __webpack_require__("sY2q")
}
var setMainHall_normalizeComponent = __webpack_require__("VU/8")
/* script */


/* template */

/* template functional */
var setMainHall___vue_template_functional__ = false
/* styles */
var setMainHall___vue_styles__ = setMainHall_injectStyle
/* scopeId */
var setMainHall___vue_scopeId__ = "data-v-6188cde9"
/* moduleIdentifier (server only) */
var setMainHall___vue_module_identifier__ = null
var setMainHall_Component = setMainHall_normalizeComponent(
  setMainHall,
  meeting_setMainHall,
  setMainHall___vue_template_functional__,
  setMainHall___vue_styles__,
  setMainHall___vue_scopeId__,
  setMainHall___vue_module_identifier__
)

/* harmony default export */ var components_meeting_setMainHall = (setMainHall_Component.exports);

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./src/components/meeting/setLayout.vue

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ var setLayout = ({
  props: ['isShow', 'merberLists', 'isHost', 'confId'],
  watch: {
    checkList: function checkList(val) {
      for (var j = 0; j < this.merberLists.length; j++) {
        if (this.checkList.indexOf(this.merberLists[j].memberId) > -1) {
          this.$set(this.merberLists[j], 'isChecked', true);
        } else {
          this.$set(this.merberLists[j], 'isChecked', false);
        }
      }
    },
    memberList: function memberList(val) {
      this.merberLists = [];
      if (val) {
        for (var i = 0; i < val.length; i++) {
          var merber = val[i];
          if (merber.state & 0x000001 && merber.state & 0x000100) {
            this.merberLists.push(merber);
          }
        }
      }
    }
  },
  data: function data() {
    return {
      checkList: [],
      assignMemberDialog: false,
      innerVisible: false,
      assignArray: [],
      assignArray1: [],
      assignArray3: [],
      assignArray4: [],
      newAssignArray: '',
      newAssignArray1: '',
      newAssignArray3: '',
      newAssignArray4: '',
      assignIndex: 1,
      radioTime: 10,
      checkIsAll: 0,
      checkIsAll1: 0,
      checkIsAll3: 0,
      checkIsAll4: 0,
      defaultAvatar: defaultAvatar_default.a,
      radioLayout: '1_1'
    };
  },
  created: function created() {
    console.log(this.memberList, "this.memberList");
  },

  methods: {
    choosePerson: function choosePerson() {
      if (this.checkIsAll == 1 || this.checkIsAll1 == 1 || this.checkIsAll3 == 1 || this.checkIsAll4 == 1) {
        console.log("我要选择全部人啦...");
        // todo;
      }
    },
    assignWindow: function assignWindow() {
      this.assignMemberDialog = true;
    },
    assignMember: function assignMember() {
      this.innerVisible = true;
    },
    assignHandleClose: function assignHandleClose() {
      this.checkList = [];
      this.$parent.closeDialog('isSetLayout');
    },
    arrayNorepeat: function arrayNorepeat(arr) {
      var newArr = [];
      for (var i = 0; i < arr.length; i++) {
        if (newArr.indexOf(arr[i]) == -1) {
          newArr.push(arr[i]);
        }
      }
      return newArr;
    },
    assignMembers: function assignMembers() {
      console.log("开始选人了", this.checkList);
    },
    handleClose: function handleClose() {
      this.$parent.closeDialog('isSetLayout');
    },
    cancelAssign: function cancelAssign() {
      for (var j = 0; j < this.merberLists.length; j++) {
        if (this.checkList.indexOf(this.merberLists[j].memberId) > -1) {
          this.$set(this.merberLists[j], 'isChecked', false);
        }
      }
      this.innerVisible = false;
      this.checkList = [];
    },
    setLayoutObj: function setLayoutObj(position, interval, assignArrayVal) {
      var screenArr = [];
      for (var i = 0; i < this.checkList.length; i++) {
        var screenObj = {};
        for (var j = 0; j < this.merberLists.length; j++) {
          var positionObj = {};
          if (this.checkList[i] == this.merberLists[j].memberId) {
            positionObj.pos = position, positionObj.interval = interval, screenObj.userName = this.merberLists[j].userName;
            screenObj.memberID = this.checkList[i], screenObj.idType = this.merberLists[j].idType, screenArr.push(screenObj);
            positionObj.screen = screenArr, assignArrayVal.push(positionObj);
          }
        }
      }
    },
    confirmAssignMember: function confirmAssignMember() {
      // 1v1主屏;
      if (this.assignIndex == 0) {
        this.setLayoutObj(0, this.radioTime * 1000, this.assignArray);
        console.log(this.assignArray, this.radioTime * 1000, "这是1_1第一个窗口的array");
        this.newAssignArray = this.setLayoutPosition(this.assignArray);
      }
      if (this.assignIndex == 1) {
        this.setLayoutObj(0, this.radioTime * 1000, this.assignArray1);
        console.log(this.assignArray1, this.radioTime * 1000, "这是1_3第一个窗口的array");
        this.newAssignArray1 = this.setLayoutPosition(this.assignArray1);
      }
      if (this.assignIndex == 3) {
        this.setLayoutObj(2, this.radioTime * 1000, this.assignArray3);
        console.log(this.assignArray3, this.radioTime * 1000, "这是1_3第三个窗口的array");
        this.newAssignArray3 = this.setLayoutPosition(this.assignArray3);
      }
      if (this.assignIndex == 4) {
        this.setLayoutObj(3, this.radioTime * 1000, this.assignArray4);
        console.log(this.assignArray4, this.radioTime * 1000, "这是1_3第四个窗口的array");
        this.newAssignArray4 = this.setLayoutPosition(this.assignArray4);
      }
      this.innerVisible = false;
      this.checkList = [];
    },
    setLayoutPosition: function setLayoutPosition(obj) {
      if (obj) {
        var position = '';
        for (var i = 0; i < obj.length; i++) {
          position = {
            "Pos": [obj[i].pos],
            "screen": obj[i].screen,
            "interval": obj[i].interval
          };
        }
        console.log(position, "这是return出去的拼好的position");
        return position;
      }
    },
    setLayoutReq: function setLayoutReq(assignArray) {
      var _this = this;

      var that = this;
      var SetLayoutBuilder = new RL_MEET.SetLayoutBuilder();
      SetLayoutBuilder.setConfId(this.confId);
      SetLayoutBuilder.setLayoutIdx(this.radioLayout);
      SetLayoutBuilder.setLayoutPos(this.$Base64.encode(stringify_default()(assignArray)));
      // SetLayoutBuilder.setMainVenue();   // 设置主会场模式 暂时用不到;
      SetLayoutBuilder.setDeviceType("21");
      RL_MEET.SetLayout(SetLayoutBuilder, function (e) {
        var resp = JSON.parse(e.result);
        if (resp.statusCode == "000000") {
          that.$message({
            message: "设置成功",
            type: "success"
          });
          that.$parent.closeDialog('isSetLayout');
          _this.checkList = [];
        }
      }).catch(function () {
        that.$message({
          type: 'info',
          message: '已取消设置'
        });
      });
    },
    confirmAssign: function confirmAssign() {
      var _this2 = this;

      var that = this;
      this.$confirm('您确定执行本次操作吗?', '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
      }).then(function () {
        var assignArray = [];
        if (_this2.newAssignArray) {
          assignArray.push(_this2.newAssignArray);
        }
        if (_this2.newAssignArray1) {
          assignArray.push(_this2.newAssignArray1);
        }
        if (_this2.newAssignArray3) {
          assignArray.push(_this2.newAssignArray3);
        }
        if (_this2.newAssignArray4) {
          assignArray.push(_this2.newAssignArray4);
        }
        console.log(assignArray, _this2.newAssignArray1, "这是指定的人呢");
        that.setLayoutReq(assignArray);
      });
    },
    closeLayout: function closeLayout() {
      var that = this;
      this.$confirm('您确定执行本次操作吗?', '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
      }).then(function () {
        that.setLayoutReq();
        (function (err) {
          console.log(err);
        });
      });
      // that.$message({
      //   type: 'success',
      //   message: '取消布局成功!'
      // });
    }
  }
});
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-ab23aede","hasScoped":false,"transformToRequire":{"video":["src","poster"],"source":"src","img":"src","image":"xlink:href"},"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/meeting/setLayout.vue
var setLayout_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('el-dialog',{attrs:{"title":"参会人布局","width":"600px","visible":_vm.isShow,"center":"","before-close":_vm.handleClose},on:{"update:visible":function($event){_vm.isShow=$event}}},[_c('el-dialog',{attrs:{"width":"400px","title":"配置","visible":_vm.innerVisible,"center":"","append-to-body":""},on:{"update:visible":function($event){_vm.innerVisible=$event}}},[(false)?_c('div',{staticStyle:{"margin-bottom":"10px"}},[_c('span',[_vm._v("布局选项：")]),_vm._v(" "),(_vm.assignIndex == '0')?_c('el-radio-group',{on:{"change":_vm.choosePerson},model:{value:(_vm.checkIsAll),callback:function ($$v) {_vm.checkIsAll=$$v},expression:"checkIsAll"}},[_c('el-radio',{attrs:{"label":1}},[_vm._v("轮巡所有人")]),_vm._v(" "),_c('el-radio',{attrs:{"label":2}},[_vm._v("轮巡指定人")])],1):(_vm.assignIndex == '1')?_c('el-radio-group',{on:{"change":_vm.choosePerson},model:{value:(_vm.checkIsAll1),callback:function ($$v) {_vm.checkIsAll1=$$v},expression:"checkIsAll1"}},[_c('el-radio',{attrs:{"label":1}},[_vm._v("轮巡所有人")]),_vm._v(" "),_c('el-radio',{attrs:{"label":2}},[_vm._v("轮巡指定人")])],1):(_vm.assignIndex == '3')?_c('el-radio-group',{on:{"change":_vm.choosePerson},model:{value:(_vm.checkIsAll3),callback:function ($$v) {_vm.checkIsAll3=$$v},expression:"checkIsAll3"}},[_c('el-radio',{attrs:{"label":1}},[_vm._v("轮巡所有人")]),_vm._v(" "),_c('el-radio',{attrs:{"label":2}},[_vm._v("轮巡指定人")])],1):(_vm.assignIndex == '4')?_c('el-radio-group',{on:{"change":_vm.choosePerson},model:{value:(_vm.checkIsAll4),callback:function ($$v) {_vm.checkIsAll4=$$v},expression:"checkIsAll4"}},[_c('el-radio',{attrs:{"label":1}},[_vm._v("轮巡所有人")]),_vm._v(" "),_c('el-radio',{attrs:{"label":2}},[_vm._v("轮巡指定人")])],1):_vm._e()],1):_vm._e(),_vm._v(" "),_c('div',{staticStyle:{"margin-bottom":"10px"}},[_c('p',{staticStyle:{"margin-bottom":"10px"}},[_vm._v("轮巡时间：")]),_vm._v(" "),_c('el-radio-group',{model:{value:(_vm.radioTime),callback:function ($$v) {_vm.radioTime=$$v},expression:"radioTime"}},[_c('el-radio',{attrs:{"label":10}},[_vm._v("10秒")]),_vm._v(" "),_c('el-radio',{attrs:{"label":30}},[_vm._v("30秒")]),_vm._v(" "),_c('el-radio',{attrs:{"label":60}},[_vm._v("60秒")]),_vm._v(" "),_c('el-radio',{attrs:{"label":120}},[_vm._v("120秒")])],1)],1),_vm._v(" "),_c('div',{staticStyle:{"margin-bottom":"10px"}},[_c('p',{staticStyle:{"margin-bottom":"10px"}},[_vm._v("选择人员：")]),_vm._v(" "),_c('el-checkbox-group',{on:{"change":_vm.assignMembers},model:{value:(_vm.checkList),callback:function ($$v) {_vm.checkList=$$v},expression:"checkList"}},_vm._l((_vm.merberLists),function(item){return _c('div',{key:item.key},[_c('el-checkbox',{attrs:{"label":item.memberId,"name":item.userName},model:{value:(item.isChecked),callback:function ($$v) {_vm.$set(item, "isChecked", $$v)},expression:"item.isChecked"}},[_c('img',{attrs:{"width":"20px","height":"20px","src":_vm.defaultAvatar,"alt":""}}),_vm._v(" "),_c('span',[_vm._v(_vm._s(item.isChecked)+" "+_vm._s(item.userName))])])],1)}),0)],1),_vm._v(" "),_c('span',{staticClass:"dialog-footer",attrs:{"slot":"footer"},slot:"footer"},[_c('el-button',{on:{"click":_vm.cancelAssign}},[_vm._v("取 消")]),_vm._v(" "),_c('el-button',{attrs:{"type":"primary"},on:{"click":function($event){return _vm.confirmAssignMember()}}},[_vm._v("保存")])],1)]),_vm._v(" "),_c('el-col',{attrs:{"span":4}},[_c('ul',{staticClass:"oneToOne",on:{"click":function($event){_vm.radioLayout='1_1'}}},[_c('li')]),_vm._v(" "),_c('el-radio',{staticClass:"oneToOneRadio",attrs:{"label":"1_1"},model:{value:(_vm.radioLayout),callback:function ($$v) {_vm.radioLayout=$$v},expression:"radioLayout"}},[_vm._v(" * ")]),_vm._v(" "),_c('ul',{staticClass:"oneToThree",on:{"click":function($event){_vm.radioLayout='1_3'}}},[_c('li'),_vm._v(" "),_c('li'),_vm._v(" "),_c('li'),_vm._v(" "),_c('li')]),_vm._v(" "),_c('el-radio',{staticClass:"oneToOneRadio",attrs:{"label":"1_3"},model:{value:(_vm.radioLayout),callback:function ($$v) {_vm.radioLayout=$$v},expression:"radioLayout"}},[_vm._v(" * ")])],1),_vm._v(" "),(_vm.radioLayout=='1_1')?_c('el-col',{staticClass:"oneToOneLayout",staticStyle:{"height":"300px"},attrs:{"span":20}},[_c('div',{staticClass:"dialogMainDiv"},[(_vm.checkIsAll == 1)?_c('p',{on:{"click":function($event){_vm.assignMember(),_vm.assignIndex = '0'}}},[_vm._v("轮巡所有人")]):(_vm.checkIsAll == 2)?_c('p',{on:{"click":function($event){_vm.assignMember(),_vm.assignIndex = '0'}}},[_vm._v("轮巡指定人")]):(_vm.checkIsAll == 0)?_c('p',{on:{"click":function($event){_vm.assignMember(),_vm.assignIndex = '0'}}},[_vm._v("语音激励")]):_vm._e(),_vm._v(" "),_c('el-col',{staticStyle:{"height":"100px"}},[_c('div',{staticClass:"oneToOneMyself"},[_c('p',[_vm._v("自己不可指定")])])])],1)]):_vm._e(),_vm._v(" "),(_vm.radioLayout=='1_3')?_c('div',{staticClass:"oneToThreeLayout"},[_c('el-col',{staticStyle:{"height":"300px"},attrs:{"span":16}},[_c('div',{staticClass:"dialogMainDiv"},[(_vm.checkIsAll1 == 1)?_c('p',{on:{"click":function($event){_vm.assignMember(),_vm.assignIndex = '1'}}},[_vm._v("轮巡所有人")]):(_vm.checkIsAll1 == 2)?_c('p',{on:{"click":function($event){_vm.assignMember(),_vm.assignIndex = '1'}}},[_vm._v("轮巡指定人")]):(_vm.checkIsAll1 == 0)?_c('p',{on:{"click":function($event){_vm.assignMember(),_vm.assignIndex = '1'}}},[_vm._v("语音激励")]):_vm._e()])]),_vm._v(" "),_c('el-col',{staticStyle:{"height":"300px"},attrs:{"span":4}},[_c('div',{staticClass:"dialogMyself"},[_c('p',[_vm._v("自己不可指定")])]),_vm._v(" "),_c('div',{staticClass:"dialogRightDiv"},[(_vm.checkIsAll3 == 1)?_c('p',{on:{"click":function($event){_vm.assignMember(),_vm.assignIndex = '3'}}},[_vm._v("轮巡所有人")]):(_vm.checkIsAll3 == 2)?_c('p',{on:{"click":function($event){_vm.assignMember(),_vm.assignIndex = '3'}}},[_vm._v("轮巡指定人")]):(_vm.checkIsAll3 == 0)?_c('p',{on:{"click":function($event){_vm.assignMember(),_vm.assignIndex = '3'}}},[_vm._v("语音激励")]):_vm._e()]),_vm._v(" "),_c('div',{staticClass:"dialogRightDiv"},[(_vm.checkIsAll4 == 1)?_c('p',{on:{"click":function($event){_vm.assignMember(),_vm.assignIndex = '4'}}},[_vm._v("轮巡所有人")]):(_vm.checkIsAll4 == 2)?_c('p',{on:{"click":function($event){_vm.assignMember(),_vm.assignIndex = '4'}}},[_vm._v("轮巡指定人")]):(_vm.checkIsAll4 == 0)?_c('p',{on:{"click":function($event){_vm.assignMember(),_vm.assignIndex = '4'}}},[_vm._v("语音激励")]):_vm._e()])])],1):_vm._e(),_vm._v(" "),_c('div',{staticClass:"dialog-footer",attrs:{"slot":"footer"},slot:"footer"},[_c('el-button',{on:{"click":_vm.closeLayout}},[_vm._v("关闭布局")]),_vm._v(" "),_c('el-button',{on:{"click":_vm.assignHandleClose}},[_vm._v("取 消")]),_vm._v(" "),_c('el-button',{attrs:{"type":"primary"},on:{"click":_vm.confirmAssign}},[_vm._v("启用布局")])],1)],1)],1)}
var setLayout_staticRenderFns = []
var setLayout_esExports = { render: setLayout_render, staticRenderFns: setLayout_staticRenderFns }
/* harmony default export */ var meeting_setLayout = (setLayout_esExports);
// CONCATENATED MODULE: ./src/components/meeting/setLayout.vue
function setLayout_injectStyle (ssrContext) {
  __webpack_require__("8ijg")
}
var setLayout_normalizeComponent = __webpack_require__("VU/8")
/* script */


/* template */

/* template functional */
var setLayout___vue_template_functional__ = false
/* styles */
var setLayout___vue_styles__ = setLayout_injectStyle
/* scopeId */
var setLayout___vue_scopeId__ = null
/* moduleIdentifier (server only) */
var setLayout___vue_module_identifier__ = null
var setLayout_Component = setLayout_normalizeComponent(
  setLayout,
  meeting_setLayout,
  setLayout___vue_template_functional__,
  setLayout___vue_styles__,
  setLayout___vue_scopeId__,
  setLayout___vue_module_identifier__
)

/* harmony default export */ var components_meeting_setLayout = (setLayout_Component.exports);

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./src/components/meeting/speakstaus.vue

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var speakstaus = ({
    props: ['user'],
    computed: extends_default()({}, Object(vuex_esm["b" /* mapGetters */])(['memberInObj']))
});
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-3349f24a","hasScoped":true,"transformToRequire":{"video":["src","poster"],"source":"src","img":"src","image":"xlink:href"},"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/meeting/speakstaus.vue
var speakstaus_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"userNameP "},[_vm._v("\n  "+_vm._s(_vm.user.userName)+"\n  "),_vm._v(" "),(_vm.memberInObj[_vm.user.memberId])?_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.IsHost(_vm.user.roleId)),expression:"IsHost(user.roleId)"}]},[_vm._v("("+_vm._s(_vm.$t('meeting.moderator'))+")")]):_vm._e(),_vm._v(" "),_c('i',{directives:[{name:"show",rawName:"v-show",value:(!_vm.user.isOpenAudio),expression:"!user.isOpenAudio"}],staticClass:"RSIcon RSIcon-guanbimaikefeng colred ",staticStyle:{"font-size":"18px"}}),_vm._v(" "),_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.user.isOpenAudio),expression:"user.isOpenAudio"}],staticClass:"spanIconBg"},[_c('svg',{staticClass:"icon",attrs:{"aria-hidden":"true"}},[_c('use',{attrs:{"xlink:href":"#RSIcon-kaiqimaikefeng1"}})])])])}
var speakstaus_staticRenderFns = []
var speakstaus_esExports = { render: speakstaus_render, staticRenderFns: speakstaus_staticRenderFns }
/* harmony default export */ var meeting_speakstaus = (speakstaus_esExports);
// CONCATENATED MODULE: ./src/components/meeting/speakstaus.vue
function speakstaus_injectStyle (ssrContext) {
  __webpack_require__("cgeL")
}
var speakstaus_normalizeComponent = __webpack_require__("VU/8")
/* script */


/* template */

/* template functional */
var speakstaus___vue_template_functional__ = false
/* styles */
var speakstaus___vue_styles__ = speakstaus_injectStyle
/* scopeId */
var speakstaus___vue_scopeId__ = "data-v-3349f24a"
/* moduleIdentifier (server only) */
var speakstaus___vue_module_identifier__ = null
var speakstaus_Component = speakstaus_normalizeComponent(
  speakstaus,
  meeting_speakstaus,
  speakstaus___vue_template_functional__,
  speakstaus___vue_styles__,
  speakstaus___vue_scopeId__,
  speakstaus___vue_module_identifier__
)

/* harmony default export */ var components_meeting_speakstaus = (speakstaus_Component.exports);

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./src/components/meeting/meetVideo.vue


//
//
//
//
//
//
//
//
//
//




/* harmony default export */ var meetVideo = ({
    props: ['userId'],
    data: function data() {
        return {
            defaultImg: defaultAvatar_default.a
        };
    },

    computed: extends_default()({}, Object(vuex_esm["b" /* mapGetters */])(['memberInObj', 'streamIdObj', 'streamObj']), {
        user: function user() {
            if (this.userId && this.$store.getters.getMemberInById(this.userId)) {
                var user = this.$store.getters.getMemberInById(this.userId);
                console.log('getMemberInById-----', stringify_default()(user));
                return user;
            } else {
                return {};
            }
        },
        stream: function stream() {
            if (this.userId && this.$store.getters.getStreamById(this.userId)) {
                var stream = this.$store.getters.getStreamById(this.userId);
                return stream;
            } else {
                return null;
            }
        }
    }),
    components: {
        speakstaus: components_meeting_speakstaus
    },
    watch: {
        userId: function userId(NewID, OldID) {
            console.log('userId----watch', NewID, OldID);
            this.$refs['selfvideo'].srcObject = null;
            this.bus.$off('videoShow' + OldID);
            this.init(NewID);
            // }
        },

        streamIdObj: {
            deep: true,
            handler: function handler(newVal, oldVal) {
                console.log('===streamIdObj===' + this.userId);
                if (this.userId && this.streamObj[this.userId] && newVal[this.userId] !== oldVal[this.userId]) {
                    this.videoShow(this.streamObj[this.userId]);
                }
            }
        }

    },
    mounted: function mounted() {
        console.log(this.userId, "mounted====注册bus");
        this.init(this.userId);
    },

    methods: {
        init: function init(userId) {
            var _this = this;

            setTimeout(function () {
                if (_this.stream) {
                    console.log('已存在视频流，直接渲染');
                    _this.videoShow(_this.stream);
                }
            }, 100);
        },
        videoShow: function videoShow(stream) {
            if (this.$refs['selfvideo'] && stream && stream.id) {
                this.$refs['selfvideo'].srcObject = stream;
                console.log('video----', this.$refs['selfvideo']);
                console.log(this.$refs['selfvideo'].srcObject, "渲染视频流,id:" + this.userId + ",userName:" + this.user.userName);
            }
        },
        noImgFind: function noImgFind(event) {
            console.log("未正确加载到图片;");
            var img = event.srcElement;
            img.src = this.defaultImg;
            img.οnerrοr = null; //控制不要一直跳动
        }
    }
});
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-51c39314","hasScoped":true,"transformToRequire":{"video":["src","poster"],"source":"src","img":"src","image":"xlink:href"},"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/meeting/meetVideo.vue
var meetVideo_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"UserVideoBg"},[_c('video',{directives:[{name:"show",rawName:"v-show",value:(_vm.user.isOpenVideo),expression:"user.isOpenVideo"}],ref:"selfvideo",attrs:{"autoplay":"","muted":""},domProps:{"muted":true}}),_vm._v(" "),_c('img',{directives:[{name:"show",rawName:"v-show",value:(!_vm.user.isOpenVideo),expression:"!user.isOpenVideo"}],attrs:{"src":_vm.memberInObj[_vm.userId]&&_vm.memberInObj[_vm.userId].photourl?_vm.memberInObj[_vm.userId].photourl:_vm.defaultImg,"ondragstart":"return false;","alt":""},on:{"error":_vm.noImgFind}}),_vm._v(" "),_c('speakstaus',{attrs:{"user":_vm.user,"MerberiList":_vm.$parent.MerberiList}})],1)}
var meetVideo_staticRenderFns = []
var meetVideo_esExports = { render: meetVideo_render, staticRenderFns: meetVideo_staticRenderFns }
/* harmony default export */ var meeting_meetVideo = (meetVideo_esExports);
// CONCATENATED MODULE: ./src/components/meeting/meetVideo.vue
function meetVideo_injectStyle (ssrContext) {
  __webpack_require__("a53c")
}
var meetVideo_normalizeComponent = __webpack_require__("VU/8")
/* script */


/* template */

/* template functional */
var meetVideo___vue_template_functional__ = false
/* styles */
var meetVideo___vue_styles__ = meetVideo_injectStyle
/* scopeId */
var meetVideo___vue_scopeId__ = "data-v-51c39314"
/* moduleIdentifier (server only) */
var meetVideo___vue_module_identifier__ = null
var meetVideo_Component = meetVideo_normalizeComponent(
  meetVideo,
  meeting_meetVideo,
  meetVideo___vue_template_functional__,
  meetVideo___vue_styles__,
  meetVideo___vue_scopeId__,
  meetVideo___vue_module_identifier__
)

/* harmony default export */ var components_meeting_meetVideo = (meetVideo_Component.exports);

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./src/components/meeting/selfmeetVideo.vue

//
//
//
//
//
//
//
//
//
//




/* harmony default export */ var selfmeetVideo = ({
    props: ['userId'],
    data: function data() {
        return {
            defaultImg: defaultAvatar_default.a
        };
    },

    computed: extends_default()({}, Object(vuex_esm["b" /* mapGetters */])(['memberInObj', 'streamObj', 'streamIdObj']), {
        user: function user() {
            if (this.userId && this.$store.getters.getMemberInById(this.userId)) {
                var user = this.$store.getters.getMemberInById(this.userId);
                return user;
            } else {
                return {};
            }
        }
    }),
    components: {
        speakstaus: components_meeting_speakstaus
    },
    watch: {
        streamIdObj: {
            deep: true,
            handler: function handler(newVal, oldVal) {
                console.log('===streamIdObj===' + this.userId);
                if (this.userId && this.streamObj[this.userId] && newVal[this.userId] !== oldVal[this.userId]) {
                    this.videoShow(this.streamObj[this.userId]);
                }
            }
        }
    },
    mounted: function mounted() {},

    methods: {
        videoShow: function videoShow(stream) {
            if (this.$refs['userRef'] && stream) {
                this.$refs['userRef'].srcObject = stream;
                console.log('self-渲染视频流=====', this.$refs['userRef']);
                console.log('self-stream=====', this.$refs['userRef'].srcObject);
            }
        },
        noImgFind: function noImgFind(event) {
            console.log("未正确加载到图片;");
            var img = event.srcElement;
            img.src = this.defaultImg;
            img.οnerrοr = null; //控制不要一直跳动
        },
        findUserInPub: function findUserInPub(userId) {}
    }
});
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-618a2fe6","hasScoped":true,"transformToRequire":{"video":["src","poster"],"source":"src","img":"src","image":"xlink:href"},"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/meeting/selfmeetVideo.vue
var selfmeetVideo_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"UserVideoBg"},[_c('video',{directives:[{name:"show",rawName:"v-show",value:(_vm.user.isOpenVideo),expression:"user.isOpenVideo"}],ref:"userRef",staticClass:"self-video",attrs:{"autoplay":"","muted":""},domProps:{"muted":true}}),_vm._v(" "),_c('img',{directives:[{name:"show",rawName:"v-show",value:(!_vm.user.isOpenVideo),expression:"!user.isOpenVideo"}],attrs:{"src":_vm.memberInObj[_vm.userId] && _vm.memberInObj[_vm.userId].photourl?_vm.memberInObj[_vm.userId].photourl:_vm.defaultImg,"ondragstart":"return false;","alt":""},on:{"error":_vm.noImgFind}}),_vm._v(" "),_c('speakstaus',{attrs:{"user":_vm.user}})],1)}
var selfmeetVideo_staticRenderFns = []
var selfmeetVideo_esExports = { render: selfmeetVideo_render, staticRenderFns: selfmeetVideo_staticRenderFns }
/* harmony default export */ var meeting_selfmeetVideo = (selfmeetVideo_esExports);
// CONCATENATED MODULE: ./src/components/meeting/selfmeetVideo.vue
function selfmeetVideo_injectStyle (ssrContext) {
  __webpack_require__("jM3i")
}
var selfmeetVideo_normalizeComponent = __webpack_require__("VU/8")
/* script */


/* template */

/* template functional */
var selfmeetVideo___vue_template_functional__ = false
/* styles */
var selfmeetVideo___vue_styles__ = selfmeetVideo_injectStyle
/* scopeId */
var selfmeetVideo___vue_scopeId__ = "data-v-618a2fe6"
/* moduleIdentifier (server only) */
var selfmeetVideo___vue_module_identifier__ = null
var selfmeetVideo_Component = selfmeetVideo_normalizeComponent(
  selfmeetVideo,
  meeting_selfmeetVideo,
  selfmeetVideo___vue_template_functional__,
  selfmeetVideo___vue_styles__,
  selfmeetVideo___vue_scopeId__,
  selfmeetVideo___vue_module_identifier__
)

/* harmony default export */ var components_meeting_selfmeetVideo = (selfmeetVideo_Component.exports);

// EXTERNAL MODULE: ./node_modules/recordrtc/RecordRTC.js
var RecordRTC = __webpack_require__("mbvs");
var RecordRTC_default = /*#__PURE__*/__webpack_require__.n(RecordRTC);

// EXTERNAL MODULE: ./node_modules/babel-runtime/helpers/toConsumableArray.js
var toConsumableArray = __webpack_require__("Gu7T");
var toConsumableArray_default = /*#__PURE__*/__webpack_require__.n(toConsumableArray);

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./src/components/whiteBoard/index.vue


//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var whiteBoard = ({
  props: ["roomId", "userId", "isWhiteBoarOrganiser", 'pTop', 'receiveId', 'wbInfo'],
  computed: extends_default()({}, Object(vuex_esm["d" /* mapState */])(["LoginServe"]), Object(vuex_esm["b" /* mapGetters */])(['meetInfo'])),
  watch: {
    meetInfo: function meetInfo(val) {
      console.log('===getters.meetInfo===', val);
      if (val.state & 0x0008) {
        this.isLock = true;
        this.controllerList.forEach(function (item) {
          if (item.className == 'lock') {
            item.isActive = 'active';
          }
        });
      } else {
        this.isLock = false;
        this.controllerList.forEach(function (item) {
          if (item.className == 'lock') {
            item.isActive = '';
          }
        });
      }
    }
  },
  data: function data() {
    return {
      confirmLeavep: false,
      isDelChecked: false,
      //控制条
      controllerList: [
      // { id: 1, name: "切换文档", className: "exchange", isActive: "", children: "DocBoxShow"},
      { id: 2, name: this.$t('last.brush'), className: "brush", children: "BruchBoxShow", isActive: "active" }, { id: 3, name: this.$t('last.laser'), className: "laser", isActive: "" }, { id: 4, name: this.$t('last.eraser'), className: "eraser", isActive: "" }, { id: 5, name: this.$t('last.layout'), className: "layout", children: "LayoutBoxShow", isActive: "" }, { id: 6, name: this.$t('last.reset'), className: "reset", isActive: "" }, { id: 7, name: this.$t('last.redo'), className: "redo", isActive: "" }, { id: 8, name: this.$t('last.delete'), className: "delete", isActive: "" }, { id: 9, name: this.$t('last.lock'), className: "lock", isActive: "" }, { id: 10, name: this.$t('last.save'), className: "save", isActive: "" }],
      //画笔控制条
      BruchBoxShow: {
        isShow: false,
        list: [{ name: this.$t('last.beeline'), className: "beeline", isActive: "" }, { name: this.$t('last.curve'), className: "curve", isActive: "active" }, { name: this.$t('last.quadrangle'), className: "quadrangle", isActive: "" }, { name: this.$t('last.trigon'), className: "trigon", isActive: "" }, { name: this.$t('last.circle'), className: "circle", isActive: "" }]
      },
      //颜色控制条
      ColorBoxShow: {
        isShow: false,
        list: [{ className: "color_red", isActive: "", rgb: [255, 51, 58] }, { className: "color_orange", isActive: "", rgb: [255, 95, 4] }, { className: "color_yellow", isActive: "", rgb: [255, 220, 0] }, { className: "color_green", isActive: "", rgb: [32, 201, 138] }, { className: "color_blue", isActive: "", rgb: [20, 107, 230] }, { className: "color_purple", isActive: "", rgb: [162, 64, 226] }, { className: "color_gray", isActive: "", rgb: [231, 240, 249] }, { className: "color_black", isActive: "", rgb: [70, 70, 70] }]
      },
      //格式控制条
      LayoutBoxShow: {
        isShow: false,
        fontSize: [{ className: "font-20", text: "20", isActive: "" }, { className: "font-24", text: "24", isActive: "" }, { className: "font-28", text: "28", isActive: "" }, { className: "font-32", text: "32", isActive: "" }, { className: "font-48", text: "48", isActive: "" }],
        fontWeight: [{ className: "font-20", isActive: "active", value: 3 }, { className: "font-24", isActive: "", value: 6 }, { className: "font-28", isActive: "", value: 8 }]
      },
      // 更多面板
      MoreBoxShow: {
        isShow: false,
        value: false
      },
      // 文本框
      isWhiteBoardInput: false,
      // 文本内容
      whiteBoardInput: "",
      // 文本字体大小
      whiteBoardTextFontSize: 25,
      isLock: false,
      DocBoxShow: {
        isShow: false
      },
      docList: [],
      current: 1,
      totalPage: 10,
      docId: 0,
      docArr: [],
      wbRoomId: '',
      fileObj: {},
      fileType: {
        img: ["png", "jpg", "jpeg"],
        pdf: ['pdf'],
        ppt: ["ppt", "pps", "pot", "ppa", 'pptx'],
        word: ["doc", "dot", "xml", 'docx'],
        xls: ["xls", "xlt", "xla", 'xlsx']
      },
      fileAccept: '.png,.jpg,.jpeg,.pdf,.ppt,.pps,.pptx,.pot,.ppa,.doc,.docx,.dot,.xls,.xlt,.xlsx',
      isReconnect: false
    };
  },

  methods: {
    exitBoard: function exitBoard() {
      if (this.pTop) {
        if (this.isDelChecked && this.isWhiteBoarOrganiser) {
          this.$bus.emit('stopWhiteBoardSharing');
        } else {
          this.$bus.emit('leaveWbRoom');
        }
      } else {
        if (this.isDelChecked && this.isWhiteBoarOrganiser) {
          this.$parent.closeWhiteBoardShare();
        } else {
          this.$parent.leaveWbRoom();
        }
      }
      this.confirmLeavep = false;
    },
    init: function init() {
      var _this = this;

      console.log("this.LoginServe");
      console.log(this.LoginServe);
      var self = this;
      this.fileObj = {};
      var wbss_user_id = this.userId;
      var canvas = document.getElementById("canvas");
      var ret = YTX_WBSS_API.init_WBSS_SDK(wbss_user_id, "123456", this.LoginServe.AppId,
      // "https://rstest.yomeeting.com",
      // "https://rs52.yomeeting.com",
      // "https://192.168.180.190",
      // `https://${this.LoginServe.WbssAddrs[0]}`,
      this.LoginServe.WbssAddrs[0],
      // 'https://192.168.27.227:9001/rest/auth',
      canvas);
      this.isReconnect = false;
      console.log(ret);
      var state = this.meetInfo.state;
      if (state & 0x0008) {
        this.isLock = true;
      } else {
        this.isLock = false;
      }
      setTimeout(function () {
        _this.current = _this.wbInfo.current;
        _this.docArr = _this.wbInfo.docArr;
        _this.docId = _this.wbInfo.docId;
        _this.totalPage = _this.wbInfo.totalPage;
        _this.wbRoomId = _this.wbInfo.wbRoomId;
        _this.shareDoc(_this.docId, function () {
          _this.gotoPage(2, _this.current);
        });
        console.log('===docArr==', _this.wbInfo);
      }, 700);

      // 设置白板区域，可以默认不设置
      YTX_WBSS_API.setWhiteBoardScale(0); // <=0 全屏分辨率比例

      // 注册监听器
      YTX_WBSS_API.onUploadDocProcessListener(function (resp) {
        console.log('===onUploadDocProcessListener===', resp);
      });
      YTX_WBSS_API.onDocConvertListener(function (resp) {
        console.log('===onDocConvertListener===', resp);
        resp.wbssRoomInfoMap.wbssDocInfoDataArray.forEach(function (item) {
          if (!_this.fileObj[item.wbssDocId]) _this.fileObj[item.wbssDocId] = {};
        });
        self.$set(self, 'docArr', resp.wbssRoomInfoMap.wbssDocInfoDataArray);
      });
      YTX_WBSS_API.onGotoPageListener(function (resp) {
        _this.current = resp.pageId;
      });
      YTX_WBSS_API.onShareDocListener(function (resp) {});
      YTX_WBSS_API.onFilePathListener(function (res) {
        console.log('===onFilePathListener===', res);
        var ext = res.fileName.split('.');
        ext = ext[ext.length - 1];
        res.ext = ext;
        for (var val in _this.fileType) {
          if (_this.fileType[val].includes(ext)) {
            res.fileType = val;
          }
        }
        _this.$set(_this.fileObj, res.docId, res);
        _this.$forceUpdate();
        console.log('===fileObj===', _this.fileObj);
      });
      YTX_WBSS_API.onConnectStateChangeListener(function (state) {
        if (state == 1) {
          //  网络掉线
          _this.$message.warning('网络掉线');
          _this.isReconnect = true;
        } else if (state == 2) {
          //  重连中
          _this.$message.warning('重连中');
          _this.isReconnect = true;
        } else if (state == 3) {
          //  重连成功
          _this.$message.success('重连成功');
          _this.isReconnect = false;
        } else if (state == 5) {
          //  重连失败，重新退出白板界面
          _this.$message.warning('重连失败，退出房间');
          console.log('重连失败，退出房间');
          _this.isDelChecked = false;
          _this.exitBoard();
        }
      });
      this.CanvasEventResize();
      // 默认曲线
      YTX_WBSS_API.setLineShape(YTX_WBSS_API._shapeType.FREELINE);
      this.controllerList.forEach(function (item) {
        if (item.className == 'brush') {
          item.isActive = 'active';
        } else if (item.className == 'lock' && _this.isLock) {
          item.isActive = 'active';
        } else {
          item.isActive = '';
        }
      });
      this.BruchBoxShow.list.forEach(function (item) {
        if (item.className == 'curve') {
          item.isActive = 'active';
        } else {
          item.isActive = '';
        }
      });

      //默认红色
      this.handleClickColor(this.ColorBoxShow.list[0], 0);
      YTX_WBSS_API.setLineWidth(3);
    },


    //渲染Canvas
    CanvasEventResize: function CanvasEventResize() {
      this.$nextTick(function () {
        YTX_WBSS_API.notifyCanvasEventResize(function () {});
      });
      // setTimeout(()=>{
      //   YTX_WBSS_API.notifyCanvasEventResize(function() {});
      // },1000)
    },


    //关闭所有closeBox
    closeAllBox: function closeAllBox() {
      var _this2 = this;

      ["BruchBoxShow", "ColorBoxShow", "LayoutBoxShow", "MoreBoxShow", 'DocBoxShow'].forEach(function (it) {
        _this2[it].isShow = false;
      });
    },


    //控制条点击
    handleClickController: function handleClickController(item, index) {
      var _this3 = this;

      this.closeAllBox();
      this.isWhiteBoardInput = false;
      if (item.children) {
        this[item.children].isShow = true;
      } else {
        switch (item.className) {
          case "laser":
            YTX_WBSS_API.setLineShape(YTX_WBSS_API._shapeType.LASERPEN);
            break;
          case "reset":
            YTX_WBSS_API.drawUndo(function (resp) {
              console.log("fun_drawUndo onSuccess");
            }, function () {
              console.error("fun_drawUndo onError");
            });
            break;
          case "save":
            this.save();
            break;
          case "context":
            this.isWhiteBoardInput = !this.isWhiteBoardInput;
            this.$nextTick(function () {
              _this3.$refs.WhiteBoardInputRef.$el.style.top = "200px";
              _this3.$refs.WhiteBoardInputRef.$el.style.left = "200px";
            });
            break;
          case "eraser":
            this.eraser();
            break;
          case "close":
            this.$bus.emit('stopWhiteBoardSharing');
            break;
          case "exitWbss":
            this.$bus.emit('leaveWbRoom');
            break;
          case "mini":
            this.$bus.emit('changeWbSize', true);
            break;
          case "docShare":

            break;
          case "redo":
            YTX_WBSS_API.drawRedo(function (resp) {
              console.log("fun_drawRedo onSuccess");
            }, function () {
              console.error("fun_drawRedo onError");
            });
            break;
          case "delete":
            this.clearCurrentPage();
            break;
          case "lock":
            this.lockLabel();
            break;
          default:
            break;
        }
        this.showControllActive(item.className);
      }
    },
    showControllActive: function showControllActive(className) {
      var _this4 = this;

      var arr = ['brush', 'laser', 'eraser'];
      if (arr.includes(className)) {
        this.controllerList.forEach(function (item) {
          if (arr.includes(item.className)) {
            item.isActive = '';
          }
          if (item.className === className) {
            item.isActive = 'active';
          }
        });
        //当选中工具为画笔或者橡皮擦时，清空画笔的线条选中
        if (className === 'eraser' || className === 'laser') {
          this.BruchBoxShow.list.forEach(function (it) {
            it.isActive = '';
          });
        }
      } else if (className === 'lock') {
        this.controllerList.forEach(function (item) {
          if (item.className === 'lock') {
            if (_this4.isLock) {
              item.isActive = 'active';
            } else {
              item.isActive = '';
            }
          }
        });
      }
    },
    shareDoc: function shareDoc(docId, callback) {
      var _this5 = this;

      var builderShareDoc = new YTX_WBSS_API.ShareDocBuilder(this.wbRoomId, docId);
      console.log(builderShareDoc);
      this.DocBoxShow.isShow = false;
      YTX_WBSS_API.shareDoc(builderShareDoc, function (resp) {
        console.log("fun_shareDoc onSuccess resp=", resp);
        _this5.current = resp.pageId;
        _this5.docId = docId;
        for (var i = 0; i < _this5.docArr.length; i++) {
          var doc = _this5.docArr[i];
          console.log('===doc.wbssDocId===', doc.wbssDocId);
          if (doc.wbssDocId == docId) {
            _this5.totalPage = doc.wbssDocTotalPage;
            break;
          }
        }
        callback && callback();
      }, function (resp) {
        console.log("fun_shareDoc onError resp=", resp);
      });
    },
    addDoc: function addDoc() {
      if (this.docArr.length > 8) {
        this.$message.warning(this.$t('last.overFileMax'));
        return;
      }
      this.$refs.fileInput.click();
    },


    //选择画笔
    handleClickBruch: function handleClickBruch(item, index) {
      this.showControllActive('brush');
      this.BruchBoxShow.list.forEach(function (it, i) {
        it.isActive = "";
        if (index === i) {
          it.isActive = "active";
          switch (it.className) {
            case "beeline":
              YTX_WBSS_API.setLineShape(YTX_WBSS_API._shapeType.LINE);
              break;
            case "curve":
              YTX_WBSS_API.setLineShape(YTX_WBSS_API._shapeType.FREELINE);
              break;
            case "quadrangle":
              YTX_WBSS_API.setLineShape(YTX_WBSS_API._shapeType.RECT);
              break;
            case "trigon":
              YTX_WBSS_API.setLineShape(YTX_WBSS_API._shapeType.TRIANGLE);
              break;
            case "circle":
              YTX_WBSS_API.setLineShape(YTX_WBSS_API._shapeType.ELLIPSE);
              break;
            default:
              break;
          }
        }
      });
    },


    //选择字号
    handleClickFontSize: function handleClickFontSize(item, index) {
      var _this6 = this;

      this.LayoutBoxShow.fontSize.forEach(function (it, i) {
        it.isActive = "";
        if (index === i) {
          it.isActive = "active";
          _this6.whiteBoardTextFontSize = Number(it.text);
        }
      });
    },


    //选择粗细
    handleClickFontWeight: function handleClickFontWeight(item, index) {
      this.LayoutBoxShow.fontWeight.forEach(function (it, i) {
        it.isActive = "";
        if (index === i) {
          it.isActive = "active";
          YTX_WBSS_API.setLineWidth(it.value);
        }
      });
    },


    //选择颜色
    handleClickColor: function handleClickColor(item, index) {
      this.ColorBoxShow.list.forEach(function (it, i) {
        it.isActive = "";
        if (index === i) {
          // 修改主控制条颜色
          it.isActive = 'active';
          console.log('===it===', it);
          // 设置颜色
          // 224,32,32,1
          var builder = new (Function.prototype.bind.apply(YTX_WBSS_API.ColorBuilder, [null].concat(toConsumableArray_default()(it.rgb), [255])))();
          YTX_WBSS_API.setLineColor(builder);
        }
      });
    },


    // 清除
    clearCurrentPage: function clearCurrentPage() {
      this.$confirm(this.$t('last.clearTip'), this.$t('modelMessage.prompt'), {
        confirmButtonText: this.$t('btn.determine'),
        cancelButtonText: this.$t('btn.cancel'),
        showClose: false,
        showCancelButton: true,
        center: true,
        customClass: "confirm"
        // type: 'info'
      }).then(function () {
        YTX_WBSS_API.clearCurrentPage();
      }).catch(function () {});
    },


    //添加画板页码
    addPagation: function addPagation() {
      if (this.totalPage < 5) {
        this.totalPage = this.totalPage + 1;
      }
    },


    //画板上一页
    togglePrevPagation: function togglePrevPagation() {
      if (this.current > 1) {
        this.$parent.current = this.$parent.current - 1;
        // this.current = this.current - 1;
        this.gotoPage(1);
      }
    },


    //画板下一页
    toggleNextPagation: function toggleNextPagation() {
      if (this.current < this.totalPage) {
        this.$parent.current = this.$parent.current + 1;
        // this.current = this.current + 1;
        this.gotoPage(3);
      }
    },


    // 切换页码
    gotoPage: function gotoPage(type, pageId) {
      // type : 1:上一页 2：指定到哪页 3：下一页
      if (type === 1) {
        YTX_WBSS_API.gotoPrevPage(function (resp) {
          console.log(resp);
        }, function () {});
      } else if (type === 2) {
        var builder = new YTX_WBSS_API.GotoPageBuilder();
        builder.setPageIndex(pageId);
        console.log("pageId=" + pageId);
        YTX_WBSS_API.gotoPage(builder, function (resp) {
          console.log(resp);
        });
      } else if (type === 3) {
        YTX_WBSS_API.gotoNextPage(function (resp) {
          console.log(resp);
        }, function () {});
      }
    },


    //删除画板
    delPagation: function delPagation() {
      if (this.totalPage > 1) {
        this.totalPage = this.totalPage - 1;
        // 删除当前页画板 需要修正当前页码
        if (this.current > this.totalPage) {
          this.current = this.totalPage;
        }
      }
    },


    // 标注锁
    lockLabel: function lockLabel(value) {
      var _this7 = this;

      /**
       * 0：锁定 1：解锁  2：锁定“发起白板操作” 3：解锁 4：锁定“白板标注” 5：解锁
       *
       * **/
      var self = this;
      this.isLock = !this.isLock;
      var acon = this.isLock ? 4 : 5;
      var LockMeetBuilder = new RL_MEET.LockMeetBuilder();
      LockMeetBuilder.setAction(acon);
      LockMeetBuilder.setConfId(self.roomId);
      RL_MEET.LockMeet(LockMeetBuilder, function (res) {
        self.$message.info(_this7.$t('last.noteLock') + (_this7.isLock ? _this7.$t('last.open') : _this7.$t('btn.close')));
      }, function (error) {
        console.info(error);
      });
    },


    // 鼠标事件状态
    isMouseEventEnable: function isMouseEventEnable(bool) {
      YTX_WBSS_API.setMouseEventEnable(bool);
      this.isLock = !bool;
    },


    // 画板保存
    save: function save() {
      var _this8 = this;

      this.$confirm(this.$t('last.noteSave'), this.$t('modelMessage.prompt'), {
        confirmButtonText: this.$t('btn.determine'),
        cancelButtonText: this.$t('btn.cancel'),
        showClose: false,
        showCancelButton: true,
        customClass: "confirm",
        center: true
        // type: 'info'
      }).then(function () {
        var png_blob_file_url = YTX_WBSS_API.getCurrentPagePNG(function (resp) {
          if (resp.img_blob_url != null) {
            console.log("fun_save_pngfile onSuccess");
          }
        }, function (resp) {
          console.error("fun_save_pngfile onError resp=" + resp);
        });

        if (png_blob_file_url != null) {
          // 文件保存到本地
          var download_png_file_element = document.createElement("a");
          download_png_file_element.download = _this8.$t('last.wb') + _this8.current + ".png";
          download_png_file_element.href = png_blob_file_url;
          download_png_file_element.src = png_blob_file_url;
          download_png_file_element.style.display = "none";
          document.body.appendChild(download_png_file_element);
          download_png_file_element.click();
          _this8.$message.info(_this8.$t('settings.saveSucc'));
        }
      }).catch(function () {});
    },


    // 文本blur
    handlewhiteBoardInputBlur: function handlewhiteBoardInputBlur(e) {
      var _this9 = this;

      var y = parseInt(e.target.parentElement.style.top);
      var x = parseInt(e.target.parentElement.style.left);
      if (this.whiteBoardInput) {
        this.addText(x, y, this.whiteBoardInput, this.whiteBoardTextFontSize, function (res) {
          _this9.whiteBoardInput = "";
        });
      }
      this.isWhiteBoardInput = false;
    },


    //绘制文本
    addText: function addText(x, y, text, fontSize, callback) {
      // 获取可视化区域,相对于Canvas布局
      var view_rect_info = YTX_WBSS_API.getCurrentPageViewRectFromCanvas();
      if (view_rect_info != null) {
        if (view_rect_info.width > 0 && view_rect_info.height > 0) {
          // 设置文本状态,不然点击屏幕会出现绘图
          try {
            YTX_WBSS_API.setLineShape(YTX_WBSS_API._shapeType.FONT);
            // 添加文本
            YTX_WBSS_API.addText({ x: x, y: y }, text, fontSize, "wbss_fangzheng_font.ttf", function (resp) {
              console.log("fun_addText_test onSuccess");
              callback && callback(resp);
            }
            // function(resp) {
            //   console.error("fun_addText_test onError");
            // }
            );
          } catch (error) {}
        }
      }
    },


    // 橡皮擦
    eraser: function eraser() {
      // let shapeType = YTX_WBSS_API.getLineShape();
      // if (
      //   shapeType != YTX_WBSS_API._shapeType.ERASER_DRAW_LINE &&
      //   shapeType != YTX_WBSS_API._shapeType.ERASER_DRAW_ID
      // ) {
      YTX_WBSS_API.setLineShape(YTX_WBSS_API._shapeType.ERASER_DRAW_LINE);
      // } else {
      //   if (shapeType == YTX_WBSS_API._shapeType.ERASER_DRAW_LINE) {
      //     YTX_WBSS_API.setLineShape(YTX_WBSS_API._shapeType.ERASER_DRAW_ID);
      //   } else {
      //     YTX_WBSS_API.setLineShape(YTX_WBSS_API._shapeType.ERASER_DRAW_LINE);
      //   }
      // }
    },
    changeSize: function changeSize(mini) {
      if (mini) {
        this.$refs.wbBox.style = 'width:1px;height:1px;overflow:hidden;';
      } else {
        this.$refs.wbBox.style = '';
      }
    },
    uploadDoc: function uploadDoc(e) {
      var file = e.target.files[0];
      console.log('===file===', file);
      YTX_WBSS_API.uploadDoc(file, function (resp) {
        console.log("uploadDoc onSuccess resp=" + resp);
      }, function (resp) {
        console.log("uploadDoc onError resp=" + resp);
      }, function (resp) {
        console.log("uploadDoc onProcess resp=" + resp);
      });
    }
  }
});
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-81a6cec4","hasScoped":true,"transformToRequire":{"video":["src","poster"],"source":"src","img":"src","image":"xlink:href"},"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/whiteBoard/index.vue
var whiteBoard_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{ref:"wbBox",staticClass:"white-board-box"},[_c('div',{staticClass:"whiteboard-header"},[_c('span',{staticClass:"txt"},[_vm._v("\n      "+_vm._s(_vm.isLock && !_vm.isWhiteBoarOrganiser ? _vm.$t('last.looking') : _vm.$t('last.noting'))+"\n    ")]),_vm._v(" "),_c('i',{staticClass:"wb-close el-icon-close",on:{"click":function($event){_vm.isWhiteBoarOrganiser ? _vm.confirmLeavep = true :  _vm.exitBoard()}}})]),_vm._v(" "),_c('canvas',{ref:"canvas",staticStyle:{"background-color":"#ffffff","width":"100vw","height":"calc(100vh - 40px)"},attrs:{"id":"canvas","width":"1280","height":"720"},on:{"click":function($event){$event.stopPropagation();return _vm.closeAllBox($event)}}}),_vm._v(" "),_c('div',{directives:[{name:"drag",rawName:"v-drag"}],ref:"controller",class:{controller:true,disabled:(_vm.isLock && !_vm.isWhiteBoarOrganiser) || _vm.isReconnect}},[_c('ul',_vm._l((_vm.controllerList),function(item){return ((item.className!=='lock' && item.className!=='delete') ||
        ((item.className === 'lock' || item.className ==='delete') && _vm.isWhiteBoarOrganiser && !_vm.pTop && !_vm.receiveId))?_c('li',{key:item.id,class:item.isActive,on:{"click":function($event){return _vm.handleClickController(item)}}},[_c('i',{class:[item.className]})]):_vm._e()}),0),_vm._v(" "),(_vm.BruchBoxShow.isShow)?_c('div',{staticClass:"bruch-box"},[_c('ul',_vm._l((_vm.BruchBoxShow.list),function(it,index){return _c('li',{key:it.name,class:it.isActive,on:{"click":function($event){return _vm.handleClickBruch(it,index)}}},[_c('i',{class:[it.className]}),_vm._v(" "),_c('span',[_vm._v(_vm._s(it.name))])])}),0)]):_vm._e(),_vm._v(" "),(_vm.ColorBoxShow.isShow)?_c('div',{staticClass:"color-box"},[_c('ul',_vm._l((_vm.ColorBoxShow.list),function(item,index){return _c('li',{key:item.className,on:{"click":function($event){return _vm.handleClickColor(item,index)}}},[_c('i',{class:[item.className,item.isActive]})])}),0)]):_vm._e(),_vm._v(" "),(_vm.LayoutBoxShow.isShow)?_c('div',{staticClass:"layout-box"},[_c('div',{staticClass:"colorBox"},_vm._l((_vm.ColorBoxShow.list),function(item,index){return _c('div',{key:item+index,class:[item.className,item.isActive],on:{"click":function($event){return _vm.handleClickColor(item,index)}}},[_c('i',{class:item.className})])}),0),_vm._v(" "),_c('div',{staticClass:"second"},[_c('h6',[_vm._v(_vm._s(_vm.$t('last.penSize')))]),_vm._v(" "),_c('p',_vm._l((_vm.LayoutBoxShow.fontWeight),function(item,index){return _c('i',{key:item+index,class:[item.className,item.isActive],on:{"click":function($event){return _vm.handleClickFontWeight(item,index)}}})}),0)])]):_vm._e(),_vm._v(" "),(_vm.DocBoxShow.isShow)?_c('ul',{staticClass:"more-box"},[_vm._l((_vm.docArr),function(item){return _c('li',{class:_vm.docId === item.wbssDocId ? 'active' : '',on:{"click":function($event){return _vm.shareDoc(item.wbssDocId)}}},[(item.wbssDocId == 0)?_c('div'):(_vm.fileObj[item.wbssDocId].fileType === 'img')?_c('img',{attrs:{"src":_vm.fileObj[item.wbssDocId].path,"alt":""}}):_c('img',{attrs:{"src":_vm.fileObj[item.wbssDocId] && _vm.fileObj[item.wbssDocId].fileType ? __webpack_require__("Hmds")("./FileTypeS_"+ _vm.fileObj[item.wbssDocId].fileType+'.png') : '',"alt":""}}),_vm._v(" "),_c('span',[_vm._v(_vm._s(item.wbssDocId == 0 ? _vm.$t('last.wb') : _vm.$t('last.doc') + item.wbssDocId))])])}),_vm._v(" "),_c('li',{directives:[{name:"preventReClick",rawName:"v-preventReClick",value:(2000),expression:"2000"}],staticClass:"add-doc",staticStyle:{"pointer-events":"auto"},on:{"click":_vm.addDoc}},[_c('div'),_vm._v(" "),_c('span',[_vm._v(_vm._s(_vm.$t('last.newWbFile')))]),_vm._v(" "),_c('input',{directives:[{name:"show",rawName:"v-show",value:(false),expression:"false"}],ref:"fileInput",attrs:{"type":"file","accept":_vm.fileAccept},on:{"change":_vm.uploadDoc}})])],2):_vm._e()]),_vm._v(" "),_c('div',{staticClass:"fonter"},[(_vm.isWhiteBoarOrganiser)?_c('i',{directives:[{name:"show",rawName:"v-show",value:(!_vm.isLock || (_vm.isLock && _vm.isWhiteBoarOrganiser)),expression:"!isLock || (isLock && isWhiteBoarOrganiser)"}],staticClass:"left",on:{"click":_vm.togglePrevPagation}}):_vm._e(),_vm._v(" "),_c('div',{staticClass:"text"},[_c('span',[_vm._v(_vm._s(_vm.current))]),_vm._v("\n      /\n      "),_c('span',[_vm._v(_vm._s(_vm.totalPage))])]),_vm._v(" "),(_vm.isWhiteBoarOrganiser)?_c('i',{directives:[{name:"show",rawName:"v-show",value:(!_vm.isLock || (_vm.isLock && _vm.isWhiteBoarOrganiser)),expression:"!isLock || (isLock && isWhiteBoarOrganiser)"}],staticClass:"right",on:{"click":_vm.toggleNextPagation}}):_vm._e()]),_vm._v(" "),_c('el-input',{directives:[{name:"show",rawName:"v-show",value:(_vm.isWhiteBoardInput),expression:"isWhiteBoardInput"},{name:"drag",rawName:"v-drag"}],ref:"WhiteBoardInputRef",staticClass:"whiteBoardInput",attrs:{"placeholder":_vm.$t('last.chatTip'),"autofocus":""},on:{"blur":_vm.handlewhiteBoardInputBlur},nativeOn:{"keyup":function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }return _vm.handlewhiteBoardInputBlur($event)}},model:{value:(_vm.whiteBoardInput),callback:function ($$v) {_vm.whiteBoardInput=$$v},expression:"whiteBoardInput"}}),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:((_vm.isLock && !_vm.isWhiteBoarOrganiser) || _vm.isReconnect),expression:"(isLock && !isWhiteBoarOrganiser) || isReconnect"}],staticClass:"white-board-zoom"}),_vm._v(" "),_c('el-dialog',{attrs:{"title":_vm.$t('modelMessage.prompt'),"visible":_vm.confirmLeavep,"width":"450px","modal":false,"close-on-click-modal":false,"custom-class":"confirmLeavepDialog","center":""},on:{"update:visible":function($event){_vm.confirmLeavep=$event}}},[_c('div',{staticStyle:{"width":"210px","margin":"0 auto","line-height":"25px"}},[_c('p',{staticStyle:{"font-size":"18px","margin-bottom":"20px"}},[_vm._v(_vm._s(_vm.$t('last.closeWbTip')))]),_vm._v(" "),(_vm.isWhiteBoarOrganiser)?_c('el-checkbox',{model:{value:(_vm.isDelChecked),callback:function ($$v) {_vm.isDelChecked=$$v},expression:"isDelChecked"}},[_vm._v(_vm._s(_vm.$t('last.deleteWb')))]):_vm._e()],1),_vm._v(" "),_c('span',{staticClass:"dialog-footer clearfix",attrs:{"slot":"footer"},slot:"footer"},[_c('el-button',{attrs:{"type":"default"},on:{"click":function($event){_vm.confirmLeavep=false}}},[_vm._v(_vm._s(_vm.$t('btn.cancel')))]),_vm._v(" "),_c('el-button',{staticStyle:{"margin-left":"50px"},attrs:{"type":"success"},on:{"click":_vm.exitBoard}},[_vm._v(_vm._s(_vm.$t('btn.determine')))])],1)])],1)}
var whiteBoard_staticRenderFns = []
var whiteBoard_esExports = { render: whiteBoard_render, staticRenderFns: whiteBoard_staticRenderFns }
/* harmony default export */ var components_whiteBoard = (whiteBoard_esExports);
// CONCATENATED MODULE: ./src/components/whiteBoard/index.vue
function whiteBoard_injectStyle (ssrContext) {
  __webpack_require__("DoPr")
  __webpack_require__("FeHq")
}
var whiteBoard_normalizeComponent = __webpack_require__("VU/8")
/* script */


/* template */

/* template functional */
var whiteBoard___vue_template_functional__ = false
/* styles */
var whiteBoard___vue_styles__ = whiteBoard_injectStyle
/* scopeId */
var whiteBoard___vue_scopeId__ = "data-v-81a6cec4"
/* moduleIdentifier (server only) */
var whiteBoard___vue_module_identifier__ = null
var whiteBoard_Component = whiteBoard_normalizeComponent(
  whiteBoard,
  components_whiteBoard,
  whiteBoard___vue_template_functional__,
  whiteBoard___vue_styles__,
  whiteBoard___vue_scopeId__,
  whiteBoard___vue_module_identifier__
)

/* harmony default export */ var src_components_whiteBoard = (whiteBoard_Component.exports);

// CONCATENATED MODULE: ./src/plugins/NoteType.js
var NoteTypes = {
  KNoteNone: -1,
  KNoteCreateConf: 0, // 创建会议的通知， 仅发送到 app 订阅通知, 可用于验证会议创建者，和创建会议参会合法性
  KNoteDeleteConf: 1,
  KNoteMemberJoin: 2,
  KNoteMemberQuit: 3,
  KNoteKickMember: 4,
  KNoteUpdateMemberInfo: 5,
  KNoteInviteMember: 6, //会议邀请的通知
  KNoteInviteResult: 7,
  KNotePreStartingConf: 8, // 目前未启用 会议即将开始，仅发送到 app 订阅通知，可用于开始会议前验证会议创建者的合法性。
  KNoteCancelInvite: 12, // 成员加入会议后，取消此成员其他终端的 呼叫邀请 页面
  KNoteStartingConfSummaryTask: 13, // 开始会议纪要转换任务的通知
  KNoteCompletedConfSummaryTask: 14, // 完成会议纪要转换任务的通知
  KNotePostStartingConf: 15, // 目前未启用 会议已经开始，仅发送到 app 订阅通知，可用于开始会议后执行一些业务处理。
  KNoteUpdateConf: 17,
  KNoteSendCommand: 19,
  KNoteSsSource: 21,
  KNoteMediaControl: 22,
  KNoteReserveNote: 24, // 会议预约的通知
  KNoteReserveRemindBeforeStart: 25, // 会议开始前的提醒通知
  KNoteReserveRemindBeforeEnd: 26, // 会议结束前的通知
  KNoteConfAppServerNote: 31, // 会议App的通知
  KNoteInterpretation: 40, // 会议同传通知
  KNoteUpdateImpelMember: 41, // 会议声音激励成员变化通知
  KNoteConfEndTime: 43 // 会议结束前3分钟通知

};
var NoteTypesAction = {
  kControlNone: -1, // 当服务器返回结果中，值不为空时，更新相应状态
  kControlForbidListen: 0, // 禁听
  kControlAllowSListen: 1, // 可听
  kControlForbidSpeak: 2, // 禁讲（言）
  kControlAllowSpeak: 3, // 可讲（言）
  kControlForbidWatchCamera: 10,
  kControlAllowSWatchCamera: 11,
  kControlForbidShareCamera: 12, // 取消发布视频
  kControlAllowShareCamera: 13, // 发布视频
  kControlForbidWatchScreen: 20,
  kControlAllowSWatchScreen: 21,
  kControlForbidShareScreen: 22, // 取消发布桌面共享
  kControlAllowShareScreen: 23, // 发布桌面共享
  kControlForbidWatchWhiteboard: 30,
  kControlAllowSWatchWhiteboard: 31,
  kControlForbidShareWhiteboard: 32,
  kControlAllowShareWhiteboard: 33,
  kControlForbidOperateWhiteboard: 34,
  kControlAllowOperateWhiteboard: 35,
  kControlStartSpeaking: 40,
  kControlStopSpeaking: 41,
  KControlConfMaxMember: 49, //最大人数变更
  kControlSetRole: 50, // 成员角色改变时，发出此通知，如调用 设置会议成员角色
  kControlUserInfo: 51, // 成员的 state/username/appdata 等数据改变时，发出此通知，如调用 更新会议成员信息 或 成员媒体断开
  KControlConfInfo: 52, // 会议信息更新
  KControlConfLockUnlock: 53, // 会议锁定状态更新
  KControlConfTopic: 54, // 会议议题更新
  KControlConfStartTime: 55, // 会议开始时间更新
  KControlUserRejectInvitation: 56, // 拒绝会议邀请
  KControlUserAcceptInvitation: 57, // 接受会议邀请
  KControlConfEndTime: 58, // 会议结束时间更新， 时长 或 会议室 改变
  KControlDelConfByUser: 60, // 用户主动解散会议
  KControlDelConfByIdleConf: 61, // 会议空闲， 解散
  KControlDelConfByExceedLimit: 62, // 会议超出最大时长限制， 解散
  KControlDelConfByConflictInConfRoomError: 63, // 会议室繁忙， 内部异常 导致 无法延时
  KControlDelConfByConflictInConfRoomPrivate: 64, // 会议室繁忙， 有会议占用会议室， 必须解散冲突的预约会议 （私人会议室）
  KControlDelConfByConflictInConfRoomOrgPub: 65, // 会议室繁忙， 有预约会议占用会议室，无法延长当前会议时长 （企业会议室）
  // 客户端收到 KControlMultiMediaRemove 通知时，仅移除界面成员，但不用提示用户
  // 客户端收到 KControlMmeberQuit 通知要显示“提示文字”
  KControlMultiMediaRemove: 66, // 启用多终端参会后， 成员真正入会后，会移除不带 @DeviceType 的成员信息。
  KControlMemberQuit: 67, // 成员主动退出会议。
  KControlDelConfByConflictInConfRoomDevice: 68, // 会议室繁忙， 预约会议到达预约时间 （企业硬件会议室）
  KControlConfLiveStart: 69, // 开始会议直播
  KControlConfLiveStop: 70, // 停止会议直播
  KControlConfLiveSwitch: 71, // 会议成员直播切换
  KControlConfLiveGetPlayUrl: 72, // 获取会议直播播放地址
  KControlDelConfByConfRoomDelete: 73, // 会议室被删除
  KControlDelConfByConfRoomDisable: 74, // 会议室被禁用
  KControlConfFileChanged: 75, // 会议文件库变化
  KControlConfAbstractChanged: 76, // 会议摘要变化
  KControlApplyPublishVoiceByModerator: 77, // 主持人点名
  KControlAcceptPublishVoiceByModerator: 78, // 主持人 同意 申请发言
  KControlRejectPublishVoiceByModerator: 79, // 主持人 拒绝 申请发言
  KControlStopPublishVoiceByModerator: 80, // 主持人 取消发言人权限，即更改发言人角色为 普通成员
  KControlApplyPublishVoiceBySelf: 81, // 参会人 申请发言
  KControlAcceptPublishVoiceBySelf: 82, // 参会人 同意点名
  KControlRejectPublishVoiceBySelf: 83, // 参会人 拒绝点名
  KControlStopPublishVoiceBySelf: 84, // 参会人 取消发言
  KControlRequestKeyFrame: 85, // 请求关键帧
  KControlDelConfBySyncFromPolycomDMA: 86, // PolycomDMA 同步到被删除的会议
  KControlSetMixScreenMembers: 87, // 设置混合显示成员列表
  KControlConfSwitchOnScreenLive: 88, // 开始会议屏幕直播
  KControlConfSwitchOffScreenLive: 89, // 停止会议屏幕直播
  KControlConfSetVideoLayout: 91, // 设置视频画面显示 固定布局 ， 目前主要用于 Polycom MCU
  KControlConfSetMainHall: 92, // 设置主会场
  KControlInviteByStartConf: 100, // “到达会议预约时间，先邀请主持人” 产生的 NotifyInviteMember
  KControlInviteByStartingConf: 101, // “自动开始会议” 产生的 NotifyInviteMember
  KControlInviteByConfMember: 102, // “会中成员手动邀请” 产生的 NotifyInviteMember
  KControlConfRecordStart: 111, // 开始会议录制
  KControlConfRecordStop: 112, // 停止会议录制
  KControlConfRecordSwitch: 113, // 会议成员录制切换
  KControlConfRecordGetFileList: 114, // 获取会议录制信息
  KControlConfRecordSwitchOnScreen: 115, // 切换到录制会议屏幕共享
  KControlConfRecordSwitchOffScreen: 116, // 停止录制会议屏幕共享
  KControlConfRecordGetSessions: 117, // 获取录制会话
  KControlConfRecordDeleteFile: 118, // 删除录制文件
  KControlConfLiveGetSessions: 120, // 获取直播会话
  KControlMemberDisconnect: 121, // 断开媒体
  KControlConfRecordPause: 122, // 暂停会议录制
  KControlConfRecordResume: 123, // 恢复会议录制
  // for 3rd party SDK event mapping
  KControlJoinThreeTeeRoom: 124, // 加入三体会议室
  KControlLeaveThreeTeeRoom: 125, // 离开三体会议室
  KControlUserUnDoInvitation: 153 //会议邀请超时未处理
};

// EXTERNAL MODULE: ./node_modules/Debugout/debugout.js
var debugout = __webpack_require__("afkt");
var debugout_default = /*#__PURE__*/__webpack_require__.n(debugout);

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./src/components/meeting/setRoundTour.vue

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ var setRoundTour = ({
  props: ['isShow', 'SelfMeetUserId'],
  data: function data() {
    return {
      roundTour: {
        state: false,
        skipNoImgeUser: false,
        roundTourInterval: 20
      },
      roundTourList: [20, 30, 60, 120, 300]
    };
  },

  methods: extends_default()({}, Object(vuex_esm["c" /* mapMutations */])(['SET_MeetSetting']), {
    handleClose: function handleClose() {
      this.$parent.closeDialog('setRoundTourDialog');
    },
    setRoundTourEvent: function setRoundTourEvent() {
      this.SET_MeetSetting(this.roundTour);
      this.handleClose();
    }
  })
});
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-04c9d85e","hasScoped":true,"transformToRequire":{"video":["src","poster"],"source":"src","img":"src","image":"xlink:href"},"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/meeting/setRoundTour.vue
var setRoundTour_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('el-dialog',{directives:[{name:"dialogDrag",rawName:"v-dialogDrag"}],attrs:{"title":_vm.$t('meeting.setRoundTour'),"visible":_vm.isShow,"center":"","width":"500px","modal":false,"close-on-click-modal":false,"modal-append-to-body":false,"custom-class":"setRoundTourDialog","before-close":_vm.handleClose},on:{"update:visible":function($event){_vm.isShow=$event}}},[_c('div',{staticClass:"roundTourCon"},[_c('ul',[_c('li',[_c('span',{staticClass:"text"},[_vm._v(_vm._s(_vm.$t('last.startRound')))]),_vm._v(" "),_c('el-switch',{attrs:{"inactive-color":"#dadada"},model:{value:(_vm.roundTour.state),callback:function ($$v) {_vm.$set(_vm.roundTour, "state", $$v)},expression:"roundTour.state"}})],1),_vm._v(" "),_c('li',[_c('span',{staticClass:"text"},[_vm._v(_vm._s(_vm.$t('last.roundInterval'))+"(s)")]),_vm._v(" "),_c('el-select',{attrs:{"placeholder":"请选择"},model:{value:(_vm.roundTour.roundTourInterval),callback:function ($$v) {_vm.$set(_vm.roundTour, "roundTourInterval", $$v)},expression:"roundTour.roundTourInterval"}},_vm._l((_vm.roundTourList),function(item){return _c('el-option',{key:item,attrs:{"label":item,"value":item}})}),1)],1),_vm._v(" "),_c('li',[_c('span',{staticClass:"text"},[_vm._v(_vm._s(_vm.$t('last.skipNoImgeUser')))]),_vm._v(" "),_c('el-switch',{attrs:{"inactive-color":"#dadada"},model:{value:(_vm.roundTour.skipNoImgeUser),callback:function ($$v) {_vm.$set(_vm.roundTour, "skipNoImgeUser", $$v)},expression:"roundTour.skipNoImgeUser"}})],1)])]),_vm._v(" "),_c('span',{staticClass:"dialog-footer",attrs:{"slot":"footer"},slot:"footer"},[_c('el-button',{on:{"click":_vm.handleClose}},[_vm._v(_vm._s(_vm.$t('btn.cancel')))]),_vm._v(" "),_c('el-button',{staticStyle:{"margin-left":"30px"},attrs:{"type":"primary"},on:{"click":_vm.setRoundTourEvent}},[_vm._v(_vm._s(_vm.$t('btn.determine')))])],1)])}
var setRoundTour_staticRenderFns = []
var setRoundTour_esExports = { render: setRoundTour_render, staticRenderFns: setRoundTour_staticRenderFns }
/* harmony default export */ var meeting_setRoundTour = (setRoundTour_esExports);
// CONCATENATED MODULE: ./src/components/meeting/setRoundTour.vue
function setRoundTour_injectStyle (ssrContext) {
  __webpack_require__("+Uo2")
  __webpack_require__("ZsmM")
}
var setRoundTour_normalizeComponent = __webpack_require__("VU/8")
/* script */


/* template */

/* template functional */
var setRoundTour___vue_template_functional__ = false
/* styles */
var setRoundTour___vue_styles__ = setRoundTour_injectStyle
/* scopeId */
var setRoundTour___vue_scopeId__ = "data-v-04c9d85e"
/* moduleIdentifier (server only) */
var setRoundTour___vue_module_identifier__ = null
var setRoundTour_Component = setRoundTour_normalizeComponent(
  setRoundTour,
  meeting_setRoundTour,
  setRoundTour___vue_template_functional__,
  setRoundTour___vue_styles__,
  setRoundTour___vue_scopeId__,
  setRoundTour___vue_module_identifier__
)

/* harmony default export */ var components_meeting_setRoundTour = (setRoundTour_Component.exports);

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./src/components/meet/Meeting.vue






//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



 //会中头部信息
 //会议信息弹框
 //延时弹框
 //延时弹框
// import Invite from "../Invite"; //邀请参会人弹框
 //参会人列表
 //设置主会场

// import chat from "../meeting/chat"; //会中im
// import chatNew from "../meeting/chat_new"; //会中im
 //指定参会人

 //参会人图标状态

 //默认头像



// import rongshi from '../../../public/rsconfig'
// RSIsShowDownLog

//白板







 //设置轮巡

/* harmony default export */ var Meeting = ({
  computed: extends_default()({}, Object(vuex_esm["d" /* mapState */])(["LoginServe"]), Object(vuex_esm["b" /* mapGetters */])(['memberInObj', 'user_account', 'meetInfo', 'memberOutObj', 'meetSetting', 'user_info', 'allMessages']), {
    confId: function confId() {
      return this.meetConfId || this.queryConfId;
    }
  }),
  components: {
    speakstaus: components_meeting_speakstaus,
    meetingHeader: components_meeting_meetingHeader,
    meetInfo: src_components_meeting_meetInfo,
    delayed: components_meeting_delayed,
    meetShare: meetShare["a" /* default */],
    // Invite,
    merberlist: components_meeting_merberlist,
    setMainHall: components_meeting_setMainHall,
    // chat,
    // chatNew,
    setLayout: components_meeting_setLayout,
    meetVideo: components_meeting_meetVideo,
    selfmeetVideo: components_meeting_selfmeetVideo,
    WhiteBoard: src_components_whiteBoard,
    setRoundTour: components_meeting_setRoundTour
  },
  data: function data() {
    return {
      mainVenue: '', //主会场成员id
      showLastVideo: false, //判断屏幕共享切屏时，是否显示后面的成员
      shareType: 1, //共享方式  1:分享桌面 2:白板
      whiteBoardRoomId: "", //白板房间id
      whiteBoardUserId: '',
      isWhiteBoarOrganiser: false, //白板发起人默认为true
      whiteBoardControllerDisabled: false, //白板控制条是否能用
      totalPage: 10, // 白板页数
      current: 1, //画板页码
      wbInfo: {},
      handUserMsg: "",
      isshowdargLi: false,
      loading: "",
      roomId: "",
      SelfMeetUserId: "", //userid+@
      userName: "",
      // meetInfo: {},
      joinState: 0,
      isLockMeet: false,
      MerberiList: {},
      MerberiList2: [],
      PlayUserList: [],
      photoList: {},
      defaultImg: defaultAvatar_default.a,
      netStatus: {},
      MSGList: [], //'聊天数组'
      isHost: false,
      isShowCamera: false,
      isShowAudio: false,
      isFullScreenStatus: false,
      screenShareIsShow: false,
      chatMSGValueNum: 0,
      video: null,
      videoStart: false,
      recorder: null,

      MoreWithMore: true,

      merberDialog: false,
      confirmLeavep: false,
      chatDialog: false, //聊天
      isDelChecked: true,
      SetLayoutDialog: false,
      meetInfoDialog: false,
      meetShareDialog: false,
      prolongDialogVisible: false,
      setVideoDialog: false,
      setMainHallDialog: false,
      activeName: "1",
      CurrentMicrophoneID: "",
      MicrophoneList: [],
      CurrentCameraID: "",
      CurrentSpeakerID: "",
      CameraList: [],
      SpeakerList: [],
      nextEndTime: "",
      oldId: {},

      addMerber: false,
      SelectedArr: [],
      SelectedList: [],

      screenShareIsMSG: "",
      IsShareIng: false,
      IsMainHall: false,
      selectMain: false,
      selecctMainIndex: 0,
      screenUserId: "",
      isScreenlockMeet: false,
      RSIsShowDownLog: false,
      isAllmuet: false,
      SaveStreamList: {},

      selfVideoModalShow: false,
      selfCodec: "", // 自己的编码类型;
      reqVideoLists: [], // 已经请求过成员视频列表;
      antiSsrc: "", // 请求视频的ssrc;
      screenStream: {},
      RSServe: "",
      showRightArrow: false,
      showRightFlag: true,
      showLeftArrow: false,
      showLeftFlag: true,
      pageNo: 1,
      memberInArrary: [],
      historyArr: [],
      isMediaConnect: false,
      queryConfId: "",
      isLogin: true,
      needAV: 'all',
      miniBoard: false,
      mediaType: 1,
      setRoundTourDialog: false,
      roundTourTimer: null,
      recordObj: {
        palyState: 0,
        pauseState: 0,
        cancleState: 0
      },
      voiceIncentiveId: ""
    };
  },

  props: {
    meetConfId: String,
    isShow: Boolean,
    joinMeetingState: Object
  },
  watch: {
    isShow: function isShow(newVal) {
      console.log('===newVal===', newVal);
      if (this.shareType === 2 && this.IsShareIng) {
        if (newVal) {
          this.leaveWbRoom(true, true);
        } else {
          this.joinWhiteBoardRoom(Number(this.whiteBoardRoomId), this.whiteBoardUserId);
        }
      }
    },

    PlayUserList: {
      deep: true,
      handler: function handler(newVal, oldVal) {
        var _this2 = this;

        console.log('PlayUserList change', newVal, oldVal);
        oldVal.forEach(function (item) {
          if (!newVal.includes(item) && item !== _this2.SelfMeetUserId && item.indexOf('=screenShare') === -1) {
            console.log('===成员不在主屏取消视频流订阅===', item);
            _this2.cancelReqVideo(1, 1, item);
          }
        });
      }
    },
    confId: {
      handler: function handler(newV, oldv) {
        console.log("newV:===============", newV);
        if (!newV) return;
        if (!this.user_account) return;
        var self = this;
        RL_MEET.disconnectMedia(function (e) {
          console.debug("退会：CCM退会成功", e);
          self.INIT();
        }, function (err) {
          console.debug("退会：CCM退会失败", err);
          self.INIT();
        });
        window.onresize = function () {
          if (!self.checkFull()) {
            // 退出全屏后要执行的动作
            self.isFullScreenStatus = false;
          }
        };
        self.RSServe = window.RSServe;
      },
      deep: true,
      immediate: true
    },

    meetSetting: {
      deep: true,
      handler: function handler(newVal, oldVal) {
        console.log('meetSetting change', newVal, oldVal);
        var _this = this;
        if (_this.roundTourTimer) clearInterval(_this.roundTourTimer);
        if (!!newVal.state) {
          if (get_own_property_names_default()(_this.memberInObj).length > 4) _this.nextScreen(newVal);
          _this.roundTourTimer = setInterval(function () {
            if (get_own_property_names_default()(_this.memberInObj).length > 4) {
              console.log('轮巡开始。。。');
              _this.nextScreen(newVal);
            }
          }, newVal.roundTourInterval * 1000);
        }
      },

      immediate: true
    }
  },
  created: function created() {
    // this.YHSDKLogin();
    var fontSize = window.CurrentUse && window.CurrentUser.systemSettings ? window.CurrentUser.systemSettings.FontSize : 100;
    this.setFontSize(fontSize);
  },
  beforeRouteEnter: function beforeRouteEnter(to, from, next) {
    console.log('重定向', to, from);
    if (to.query && to.query.confId) {
      next(function (that) {
        that.isLogin = false;
        that.queryConfId = to.query.confId;
      });
    } else {
      next();
    }
  },
  beforeDestroy: function beforeDestroy() {
    RL_MEET.MeetingListener(function () {});
    RL_Media.onConferenceNotifyLinstener(function () {});
    RL_Media.setOnPublishMedia(function () {});
    RL_Media.setOnTrack(function () {});
  },
  mounted: function mounted() {
    this.OneWithOneSmallDec();
    // 会议声音为混音，所以只需要一个audio;
    // 只播放自己本地的声音,暂时注释掉;
    var self = this;
    RL_Media.setOnPublishMedia(function (e, mediaType) {
      console.log('===setOnPublishMedia===', e, mediaType);
      self.mediaType = mediaType;
      self.$refs["selfVideo"].srcObject = e;
      self.SaveStreamList[self.SelfMeetUserId] = e;
      self.$store.commit('SET_StreamObj', self.SaveStreamList);
    });
    this.RX_Util.registerBusEvents({
      transferListenerData: self.transferListenerData,
      leaveAllMeet: self.leaveAllMeet,
      initMeeting: self.initMeeting
    }, this);
    RL_MEET.MeetingListener(this.Meetlistener);
    RL_Media.onConferenceNotifyLinstener(this.ConferenceNotify);
    console.log('===meeting mounted===');
  },

  methods: extends_default()({}, Object(vuex_esm["c" /* mapMutations */])(['SET_AllMessages']), {
    initMeeting: function initMeeting() {
      var self = this;
      RL_MEET.disconnectMedia(function (e) {
        console.debug("退会：CCM退会成功", e);
        self.INIT();
      }, function (err) {
        console.debug("退会：CCM退会失败", err);
        self.INIT();
      });
    },
    transferListenerData: function transferListenerData(fromListener, data) {
      if (fromListener == 'onMsgReceiveListener') {
        console.log('来自RL_Chat.onMsgReceiveListener的消息', data);
        this.IMMsgListener(data);
      } else if (fromListener === 'MeetNotice_IM') {
        this.ConferenceNotify(data);
      } else if (fromListener === 'unReadMsgCount') {
        if (!this.chatDialog) {
          var limit = data || 1;
          this.chatMSGValueNum += limit;
        }
      }
    },
    checkFull: function checkFull() {
      //判断浏览器是否处于全屏状态 （需要考虑兼容问题）
      //火狐浏览器
      var isFull = document.mozFullScreen || document.fullScreen ||
      //谷歌浏览器及Webkit内核浏览器
      document.webkitIsFullScreen || document.webkitRequestFullScreen || document.mozRequestFullScreen || document.msFullscreenEnabled;
      if (isFull === undefined) {
        isFull = false;
      }
      return isFull;
    },
    downlog: function downlog() {
      var bugout = new debugout["Debugout"]();
      var bugoutName = this.$t('meeting.log') + this.roomId + "_" + this.userName + "_" + new Date().getTime();
      bugout.logFilename = bugoutName + ".log";
      console.info("日志下载");
      bugout.log('test');
      bugout.downloadLog();
    },
    isChangeLayout: function isChangeLayout() {
      if (get_own_property_names_default()(this.memberInObj).length < 2) {
        this.$message({
          message: this.$t('meeting.notChangeViewLayout'),
          type: "error"
        });
        return;
      } else {
        if (!this.MoreWithMore) {
          this.selecctMainIndex = 0;
        } else {
          this.selecctMainIndex = 1;
        }
        this.selectMain = true;
      }
    },
    changelaout: function changelaout() {
      if (this.selecctMainIndex == 0) {
        this.MoreWithMore = false;
        // 取消订阅所有
      } else {
        this.MoreWithMore = true;
      }

      this.selectMain = false;
    },
    OneWithOneSmallDec: function OneWithOneSmallDec() {
      var self = this;
      if (document.getElementById("dargLi")) {
        var drag = document.getElementById("dargLi");

        // //点击某物体时，用drag对象即可，move和up是全局区域，
        // 也就是整个文档通用，应该使用document对象而不是drag对象(否则，采用drag对象时物体只能往右方或下方移动)
        drag.onmousedown = function (event) {
          // console.log(event)
          var startTime = event.timeStamp;

          var event = event || window.event; //兼容IE浏览器
          //    鼠标点击物体那一刻相对于物体左侧边框的距离=点击时的位置相对于浏览器最左边的距离-物体左边框相对于浏览器最左边的距离
          var diffX = event.clientX - drag.offsetLeft;
          var diffY = event.clientY - drag.offsetTop;
          // console.log(startTime, event.clientX, event.clientY)
          if (typeof drag.setCapture !== "undefined") {
            drag.setCapture();
          }
          document.onmousemove = function (event) {
            var event = event || window.event;
            var moveX = event.clientX - diffX;
            var moveY = event.clientY - diffY;
            if (moveX < 0) {
              moveX = 0;
            } else if (moveX > window.innerWidth - drag.offsetWidth) {
              moveX = window.innerWidth - drag.offsetWidth;
            }
            if (moveY < 0) {
              moveY = 0;
            } else if (moveY > window.innerHeight - drag.offsetHeight - 110) {
              // 减去底部footer的高;
              moveY = window.innerHeight - drag.offsetHeight - 110;
            }
            // else {
            drag.style.left = moveX + "px";
            drag.style.top = moveY + "px";
            // }
          };
          document.onmouseup = function (event) {
            var diffTime = event.timeStamp - startTime;
            if (diffTime < 150) {
              self.isshowdargLi = !self.isshowdargLi;
            }
            this.onmousemove = null;
            this.onmouseup = null;
            //修复低版本ie bug
            if (typeof drag.releaseCapture != "undefined") {
              drag.releaseCapture();
            }
          };
        };
      }
    },
    memberIdFilter: function memberIdFilter(id) {
      if (id.includes('@')) {
        return id.substr(0, id.lastIndexOf('@'));
      } else {
        return id;
      }
    },
    GetUserPhoto: function GetUserPhoto(memberId) {
      if (this.memberInObj[memberId] && (this.memberInObj[memberId].photoUrl || this.memberInObj[memberId].photoUrl === false) || this.memberOutObj[memberId] && (this.memberOutObj[memberId].photoUrl || this.memberOutObj[memberId].photoUrl === false)) return;
      var member = this.memberIdFilter(memberId);
      member = member + '_refresh';
    },
    stopRecordingCallback: function stopRecordingCallback() {
      // this.video.src = this.video.srcObject = null;
      this.video.src = URL.createObjectURL(this.recorder.getBlob());

      var file = new File([this.recorder.getBlob()], this.$t('meeting.test'), {
        type: "video/mp4"
      });

      console.log(file);

      var a = document.createElement("a");
      a.download = this.$t('meeting.test');
      a.style.display = "none";
      a.href = window.URL.createObjectURL(file);
      document.body.appendChild(a);
      a.click();
      a.remove();
      this.recorder.screen.stop();
      this.recorder.destroy();
      this.recorder = null;
      this.videoStart = false;
    },
    stopRecording: function stopRecording() {
      this.recorder.stopRecording(this.stopRecordingCallback);
    },
    addStreamStopListener: function addStreamStopListener(stream, callback) {
      stream.addEventListener("ended", function () {
        callback();
        callback = function callback() {};
      }, false);
      stream.addEventListener("inactive", function () {
        callback();
        callback = function callback() {};
      }, false);
      stream.getTracks().forEach(function (track) {
        track.addEventListener("ended", function () {
          callback();
          callback = function callback() {};
        }, false);
        track.addEventListener("inactive", function () {
          callback();
          callback = function callback() {};
        }, false);
      });
    },
    invokeGetDisplayMedia: function invokeGetDisplayMedia(success, error) {
      var displaymediastreamconstraints = {
        video: {
          displaySurface: "monitor", // monitor, window, application, browser
          logicalSurface: true,
          cursor: "always" // never, always, motion
        },
        audio: true,
        speaker: true
      };
      // above constraints are NOT supported YET
      // that's why overridnig them
      displaymediastreamconstraints = {
        video: true,
        audio: true,
        speaker: true
      };
      if (navigator.mediaDevices.getDisplayMedia) {
        navigator.mediaDevices.getDisplayMedia(displaymediastreamconstraints).then(success).catch(error);
      } else {
        navigator.getDisplayMedia(displaymediastreamconstraints).then(success).catch(error);
      }
    },
    captureScreen: function captureScreen(callback) {
      var _this3 = this;

      this.invokeGetDisplayMedia(function (screen) {
        _this3.addStreamStopListener(screen, function () {
          //
        });
        callback(screen);
      }, function (error) {
        console.error(error);
        alert("Unable to capture your screen. Please check console logs.\n" + error);
      });
    },
    startRecording: function startRecording() {
      var _this4 = this;

      this.$message.error(this.$t('meeting.build'));
      return;
      this.captureScreen(function (screen) {
        _this4.video.srcObject = screen;
        _this4.recorder = RecordRTC_default()(screen, {
          type: "video"
        });

        _this4.recorder.startRecording();
        // release screen on stopRecording
        _this4.recorder.screen = screen;
        _this4.videoStart = true;
      });
    },
    PreviewingVideo: function PreviewingVideo() {
      var self = this;
      if (self.$refs["SelectVideo2"]) {
        self.$set(self.$refs["SelectVideo2"], "srcObject", self.$refs["selfVideo"].srcObject);
      }
    },
    INIT: function INIT() {
      var self = this;
      self.loading = self.$loading({
        lock: true,
        text: this.$t('meeting.load'),
        spinner: "el-icon-loading",
        background: "rgba(0, 0, 0, 0.7)"
      });
      self.roomId = self.confId;
      console.log("会前：当前会议号" + self.roomId);
      if (self.LoginServe.Profile && self.LoginServe.Profile.NickName) {
        self.SelfMeetUserId = self.LoginServe.UserId + "@21";
        self.$store.commit('SET_SelfMeetUserId', self.SelfMeetUserId);
        self.userName = self.LoginServe.Profile.NickName;
        console.log("会前：登录", "\u767B\u5F55userid:" + self.LoginServe.UserId + ",userName:" + self.userName);
        if (self.LoginServe.UserId.indexOf('vistor') > -1) {
          window.CurrentUser = self.LoginServe;
        }
        if (self.LoginServe.Profile.NickName) {
          self.YHSDKJoinMeet();
        } else {
          self.YHSDKLogin();
        }
      } else {
        self.loading.close();
        console.debug("会前：游客登录");
        self.$router.replace({
          name: "login",
          query: {
            roomId: self.roomId
          }
        });
      }
    },
    YHSDKLogin: function YHSDKLogin() {
      var self = this;
      RL_Media.chatRommNickName = self.userName;
      mediaMeeting.YHnickName = self.userName;
      mediaMeeting.YHidType = self.LoginServe.Profile.UserType || 1;
      mediaMeeting._appid = self.LoginServe.AppId;
      mediaMeeting._appToken = self.LoginServe.AppToken;
      RL_YTX_NEW.init({
        appId: self.LoginServe.AppId,
        serverIp: window._ws,
        isV3: true
      });
      RL_YTX_NEW.chatInit({
        fileServerIp: window.fileServerIp,
        lvsServer: window.FILE_ACCESS_URL,
        getMsgByArray: true
      });
      window.Configs.maxUploadFileSize = 100 * 1024 * 1024;
      mediaMeeting.serverIp = self.$md5(self.LoginServe.ConnectorAddrs[0]);
      mediaMeeting.lvsServer = self.LoginServe.LvsAddrs[0];
      mediaMeeting.ClientSecretKey = self.LoginServe.ClientSecretKey || 1;
      RL_YTX_NEW.onConnectStateChangeLisenter(self.connectState);
      mediaMeeting.Login(self.LoginServe.UserId, function () {
        console.debug("会中：SDK缓存登录成功");
        RL_MEET.init(self.LoginServe.AppId, self.LoginServe.UserId);
        RL_MEET.MeetingListener(self.Meetlistener);
        self.YHSDKJoinMeet();
        RL_Chat.uploadPersonInfo({
          nickName: self.userName
        }, function (res) {
          console.log('===uploadPersonInfo success===', self.userName);
        }, function (err) {});
      });
      // RL_MEET.InviteJoinMeetListener(self.ConferenceNotify);
    },
    YHSDKError: function YHSDKError(err) {
      var _this5 = this;

      var self = this;
      if (err.statusCode == "814007") {
        // this.$message.error(this.$t('meeting.wrongPassword'));
        self.$prompt("", this.$t('meeting.pleaseInputMeetingPassword'), {
          confirmButtonText: this.$t('btn.determine'),
          center: true,
          showCancelButton: false,
          inputPattern: /^\d{6}$/,
          inputErrorMessage: this.$t('meeting.pleaseEnterPassword'),
          inputType: "number",
          inputValue: this.$t('meeting.pleaseEnterPassword'),
          inputPlaceholder: this.$t('meeting.pleaseEnterPassword')
        }).then(function (_ref) {
          var value = _ref.value;

          if (value) {
            self.$route.params.pwd = value;
            self.YHSDKJoinMeet();
          } else {
            _this5.$message({
              message: _this5.$t('meeting.pleaseInputPassword'),
              type: "error"
            });
          }
        }).catch(function () {});
      } else {
        if (err.statusCode === 174005) {
          this.$message.error(this.$t('meeting.noCameraFound'));
        } else if (err.statusCode == "814006") {
          this.$message.error(this.$t('meeting.wrongMeetingNumber'));
        } else if (err.statusCode == "814026") {
          this.$message.error(this.$t('meeting.meetingNotStart'));
        } else if (err.statusCode == "814012") {
          this.$message.error(this.$t('meeting.meetingLocked'));
        } else if (err.statusCode == "120001") {
          this.$message.error(this.$t('meeting.joinMeetingFaileds'));
        } else if (err.statusCode == "814007") {
          this.$message.error(this.$t('meeting.wrongPassword'));
          self.$prompt("", this.$t('meeting.pleaseInputMeetingPassword'), {
            confirmButtonText: this.$t('ben.determine'),
            center: true,
            showCancelButton: false,
            inputPattern: /^\d{6}$/,
            inputErrorMessage: this.$t('meeting.pleaseEnterPassword'),
            inputType: "number",
            inputValue: this.$t('meeting.pleaseEnterPassword'),
            inputPlaceholder: this.$t('meeting.pleaseEnterPassword')
          }).then(function (_ref2) {
            var value = _ref2.value;

            if (value) {
              // self.$route.params.pwd
            } else {
              _this5.$message({
                message: _this5.$t('meeting.pleaseInputPassword'),
                type: "error"
              });
            }
          }).catch(function () {});
        } else {
          console.error("入会失败：", err);
          if (err.statusMsg) {
            this.$message.error(this.$t('meeting.joinMeetingFailed') + '，' + err.statusMsg);
          } else {
            this.$message.error(this.$t('meeting.joinMeetingFailed'));
          }
          this.$router.replace('/yuntongxun');
        }
        self.loading.close();
        // 匿名入会
        if (this.SelfMeetUserId.indexOf("vistor") > -1) {
          RL_YTX_NEW.logout(function () {
            _this5.$router.replace({
              name: "login"
            });
          });
        } else {
          this.$router.replace('/yuntongxun');
        }
      }
    },
    joinWhiteBoardRoom: function joinWhiteBoardRoom(whiteBoardRoomId, userid) {
      var _this6 = this;

      var self = this;
      // 初始化白板
      self.whiteBoardUserId = userid;
      this.$refs.WhiteBoard.init();
      var builder = new YTX_WBSS_API.JoinRoomBuilder(whiteBoardRoomId, "123456", 0);
      YTX_WBSS_API.joinRoom(builder, function (res) {
        _this6.miniBoard = true;
        var selfUserId = _this6.memberIdFilter(_this6.SelfMeetUserId);
        console.log(res);
        // 获取白板当前页码
        _this6.current = res.wbssRoomInfoMap.wbssCurtentPageId;
        // YTX_WBSS_API.clearCurrentPage();
        // 检验是否是白板发起人
        var isTrue = userid.includes(selfUserId) ? true : false;
        console.log('SelfMeetUserId---', _this6.SelfMeetUserId);
        // 设置白板发起人关闭白板共享按钮
        _this6.screenShareIsShow = isTrue;
        // 设置白板发起人为false
        _this6.isWhiteBoarOrganiser = isTrue;
        self.$set(_this6, 'wbInfo', {
          docArr: res["wbssRoomInfoMap"].wbssDocInfoDataArray,
          docId: res["wbssRoomInfoMap"].wbssCurrentDocId,
          totalPage: res["wbssRoomInfoMap"].wbssDocInfoDataArray[res["wbssRoomInfoMap"].wbssCurrentDocId].wbssDocTotalPage,
          current: res.wbssRoomInfoMap.wbssCurtentPageId,
          isWhiteBoarOrganiser: isTrue,
          wbRoomId: whiteBoardRoomId
        });
        // 加入白板 保存布局状态,退出白板后保留该状态
        window.sessionStorage.setItem("selecctMainIndex", _this6.MoreWithMore);
        // 改成1v1
        _this6.selectMain = false;
        _this6.selecctMainIndex = 0;
        _this6.shareType = 2;
        _this6.IsShareIng = true;
      }, function (err) {
        _this6.$message.error({
          message: err.msg,
          type: "error"
        });
      });
    },
    leaveWbRoom: function leaveWbRoom(destroy, isMini) {
      var self = this;
      var builder = new YTX_WBSS_API.LeaveRoomBuilder(parseInt(this.whiteBoardRoomId));
      console.log('===离开白板房间===');
      YTX_WBSS_API.leaveRoom(builder, function (resp) {
        console.log('===离开白板房间成功===', resp);
        if (!isMini) {
          self.screenShareIsShow = false;
          self.shareType = 1;
          self.IsShareIng = false;
        }
      }, function (err) {
        if (!destroy) {
          console.log('leaveroom err', err);
          self.$alert(self.$t('meeting.abnormalExitingWhiteboard'), self.$t('modelMessage.prompt'), {
            confirmButtonText: self.$t('btn.determine'),
            callback: function callback(action) {
              // 匿名入会
              if (self.SelfMeetUserId.indexOf("vistor") > -1) {
                window.location.reload();
              } else {
                window.location.reload();
              }
            }
          });
        }
      });
    },

    // 关闭白板
    closeWhiteBoardShare: function closeWhiteBoardShare() {
      var self = this;
      self.stopWhiteboardSharing(function (res) {
        try {
          YTX_WBSS_API.clearCurrentPage();
        } catch (error) {} finally {
          self.miniBoard = false;
          // 设置白板发起人为false
          self.screenShareIsShow = false;
          self.isWhiteBoarOrganiser = false;
          self.IsShareIng = false;
          self.shareType = 1;
          var builder = new YTX_WBSS_API.DeleteRoomBuilder(parseInt(self.whiteBoardRoomId));
          YTX_WBSS_API.deleteRoom(builder, function (resp) {
            console.log('deleteRoom', resp);
          }, function (err) {
            console.log("delete room error", err);
          });
        }
      });
    },
    shareWhiteBoard: function shareWhiteBoard() {
      var self = this;
      if (this.isScreenlockMeet && !this.isHost) {
        this.$message.error(this.$t('meeting.sharingLock'));
        return;
      }
      // 检验是否有人再共享白板
      if (this.IsShareIng || this.miniBoard) {
        return self.$message.error(this.$t('meeting.sharing'));
      }
      // 初始化白板
      this.$refs.WhiteBoard.init();

      var roomId = self.roomId;
      //修改分享状态
      self.shareType = 2;
      self.IsShareIng = true;
      // self.$nextTick(to => {
      var builder = new YTX_WBSS_API.CreateRoomBuilder(1, "123456", 100, 0, this.meetInfo.confId);
      console.log('builder===', builder);
      YTX_WBSS_API.createRoom(builder, function (resp) {
        self.miniBoard = true;
        console.info(resp);
        self.$set(self, 'wbInfo', {
          docArr: resp["wbssRoomInfoMap"].wbssDocInfoDataArray,
          docId: resp["wbssRoomInfoMap"].wbssCurrentDocId,
          totalPage: resp["wbssRoomInfoMap"].wbssDocInfoDataArray[resp["wbssRoomInfoMap"].wbssCurrentDocId].wbssDocTotalPage,
          current: resp.wbssRoomInfoMap.wbssCurtentPageId,
          isWhiteBoarOrganiser: true,
          wbRoomId: resp["wbssRoomInfoMap"].wbssCurrentRoomId
        });
        // 创建白板 保存布局状态,退出白板后保留该状态
        window.sessionStorage.setItem("selecctMainIndex", self.MoreWithMore);
        // 改成1v1
        self.selectMain = false;
        self.selecctMainIndex = 0;
        // 共享成功修改状态
        self.screenShareIsShow = true;
        self.whiteBoardRoomId = resp["wbssRoomInfoMap"].wbssCurrentRoomId;
        self.whiteBoardUserId = self.SelfMeetUserId;
        // 设置白板发起人
        self.isWhiteBoarOrganiser = true;
        // 监听发起白板通知ccm
        self.startBoardSharing();
      }, function (resp) {
        console.info(resp);
        self.shareType = 1;
        self.IsShareIng = false;
        self.$message.error({
          message: resp.msg,
          type: "error"
        });
      });
      // });
    },


    // 开启ccm白板共享
    startBoardSharing: function startBoardSharing() {
      var self = this;
      // 开始白板共享
      var StartWhiteboardSharingBuilder = new RL_MEET.StartWhiteboardSharingBuilder();

      var obj = new Object();
      obj.roomId = self.whiteBoardRoomId + "";
      // obj.boardtype = "1";
      // obj.deviceType = "21";
      obj.password = "123456";
      obj.pwd = "123456"; //兼容其他端白板字段
      // obj.server = `https://${this.LoginServe.WbssAddrs[0]}`;
      obj.server = this.LoginServe.WbssAddrs[0];
      // obj.roomtype = "1";
      obj.userid = self.SelfMeetUserId + "";
      obj.username = self.LoginServe.Profile.NickName + "";
      console.log('startwhiteboard obj', obj);
      StartWhiteboardSharingBuilder.setWbInfo(stringify_default()(obj));
      RL_MEET.StartWhiteboardSharing(StartWhiteboardSharingBuilder, function (res) {
        console.info(res);
        if (res.statusCode == "000000") {
          console.log("share success");
        }
      }, function (error) {
        console.info(error);
        console.log("share error");
      });
    },


    // 关闭ccm白板共享
    stopWhiteboardSharing: function stopWhiteboardSharing(callback) {
      var _this7 = this;

      var StopWhiteboardSharingBuilder = new RL_MEET.StopWhiteboardSharingBuilder();
      var obj = new Object();
      obj.roomId = this.whiteBoardRoomId.toString();
      StopWhiteboardSharingBuilder.setWbInfo(stringify_default()(obj));
      RL_MEET.StopWhiteboardSharing(StopWhiteboardSharingBuilder, function (res) {
        if (res.statusCode == "000000") {
          callback(res);
        }
      }, function (error) {
        console.info(error);
        _this7.leaveWbRoom(true);
      });
    },
    confirmShow: function confirmShow() {
      var _this8 = this;

      var self = this;
      console.log(self.joinMeetingState);
      var isCloseVideo = true;
      var isCloseAudio = true;
      if (self.joinMeetingState) {
        isCloseVideo = self.joinMeetingState.isCloseVideo;
        isCloseAudio = self.joinMeetingState.isCloseAudio;
      }
      self.$confirm(this.$t('meeting.protectWserPrivacy'), this.$t('modelMessage.prompt'), {
        confirmButtonText: this.$t('btn.determine'),
        cancelButtonText: this.$t('btn.cancel'),
        customClass: "confirm",
        showClose: false,
        showCancelButton: false,
        center: true
        // type: 'info'
      }).then(function () {
        console.log(_this8.joinMeetingState);
        if (self.isHost) {
          console.log('===this.needAV===', _this8.needAV);
          setTimeout(function () {
            if (_this8.needAV === 'all' || _this8.needAV === 'video') {
              self.openCamera(true);
            }
            if (_this8.needAV === 'all' || _this8.needAV === 'audio') {
              self.openMicrophone(true);
            }
          }, 100);
        } else {
          // let joinState = self.meetInfo.joinState;
          // if ( joinState & 0x000040) {
          //   //如果设置入会打开麦克风
          //   self.openMicrophone(true);
          // } else {
          //   // self.closeMicrophone(true);
          // }

          // if ( joinState & 0x000004) {
          //   //如果设置入会打开摄像头
          //   setTimeout(() => {
          //     self.openCamera(true);
          //   }, 100);
          // } else {
          //   // self.closeCameraAndPubVideo(true);
          // }

          if (!isCloseVideo) {
            self.openCamera(true);
          } else {
            self.closeCameraAndPubVideo(true);
          }
          if (!isCloseAudio) {
            self.openMicrophone(true);
          } else {
            self.closeMicrophone(true);
          }
        }
        if (self.meetInfo.wbInfo) {
          var wbInfo = JSON.parse(self.meetInfo.wbInfo);
          self.whiteBoardRoomId = wbInfo.roomId;
          self.joinWhiteBoardRoom(Number(wbInfo.roomId), wbInfo.userid);
        }
      });
    },
    YHSDKJoinMeet: function YHSDKJoinMeet() {
      console.log(this.joinMeetingState);
      RL_Media.setOnTrack(this.getStreamListener);
      var self = this;
      var joinMeetRoomBuilder = new RL_MEET.JoinMeetRoomBuilder();
      joinMeetRoomBuilder.setConfId(self.roomId);
      joinMeetRoomBuilder.setUserName(self.userName);
      joinMeetRoomBuilder.setPassword(self.$route.params.pwd);
      joinMeetRoomBuilder.setJoinType(2); // joinType若为2，则需要请求媒体权限;
      if (this.joinMeetingState && this.joinMeetingState.joinMeetingState) joinMeetRoomBuilder.setJoinState(this.joinMeetingState.joinMeetingState);
      console.log('joinMeetRoomBuilder', joinMeetRoomBuilder);
      RL_MEET.JoinMeetRoom(joinMeetRoomBuilder, function (e, a) {
        console.debug("会中：YH加入会议成功", e.conf.members);
        // 全屏模式
        console.log(a);
        self.$bus.emit('toggleHeader', false);
        self.selfVideoModalShow = true;
        self.PlayUserList = [self.SelfMeetUserId];
        self.memberInArrary = [self.SelfMeetUserId];
      }, function (err) {
        console.log(err);
        self.YHSDKError(err);
      });
      //注册通知事件监听
      if (self.queryConfId && !self.meetConfId) {
        // RL_MEET.InviteJoinMeetListener(this.ConferenceNotify);
        RL_MEET.IMMsgListener(self.IMMsgListener);
      }
      RL_Chat.getMyInfo(function (obj) {
        console.debug("会中IM：获取个人消息", obj);
      }, function (err) {
        console.log(err, "错误");
      });
      //注册群组通知事件监听
      // RL_Chat.onNoticeReceiveListener(obj => {
      //     console.log("获取群组通知");
      //     console.log(obj);
      //     //收到群组通知
      // });
    },
    IMMsgListener: function IMMsgListener(obj) {
      var self = this;
      console.log(obj, "聊天接收消息通知");
      if (!!this.isNewMeetingChat) {
        if (Array.isArray(obj)) {
          for (var i = 0; i < obj.length; i++) {
            this.$bus.emit('dealMessagesChat', obj[i]);
          }
        } else {
          this.$bus.emit('dealMessagesChat', obj);
        }
      } else {
        if (Array.isArray(obj)) obj = obj[0];
        if (obj.msgReceiver != this.meetInfo.chatGroupId) {
          return;
        }
        if (obj.msgType === 1) {
          if (obj.msgContent != "ytx-control-hardware") {
            // if (obj.msgSender.indexOf('vistor') > -1) {
            for (var _i in this.memberInObj) {
              if (_i.indexOf(obj.msgSender) > -1) {
                obj.senderNickName = this.memberInObj[_i].userName;
                // obj.photoUrl = this.memberInObj[i].photourl;
                if (this.memberInObj[_i].photourl) {
                  obj.userPhotoId = _i;
                }
              }
            }
            // }
            self.MSGList.push({
              msg: obj.msgContent,
              msgType: obj.msgType,
              userid: obj.msgSender,
              NickName: obj.senderNickName,
              userPhotoId: obj.userPhotoId
            });
          }
          if (!self.chatDialog) {
            self.chatMSGValueNum++;
          }
        } else if (obj.msgType === 50) {
          //邀请成员通知
          // this.$message({
          //   type: "info",
          //   message: ""
          // });
          // return;
        }
      }
    },
    screenlockMeet: function screenlockMeet() {
      var _this9 = this;

      var that = this;
      if (!this.isHost) {
        that.$message({
          message: this.$t('meeting.haveNoPermission'),
          type: "error"
        });
        return;
      }
      var acon = 0;
      var msg = this.$t('meeting.theSharingIsLocked');
      if (this.isScreenlockMeet) {
        acon = 3;
        msg = this.$t('meeting.theSharingIsUnlocked');
      } else {
        acon = 2;
      }
      var LockMeetBuilder = new RL_MEET.LockMeetBuilder();
      LockMeetBuilder.setAction(acon);
      LockMeetBuilder.setConfId(that.roomId);
      RL_MEET.LockMeet(LockMeetBuilder, function (res) {
        _this9.isScreenlockMeet = !_this9.isScreenlockMeet;
        _this9.$message.info(msg);
      }, function (error) {
        console.info(error);
      });
    },
    lockMeet: function lockMeet() {
      var _this10 = this;

      var that = this;
      if (!this.isHost) {
        that.$message({
          message: this.$t('meeting.haveNoPermission'),
          type: "error"
        });
        return;
      }
      var acon = 0;
      var msg = this.$t('meeting.theMeetingIsLocked');
      if (this.isLockMeet) {
        acon = 1;
        msg = this.$t('meeting.theMeetingIsUnlocked');
      } else {
        acon = 0;
      }
      var LockMeetBuilder = new RL_MEET.LockMeetBuilder();
      LockMeetBuilder.setAction(acon);
      LockMeetBuilder.setConfId(that.roomId);
      RL_MEET.LockMeet(LockMeetBuilder, function (res) {
        _this10.isLockMeet = !_this10.isLockMeet;
        _this10.$message.info(msg);
      }, function (error) {
        console.info(error);
      });
    },
    leaveAllMeet: function leaveAllMeet(leave) {
      var _this11 = this;

      if (this.shareType == 2 && this.IsShareIng || this.miniBoard) {
        this.leaveWbRoom(true);
      }
      if (this.isDelChecked && !leave && this.isHost) {
        RL_MEET.DeleteMeeting(self.roomId, function (e) {
          _this11.$bus.emit("updateMeetingList");
        }, function (err) {});
      } else {
        RL_MEET.leaveMeeting(function (e) {
          console.debug("退会：CCM退会成功", e);
          _this11.$bus.emit("updateMeetingList");
        }, function (err) {
          console.debug("退会：CCM退会失败", err);
        });
      }
      // 清除allMessages数据
      if (this.allMessages && this.allMessages[this.GroupId] && this.allMessages[this.GroupId].msgs.length > 0) {
        this.allMessages[this.GroupId].msgs.length = 0;
        this.SET_AllMessages(this.allMessages);
      }
      if (this.roundTourTimer) clearInterval(this.roundTourTimer);
      this.loading.close();
      // 匿名入会
      if (this.SelfMeetUserId.indexOf("vistor") > -1) {
        this.$router.replace({
          name: "login"
        });
        setTimeout(function () {
          location.reload();
        }, 100);
      } else {
        if (this.confirmLeavep) this.confirmLeavep = false;
        this.queryConfId = "";
        this.IsShareIng = false;
        this.miniBoard = false;
        this.$bus.emit('toggleHeader', true);
        this.$router.replace('/yuntongxun');
      }
    },
    LeaveMeetBtn: function LeaveMeetBtn() {
      var _this12 = this;

      if (this.isHost) {
        this.confirmLeavep = true;
      } else {
        this.$confirm(this.$t('meeting.goingToExitTheMeeting'), this.$t('modelMessage.prompt'), {
          confirmButtonText: this.$t('btn.determine'),
          cancelButtonText: this.$t('btn.cancel'),
          customClass: "confirm",
          roundButton: true,
          center: true
        }).then(function () {
          _this12.leaveAllMeet();
        }).catch(function (error) {});
      }
    },
    closeCameraAndPubVideo: function closeCameraAndPubVideo(notip) {
      //关闭本地摄像头
      console.debug("--关闭本地摄像头");
      var self = this;
      RL_MEET.StopPublishVideo(function () {
        if (!notip) {
          self.$message.info(self.$t('meeting.cameraIsTurnedOffSuccess'));
        }
      }, function () {
        self.$message.error(self.$t('meeting.localCameraFailedTurnedOff'));
      });
      self.isShowCamera = false;
    },
    openCamera: function openCamera(notip) {
      //打开摄像头
      console.debug("--打开摄像头");
      if (this.mediaType == 0) {
        this.$message.error(this.$t('meeting.noCameraDetected'));
        return;
      }
      this.isShowCamera = true;
      var self = this;
      RL_MEET.StartPublishVideo(function () {
        if (!notip) {
          self.$message.info(self.$t('meeting.openCameraSuccess'));
        }
      }, function () {
        self.$message.error(self.$t('meeting.openCameraFailed'));
      });
    },
    planHand: function planHand() {
      var self = this;
      var startPublishVoiceBuilder = new RL_MEET.StartPublishVoiceBuilder();
      startPublishVoiceBuilder.setExclusively(2);
      RL_MEET.StartPublishVoice(startPublishVoiceBuilder, function (e) {
        var resp = JSON.parse(e.result);
        if (resp.statusCode == "000000") {} else {
          self.$message.error(self.$t('meeting.raiseHandFailed') + resp.statusMsg);
        }
      });
    },
    handUser: function handUser() {
      var self = this;
      var handCount = 0;
      var handNames = [];
      for (var user in self.MerberiList) {
        if (self.MerberiList[user].state & 0x00020000 && self.MerberiList[user].roleId == 11) {
          handCount++;
          if (handCount < 3) {
            handNames.push(self.MerberiList[user].userName);
          }
        }
      }
      var handMsg = "";
      if (handCount == 1) {
        handMsg = handNames[0] + self.$t('meeting.raiseHandForSpeak');
      }

      if (handCount > 1) {
        handMsg = handNames[0] + "、" + handNames[1] + self.$t('meeting.wait') + handCount + this.$t('meeting.raiseHand');
      }
      if (handCount > 0) {
        self.handUserMsg = handMsg;
      } else {
        self.handUserMsg = "";
      }
    },
    closePlanHand: function closePlanHand() {
      var self = this;
      var startPublishVoiceBuilder = new RL_MEET.StartPublishVoiceBuilder();
      startPublishVoiceBuilder.setExclusively(6);
      RL_MEET.StartPublishVoice(startPublishVoiceBuilder, function (e) {
        var resp = JSON.parse(e.result);
        if (resp.statusCode == "000000") {} else {
          self.$message.error(self.$t('meeting.raiseHandFailed') + resp.statusMsg);
        }
      });
    },
    openMicrophone: function openMicrophone(notip) {
      //打开麦克风
      console.debug("--打开麦克风");
      if (this.memberInObj[this.SelfMeetUserId] && this.memberInObj[this.SelfMeetUserId].roleId == 11) {
        this.$message.info(this.$t('meeting.notAllowParticipants'));
        return;
      }
      var self = this;
      self.isShowAudio = true;
      RL_MEET.StartPublishVoice(function () {
        if (!notip) {
          self.$message.info(self.$t('meeting.successTurnedMicrophone'));
        }
      }, function () {
        self.$message.error(self.$t('meeting.failedTurnedMicrophone'));
      });
    },
    closeMicrophone: function closeMicrophone(notip) {
      console.debug("--关闭麦克风");
      var self = this;
      self.isShowAudio = false;
      RL_MEET.StopPublishVoice(function () {
        if (!notip) {
          self.$message.info(self.$t('meeting.successTurnedOffMicrophone'));
        }
      }, function () {
        self.$message.error(self.$t('meeting.failedTurnedOffMicrophone'));
      });
    },
    inviteMerbers: function inviteMerbers() {
      var self = this;
      self.SelectedList = [];
      var memberInObj = JSON.parse(stringify_default()(this.memberInObj));
      var memberOut = JSON.parse(stringify_default()(this.memberOutObj));
      var members = assign_default()(memberInObj, memberOut);
      console.log('members---', members);
      for (var key in members) {
        var username = members[key].username;
        if (key && key.indexOf("@") > -1) {
          key = key.substr(0, key.indexOf("@"));
        }
        self.SelectedList.push({ account: key, username: username });
      }
      var memberCount = this.meetInfo.maxMember - keys_default()(this.memberInObj).length - keys_default()(this.memberOutObj).length;
      self.$bus.emit('addPerson', true, memberCount, self.SelectedList, self.inviteMerber, true);
    },
    inviteMerber: function inviteMerber(data) {
      console.log('inviteMerber====', data);
      this.closePop();
      var userlist = [];
      for (var i = 0; i < data.length; i++) {
        if (!data[i].disabled) {
          userlist.push({
            userName: data[i].username || data[i].unm || data[i].account,
            memberId: data[i].userId || data[i].account,
            idType: 2,
            photoUrl: data[i].photoUrl
          });
        }
      }
      var that = this;
      var inviteMemberBuilder = new RL_MEET.InviteMemberBuilder();
      inviteMemberBuilder.setInviteMembers(userlist);
      inviteMemberBuilder.setConfId(that.roomId);
      inviteMemberBuilder.setCallImmediately(1);
      RL_MEET.InviteMember(inviteMemberBuilder, function (e) {
        that.closePop();
        that.$message({
          message: that.$t('group.inviteSuccess'),
          type: "success"
        });
        // that.inveUserList.push(...data)
        // that.inveUserList = Array.from(new Set(that.inveUserList))
      }, function (err) {
        that.closePop();
        that.$message({
          message: err.statusMsg,
          type: "error"
        });
      });
    },

    // 获取媒体设备信息;
    getMediaDeviceList: function getMediaDeviceList() {
      var _this13 = this;

      var self = this;
      var currentSpeakerID;
      var currentCameraID;
      var currentMicrophoneID;
      var speakers = [];
      var cameras = [];
      var microphone = [];

      RL_Media.GetMediaDevice(function (deviceList) {
        console.log(deviceList, "deviceList===========");
        for (var key in deviceList) {
          var val = deviceList[key];
          if (val.kind == 'audiooutput') {
            speakers.push({
              "name": val.label,
              "id": val.deviceId
            });
            if (val.deviceId == 'default') {
              currentSpeakerID = self.CurrentSpeakerID ? self.CurrentSpeakerID : val.deviceId;
            } else {
              currentSpeakerID = val.deviceId;
            }
          }
          if (val.kind == 'videoinput') {
            cameras.push({
              "name": val.label,
              "id": val.deviceId
            });
            if (!currentCameraID) {
              if (val.deviceId == 'default') {
                currentCameraID = self.CurrentCameraID ? self.CurrentCameraID : val.deviceId;
              } else {
                currentCameraID = val.deviceId;
              }
            }
          }
          if (val.kind == 'audioinput') {
            microphone.push({
              "name": val.label,
              "id": val.deviceId
            });
            if (val.deviceId == 'default') {
              currentMicrophoneID = self.CurrentMicrophoneID ? self.CurrentMicrophoneID : val.deviceId;
            } else {
              currentMicrophoneID = val.deviceId;
            }
          }
        }
        // 扬声器列表;
        _this13.SpeakerList = speakers;
        // 摄像头列表;
        _this13.CameraList = cameras;
        // 麦克风列表;
        _this13.MicrophoneList = microphone;
        _this13.CurrentSpeakerID = currentSpeakerID;
        _this13.CurrentCameraID = currentCameraID;
        _this13.CurrentMicrophoneID = currentMicrophoneID;
        _this13.PreviewingVideo();
      });
    },

    // 会中设备更换重新绑定;
    attachSinkId: function attachSinkId(element, sinkId) {
      element.setSinkId(sinkId).then(function () {
        console.log("Success, audio output device attached: " + sinkId);
      }).catch(function (error) {
        var errorMessage = error;
        if (error.name === "SecurityError") {
          errorMessage = "You need to use HTTPS for selecting audio output device: " + error;
        }
        console.error(errorMessage);
        // Jump back to first output device in the list as it's the default.
      });
    },

    // 保存选择的设备;
    saveSet: function saveSet() {
      // ChangeAudioOutput
      var self = this;
      console.log('===activeName===', this.activeName);
      if (this.activeName == 1) {
        RL_Media.ChangeAudioOutput(self.$refs.audioTar, self.CurrentSpeakerID, function () {
          console.log("修改扬声器设备成功");
          self.$message.success(self.$t('meeting.successSpeakerDevice'));
        }, function () {
          console.log("修改扬声器设备失败");
        });
        this.changeAudioDestination();

        RL_Media.ChangeAudioInput(self.CurrentMicrophoneID, function () {
          console.log("修改麦克风设备成功");
          self.$message.success(self.$t('meeting.successMicrophoneDevice'));
        }, function () {
          console.log("修改麦克风设备失败");
        });
      } else {
        RL_Media.changeVideoInput(self.CurrentCameraID, function (e) {
          self.$message.success(self.$t('meeting.successCameraCevice'));
          console.log("修改摄像头设备成功", e);
          self.SaveStreamList[self.SelfMeetUserId] = e;
          self.$store.commit('SET_StreamObj', self.SaveStreamList);
          self.$refs["selfVideo"].srcObject = e;
        }, function () {
          console.log("修改摄像头设备失败");
        });
      }

      self.setVideoDialog = false;
    },

    // 切换扬声器;
    changeAudioDestination: function changeAudioDestination() {
      this.attachSinkId(this.$refs.audioTar, this.CurrentSpeakerID);
    },
    setvidedoialog: function setvidedoialog() {
      this.setVideoDialog = true;
      this.oldId = {
        CurrentMicrophoneID: this.CurrentMicrophoneID,
        CurrentSpeakerID: this.CurrentSpeakerID,
        CurrentCameraID: this.CurrentCameraID
      };
      this.getMediaDeviceList();
    },
    closePop: function closePop() {
      this.$bus.emit('addPerson', false);
    },
    toggleFullScreen: function toggleFullScreen() {
      //全屏
      //

      // var el = document.getElementById("meeting") || e.target; //target兼容Firefox
      var isFullscreen = document.fullScreen || document.mozFullScreen || document.webkitIsFullScreen;
      if (!isFullscreen) {
        this.isFullScreenStatus = true;
        //进入全屏,多重短路表达式
        var el = document.documentElement;
        var rfs = el.requestFullScreen || el.webkitRequestFullScreen || el.mozRequestFullScreen || el.msRequestFullscreen;
        if (typeof rfs != "undefined" && rfs) {
          rfs.call(el);
        }
        return;
      } else {
        this.isFullScreenStatus = false;
        //退出全屏,三目运算符
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.mozCancelFullScreen) {
          document.mozCancelFullScreen();
        } else if (document.webkitCancelFullScreen) {
          document.webkitCancelFullScreen();
        } else if (document.msExitFullscreen) {
          document.msExitFullscreen();
        }
      }
    },
    SelfCloseScreenShare: function SelfCloseScreenShare() {
      var self = this;
      this.$message.error(this.$t('meeting.clickStopSharing'));
      return;
    },

    //桌面共享处理
    screenShare: function screenShare() {
      if (this.isScreenlockMeet && !this.isHost) {
        this.$message.error(this.$t('meeting.openTheSharingLock'));
        return;
      }
      if (this.IsShareIng || this.miniBoard) {
        return this.$message.error(this.$t('meeting.sharing'));
      }
      var self = this;
      if (!navigator.mediaDevices.getDisplayMedia) {
        self.screenShareIsShow = false;
        self.$message.error(this.$t('meeting.noPluginIsConfigured'));
      } else {
        // var screenShareNew = new  RL_Media.ScreenShareBuilder();
        // screenShareNew.setMediaInfo({
        //   confId: self.roomId,
        //   resolution: "5",
        //   mediaType: "2"
        // });
        // screenShareNew.setCallId(RL_MEET.callId);
        // screenShareNew.setCalled(self.confId);
        RL_Media.startScreenShare(function () {
          console.log("screen share success");
          // if (e.stream) {
          //   self.screenStream = e.stream;
          //   self.$set(self.$refs["oneMainScreen"], "srcObject", e.stream);
          //   self.$set(self.$refs["moreMainScreen"], "srcObject", e.stream);
          //     self.$message.success(self.memberInObj[self.SelfMeetUserId].userName + "已经开始桌面共享");
          //     self.screenShareIsMSG = self.memberInObj[self.SelfMeetUserId].userName + "的屏幕共享";
          //     self.IsShareIng = true;
          //     self.screenUserId = self.SelfMeetUserId;
          // }
          self.shareType = 1;
          self.screenShareIsShow = true;
        }, function (err) {
          console.log(err, "screenShareNew error ");
        });
      }
    },


    // 收到屏幕共享通知，请求屏幕共享流;
    sreenShareNotify: function sreenShareNotify(tar) {

      if (tar.ssSource && tar.ssSsrc && tar.ssCodec) {
        var _this = this;
        var ssrc = tar.ssSsrc | 0x20; //屏幕共享
        _this.antiSsrc = ssrc;
        //request screen share
        if (tar.memberId == this.SelfMeetUserId) {
          return;
        }
        var requestVideo = {
          confId: _this.roomId,
          antiSsrc: ssrc.toString(),
          resolution: "5",
          mediaType: "2",
          antiEncodeType: tar.ssCodec,
          callId: RL_MEET.callId,
          called: _this.confId,
          userName: tar.userName || tar.memberId,
          memberId: tar.memberId
        };
        console.log('===开始拉取共享流===', tar);
        RL_Media.subscribeMedia(requestVideo, function (e) {
          console.log(e, " req screen share success");
        }, function (err) {
          console.log(err, "reqMeetingMemberVideo error ");
        });
      }
    },


    // cancelType 1为取消视频流; 2为取消共享流;
    // isSubScreen 取消视频/屏幕共享订阅为1; 发起方结束屏幕共享订阅为0;
    // memberId 当有人离开会议时,取消视频视频订阅;
    cancelReqVideo: function cancelReqVideo(cancelType, isSubScreen, memberId, callback) {
      var _this14 = this;

      // 调用cancelReqVideo;
      var _this = this;
      var antissrc = void 0;
      console.log('===取消订阅===', 'cancelType:' + cancelType + '，memberId:' + memberId + '，userName：' + _this.memberInObj[memberId].userName);
      if (cancelType == 1) {
        antissrc = _this.memberInObj[memberId].videoSsrc;
      } else {
        antissrc = _this.memberInObj[memberId].videoSsrc || _this.memberInObj[memberId].ssSsrc;
      }
      var cancelVideoBuilder = new RL_Media.cancelVideoBuilder();
      cancelVideoBuilder.setMediaInfo({
        confId: _this.roomId,
        antissrc: antissrc,
        mediaType: cancelType.toString(),
        otherCancelScreen: isSubScreen
      });
      cancelVideoBuilder.setCallId(RL_MEET.callId);
      cancelVideoBuilder.setCalled(_this.roomId);
      cancelVideoBuilder.setUserName(_this.memberInObj[memberId].userName || memberId);
      cancelVideoBuilder.setMemberId(memberId);
      if (_this.SaveStreamList[memberId] && cancelType == 1) {
        delete _this.SaveStreamList[memberId];
        _this.$store.commit('SET_StreamObj', _this.SaveStreamList);
        console.log('SaveStreamList===delete');
      }
      RL_Media.cancelVideo(cancelVideoBuilder, function (e) {
        console.log(e, "cancelVideo success");
        if (cancelType == 2) {
          if (_this.PlayUserList[0].includes('=screenShare')) {
            _this.updateScreenMembers(_this.PlayUserList[0]);
          }
          _this.screenUserId = "";
          _this.screenShareIsShow = "";
          _this.$message.success(_this14.$t('meeting.screenSharingBeenClose'));
          _this.IsShareIng = false;
        } else {
          // console.log('_this.SaveStreamList[memberId]',_this.SaveStreamList[memberId])
          // if (_this.SaveStreamList[e.userId] && cancelType == 1) {
          //     delete _this.SaveStreamList[e.userId];
          //     _this.$store.commit('SET_StreamObj', _this.SaveStreamList);
          //     console.log('SaveStreamList===delete')
          // }
        }
        callback && callback();
      }, function (err) {
        console.log(err, "cancelVideo error ");
      });
    },
    getStreamListener: function getStreamListener(e) {
      console.log("===getStreamListener===", e);
      var self = this;
      if (e.stream) {
        if (e.userId) {
          if (e.mediaType == 1) {
            self.SaveStreamList[e.userId] = e.stream;
            console.log(self.SaveStreamList, "===========拉流成功======" + e.userId);
            self.$store.commit('SET_StreamObj', self.SaveStreamList);
          } else if (e.mediaType == 2) {
            console.log("screen share success");
            this.screenStream = e.stream;
            this.$set(this.$refs["oneMainScreen"], "srcObject", e.stream);
            this.$set(this.$refs["moreMainScreen"], "srcObject", e.stream);
            console.log(this.$refs["moreMainScreen"].srcObject);
            var PlayUserList = JSON.parse(stringify_default()(this.PlayUserList));
            PlayUserList.unshift(e.userId + '=screenShare');
            if (PlayUserList.length > 4) {
              PlayUserList.splice(PlayUserList.length - 1);
            }
            this.PlayUserList = PlayUserList;
            this.IsShareIng = true;
            this.shareType = 1;
            this.$message.success(this.memberInObj[e.userId].userName + this.$t('meeting.screenSharingVeenStart'));
            this.screenShareIsMSG = this.memberInObj[e.userId].userName + this.$t('meeting.screenSharing');
            this.screenUserId = e.userId;
          }
        } else {
          this.$refs.audioTar.srcObject = e.stream;
        }
      }
    },


    // 拉流方法
    pullStream: function pullStream(item) {
      if (!this.PlayUserList.includes(item.memberId)) return;
      var self = this;
      console.log('=====开始拉流=====' + item.memberId, item);

      var requestVideo = {
        confId: this.roomId,
        antiSsrc: item.videoSsrc,
        resolution: "5",
        mediaType: "1",
        antiEncodeType: item.videoCodec,
        callId: RL_MEET.callId,
        called: this.roomId,
        userName: item.userName || item.memberId,
        memberId: item.memberId
      };
      console.log('requestVideo', requestVideo);
      self.SaveStreamList[item.memberId] = {};
      RL_Media.subscribeMedia(requestVideo, function (e) {
        console.log('请求成员视频流成功');
      }, function (err) {
        console.log(err, "requestVideo error ", err);
        delete self.SaveStreamList[item.memberId];
      });
    },
    systemMsgPush: function systemMsgPush(msg, needNotify) {
      if (needNotify) {
        this.$notify({
          message: msg,
          position: "bottom-left",
          duration: 3000,
          type: "warning",
          showClose: false,
          customClass: "bottom-leftNotify"
          // offset: 80
        });
      }
      if (!!this.isNewMeetingChat) {
        var timeDifference = this.user_info && this.user_info.timeDifference && parseInt(this.user_info.timeDifference) || 0;
        this.$bus.emit('dealMessagesChat', {
          msgType: 1,
          msgSender: 'systemNotify',
          msgReceiver: this.GroupId,
          msgId: new Date().getTime() - timeDifference,
          msgContent: msg
        });
      } else {
        this.MSGList.push({
          msg: msg,
          msgType: 1,
          userid: '系统通知'
        });
      }
    },

    //获取会议信息
    getMeetInfo: function getMeetInfo(callback) {
      var GetMeetInfoBuilder = new RL_MEET.GetMeetInfoBuilder();
      var self = this;

      GetMeetInfoBuilder.setConfId(self.roomId);
      RL_MEET.GetMeetInfo(GetMeetInfoBuilder, function (e) {
        callback(JSON.parse(e.result));
      });
    },

    //成员加入或退出时，更新memberInArray
    updateMemberInArray: function updateMemberInArray(type, memberId) {
      // type: add   delete
      var self = this;
      var index = void 0;
      if (type === 'add') {
        if (!self.memberInArrary.includes(memberId)) {
          console.log('memberInArrary push', memberId);
          if (self.memberInArrary[0] === self.SelfMeetUserId) {
            self.memberInArrary.unshift(memberId);
          } else {
            self.memberInArrary.push(memberId);
          }
        }
      } else {
        //删除数组
        index = self.memberInArrary.indexOf(memberId);
        if (memberId === self.memberInArrary[0] && self.memberInArrary.length > 2) {
          self.memberInArrary.unshift(self.memberInArrary.splice(2, 1)[0]);
        }
        console.log('memberInArrary delete', memberId, index);
        if (index > -1) self.memberInArrary.splice(self.memberInArrary.indexOf(memberId), 1);
      }
      return index;
      console.log('===memberInArrary===', stringify_default()(self.memberInArrary));
    },

    //更新屏幕参会成员
    updateScreenMembers: function updateScreenMembers(memberId, memberIndex) {
      var _this15 = this;

      //删除掉被删除的成员后面的所有人，再重新从memberInArrary里取
      console.log('===memberInArrary===', stringify_default()(this.memberInArrary));
      var PlayUserList = JSON.parse(stringify_default()(this.PlayUserList));
      console.log('===PlayUserList===', stringify_default()(PlayUserList));
      var playIndex = PlayUserList.indexOf(memberId);
      if (memberId.indexOf('=screenShare') > -1) {
        if (this.IsMainHall) {
          memberIndex = this.memberInArrary.indexOf(PlayUserList[2]);
          PlayUserList.shift();
          playIndex = 1;
        } else {
          memberIndex = this.memberInArrary.indexOf(PlayUserList[1]);
          console.log('===memberIndex===', memberIndex);
        }
      }
      var sliceIndex = memberIndex + 4 - playIndex;
      if (this.memberInArrary.length < 5) {
        //会中成员小于5个时直接取所有的成员
        playIndex = 0;
        memberIndex = 0;
        sliceIndex = this.memberInArrary.length;
        if (this.IsShareIng && this.shareType === 1 && memberId !== this.screenUserId && !memberId.includes('=screenShare')) {
          playIndex = 1;
          if (this.memberInArrary.length === 4) {
            sliceIndex--;
          }
        }
      } else {
        //当计算出来的sliceIndex大于memberInArrary的最后一位时，直接取最后几个
        if (sliceIndex > this.memberInArrary.length - 1) {
          sliceIndex = this.memberInArrary.length;
          memberIndex = sliceIndex - (4 - playIndex) > -1 ? sliceIndex - (4 - playIndex) : 0;
          if (memberIndex === 0) {
            playIndex = 0;
          }
        }
      }
      if (this.IsShareIng && this.shareType === 1 && memberId === this.screenUserId) {
        this.IsShareIng = false;
        PlayUserList.shift();
        if (playIndex > 0) {
          playIndex--;
          sliceIndex++;
        }
      }
      PlayUserList.splice(playIndex);
      console.log('===index===', playIndex, memberIndex, sliceIndex);
      PlayUserList = PlayUserList.concat(this.memberInArrary.slice(memberIndex, sliceIndex));
      this.PlayUserList = PlayUserList;
      //渲染视频流
      console.log('===成员退出渲染视频流===', PlayUserList);
      setTimeout(function () {
        delete _this15.MerberiList[memberId];
        _this15.$store.commit('SET_MemberInObj', _this15.MerberiList);
      }, 100);
      this.changeScreenMember();
    },

    //更新摄像头、麦克风状态
    updateMemberMediaStatus: function updateMemberMediaStatus(members, key, status) {
      var _this16 = this;

      var self = this;
      //媒体链接完成之后再进行媒体操作
      if (!this.isMediaConnect) return;
      members.forEach(function (item) {
        console.log('item=====', item);
        if (key === 'isOpenVideo') {
          if (item.state & 0x000004) {
            status = true;
          } else {
            status = false;
          }
        } else {
          if (item.state & 0x000040) {
            status = true;
          } else {
            status = false;
          }
        }
        if (!self.memberInObj[item.memberId]) {
          var memberOut = self.memberOutObj;
          if (memberOut[item.memberId]) {
            self.MerberiList[item.memberId] = extends_default()({}, memberOut[item.memberId], item, defineProperty_default()({}, key, status));
            self.$store.commit('SET_MemberInObj', self.MerberiList);
          } else {
            self.MerberiList[item.memberId] = item;
          }
          console.log('self.MerberiList====', self.MerberiList);
          delete memberOut[item.memberId];
          self.$store.commit('SET_MemberOutObj', memberOut);
        } else {
          self.MerberiList[item.memberId] = extends_default()({}, self.MerberiList[item.memberId], item, defineProperty_default()({}, key, status));
          self.$store.commit('SET_MemberInObj', self.MerberiList);
          console.log('self.MerberiList==== true', self.MerberiList);
        }
        //判断一下共享状态，若当前屏幕共享者的状态为0，则不显示屏幕共享
        if (_this16.shareType === 1 && _this16.IsShareIng && item.memberId === _this16.screenUserId && (item.state & 0x000008) === 0) {
          if (_this16.PlayUserList[0].includes('=screenShare')) {
            _this16.updateScreenMembers(_this16.PlayUserList[0]);
          }
          _this16.screenUserId = "";
          _this16.screenShareIsShow = "";
          _this16.IsShareIng = false;
        }
        if (!self.PlayUserList.includes(item.memberId) && self.PlayUserList.length < 4) {
          if (self.PlayUserList[0] === self.SelfMeetUserId) {
            self.PlayUserList.unshift(item.memberId);
          } else {
            self.PlayUserList.push(item.memberId);
          }
        }
        //  对其他参会人进行拉流操作
        if (key === 'isOpenVideo' && status && item.memberId !== self.SelfMeetUserId) {
          if (!self.SaveStreamList[item.memberId]) {
            console.log('===摄像头打开，拉取视频流===', self.MerberiList[item.memberId]);
            self.pullStream(self.MerberiList[item.memberId]);
          } else {
            //若异常退会，又重新入会需要重新拉取视频流
            console.log('===重新拉取视频流===', self.MerberiList[item.memberId]);
            self.cancelReqVideo(1, 1, item.memberId, function () {
              self.pullStream(self.MerberiList[item.memberId]);
            });
          }
        }
        //更新全员静音和全员关闭摄像头状态
        if (status && item.memberId !== self.SelfMeetUserId) {
          self.bus.$emit('updateMediaStatus', key);
        }
        self.updateMemberInArray('add', item.memberId);
      });
    },

    //成员变更
    memberListChange: function memberListChange(type, obj) {
      var _this17 = this;

      //  1: 成员加入；2：成员退出；3：成员被踢出
      var self = this;
      if (type === 1) {
        obj.members.forEach(function (item) {
          console.debug("YHSKDIM：成员加入", item.userName);
          if (item.memberId !== self.SelfMeetUserId) {
            _this17.updateMemberConfStatus(item);
            if (!obj.inviter) {
              self.systemMsgPush(item.userName + _this17.$t('meeting.joinMeeting'), true);
            }
          }
        });
      } else if (type === 2) {
        console.log('YHSKDIM：成员退出');
        if (obj.memberId === self.SelfMeetUserId) {
          self.leaveAllMeet();
          return;
        }
        if (obj.action === NoteTypesAction.KControlMultiMediaRemove) {
          var memberOut = this.memberOutObj;
          if (memberOut[obj.memberId]) delete memberOut[obj.memberId];
          this.$store.commit('SET_MemberOutObj', memberOut);
          return;
        }
        var user = self.MerberiList[obj.memberId] || self.memberOutObj[obj.memberId];
        var memberIndex = self.updateMemberInArray('delete', obj.memberId);
        //当前屏幕中包含该成员时执行取消视频流操作
        if (self.PlayUserList.includes(obj.memberId)) {
          //有成员退出后，由其他参会成员补上
          self.updateScreenMembers(obj.memberId, memberIndex);
          self.systemMsgPush(user.userName + this.$t('meeting.exitMeeting'), true);
        } else if (this.MerberiList[obj.memberId]) {
          delete this.MerberiList[obj.memberId];
          this.$store.commit('SET_MemberInObj', this.MerberiList);
          self.systemMsgPush(user.userName + this.$t('meeting.exitMeeting'), true);
        } else if (this.memberOutObj[obj.memberId]) {
          var memberOutObj = this.memberOutObj;
          delete memberOutObj[obj.memberId];
          this.$store.commit('SET_MemberOutObj', memberOutObj);
        }
      } else if (type === 3) {
        if (!obj.kickedMembers) return;
        for (var i = 0; i < obj.kickedMembers.length; i++) {
          var memberId = obj.kickedMembers[i].memberId;
          if (memberId == self.SelfMeetUserId) {
            self.$message.error(this.$t('meeting.beenRemovedFromMeeting'));
            self.leaveAllMeet(true);
            break;
          } else {
            var name = obj.memberId === self.SelfMeetUserId ? this.$t('meeting.you') : this.$t('meeting.moderator');
            var _user = self.MerberiList[memberId] || self.memberOutObj[memberId];
            self.systemMsgPush(name + this.$t('meeting.haveBeen') + _user.userName + this.$t('meeting.removedFromMeeting'), true);
            var _memberIndex = self.updateMemberInArray('delete', memberId);
            //当前屏幕中包含该成员时执行取消视频流操作
            if (self.PlayUserList.includes(memberId)) {
              self.updateScreenMembers(memberId, _memberIndex);
            } else {
              if (self.MerberiList[memberId]) {
                delete this.MerberiList[memberId];
                this.$store.commit('SET_MemberInObj', this.MerberiList);
              } else if (this.memberOutObj[memberId]) {
                var _memberOutObj = this.memberOutObj;
                delete _memberOutObj[memberId];
                this.$store.commit('SET_MemberOutObj', _memberOutObj);
              }
            }
          }
        }
      }
    },

    //更新成员会议状态
    updateMemberConfStatus: function updateMemberConfStatus(item, isPullStream) {
      var self = this;
      var memberOut = self.memberOutObj;
      if (item.state & 0x000100) {
        //媒体在线
        console.log('------媒体在线------', item);
        if (item.state & 0x000040) {
          // 麦克风打开;
          item.isOpenAudio = true;
        } else {
          item.isOpenAudio = false;
        }
        if (item.state & 0x000004) {
          // 摄像头打开;
          item.isOpenVideo = true;
        } else {
          item.isOpenVideo = false;
        }
        if (memberOut[item.memberId]) {
          self.MerberiList[item.memberId] = extends_default()({}, memberOut[item.memberId], item);
          delete memberOut[item.memberId];
          self.$store.commit('SET_MemberOutObj', memberOut);
        } else {
          self.MerberiList[item.memberId] = extends_default()({}, self.MerberiList[item.memberId], item);
        }
        self.$store.commit('SET_MemberInObj', self.MerberiList);
        if (!self.PlayUserList.includes(item.memberId) && self.PlayUserList.length < 4) {
          if (self.PlayUserList[0] === self.SelfMeetUserId) {
            self.PlayUserList.unshift(item.memberId);
          } else {
            self.PlayUserList.push(item.memberId);
          }
        }
        if (isPullStream) {
          if (item.isOpenVideo) {
            console.log('===入会拉取视频流===', self.MerberiList[item.memberId]);
            self.pullStream(self.MerberiList[item.memberId]);
          }
          if (item.state & 0x000008) {
            console.log('===入会拉取共享流===', 'userId:' + item.memberId + 'userName:' + item.userName);
            self.sreenShareNotify(item);
          }
        }
        self.updateMemberInArray('add', item.memberId);
      } else {
        console.log('------媒体不在线------', item);
        if (item.memberId === self.SelfMeetUserId) {
          console.log('媒体掉线, 退出会议');
          this.$message.error(this.$t('meeting.exitTheMeeting'));
          self.leaveAllMeet(true);
          return;
        }
        //若成员不在线，且有屏幕共享，清空掉该成员的屏幕共享
        if (this.shareType === 1 && this.IsShareIng) {
          if (item.memberId === this.screenUserId) {
            if (this.PlayUserList[0].includes('=screenShare')) {
              this.updateScreenMembers(this.PlayUserList[0]);
            }
            this.screenUserId = "";
            this.screenShareIsShow = "";
            this.IsShareIng = false;
          }
        }
        if (item.state & 0x000200) {
          //用户拒绝邀请
          item.stateContent = this.$t('meeting.refused');
        } else if (item.state & 0x000400) {
          //正在接通
          item.stateContent = this.$t('meeting.connecting');
        } else if (item.state & 0x00040000) {
          //媒体超时
          item.stateContent = this.$t('meeting.mediaTimeOut');
        } else if (item.state & 0x000800) {
          //已挂断
          item.stateContent = this.$t('meeting.hungUp');
        } else if (item.state & 0x00080000) {
          item.stateContent = this.$t('last.inviteTimeout');
        }
        if (self.MerberiList[item.memberId]) {
          item = extends_default()({}, self.MerberiList[item.memberId], item);
          var memberIndex = self.updateMemberInArray('delete', item.memberId);
          if (self.PlayUserList.includes(item.memberId)) {
            self.updateScreenMembers(item.memberId, memberIndex);
          } else {
            delete this.MerberiList[item.memberId];
            this.$store.commit('SET_MemberInObj', this.MerberiList);
          }
        }
        if (memberOut[item.memberId]) item = extends_default()({}, memberOut[item.memberId], item);
        memberOut[item.memberId] = item;
        self.$store.commit('SET_MemberOutObj', memberOut);
      }
      this.GetUserPhoto(item.memberId);

      console.log('memberOut---', memberOut, self.MerberiList);
    },

    //成员信息更新
    memberInfoChange: function memberInfoChange(obj) {
      var self = this;
      if (obj.action === NoteTypesAction['kControlNone']) {
        obj.members.forEach(function (item) {
          if (item.state && item.memberId !== self.SelfMeetUserId) {
            self.updateMemberConfStatus(item);
          } else if (item.memberId === self.SelfMeetUserId && self.MerberiList[self.SelfMeetUserId] && item.roleId !== self.MerberiList[self.SelfMeetUserId].roleId) {
            self.isHost = self.IsHost(item.roleId);
            self.updateMemberConfStatus(item);
          }
        });
      } else if (obj.action == NoteTypesAction["KControlMemberDisconnect"]) {
        self.$message.error(this.$t('meeting.offYourMediaConnection'));
        console.debug("YHSKDIM:主持人已断开你的媒体连接");
        self.leaveAllMeet();
        return;
      } else if (obj.action == NoteTypesAction["kControlForbidShareScreen"]) {
        var item = obj.members[0];
        self.$set(self.MerberiList, item.memberId, extends_default()({}, self.MerberiList[item.memberId], item));
        self.$store.commit('SET_MemberInObj', self.MerberiList);
        if (item.memberId == this.SelfMeetUserId) {
          self.IsShareIng = false;
          self.screenShareIsShow = false;
          return;
        }
        self.cancelReqVideo(2, 0, obj.members[0].memberId);
      } else if (obj.action == NoteTypesAction["kControlAllowSpeak"]) {
        console.debug("YHSKDIM：发布语音");
        self.updateMemberMediaStatus(obj.members, 'isOpenAudio', true);
      } else if (obj.action == NoteTypesAction["kControlForbidSpeak"]) {
        console.debug("YHSKDIM：取消发布语音");
        self.updateMemberMediaStatus(obj.members, 'isOpenAudio', false);
      } else if (obj.action == NoteTypesAction["KControlAcceptPublishVoiceByModerator"]) {
        console.debug("YHSKDIM：主持人同意申请发言");
        obj.members.forEach(function (item) {
          if (item.memberId == self.SelfMeetUserId) {
            self.openMicrophone();
          }
        });
      } else if (obj.action == NoteTypesAction["KControlRejectPublishVoiceByModerator"]) {
        console.debug("YHSKDIM：主持人拒绝申请发言");
        self.$message.info(this.$t('meeting.refusedYourRequestSpeaking'));
      } else if (obj.action == NoteTypesAction["kControlAllowShareScreen"]) {
        console.debug("YHSKDIM：发布桌面共享");
        var _item = obj.members[0];
        self.$set(self.MerberiList, _item.memberId, extends_default()({}, self.MerberiList[_item.memberId], _item));
        self.$store.commit('SET_MemberInObj', self.MerberiList);
        // 如果发起屏幕共享的人是自己则不作处理;
        if (_item.memberId !== this.SelfMeetUserId) {
          this.sreenShareNotify(obj.members[0]);
        }
      } else if (obj.action == NoteTypesAction["KControlAcceptPublishVoiceBySelf"]) {
        console.debug("YHSKDIM：主持人同意点名");
      } else if (obj.action == NoteTypesAction["KControlRejectPublishVoiceBySelf"]) {
        console.debug("YHSKDIM：主持人拒绝点名");
      } else if (obj.action == NoteTypesAction["KControlApplyPublishVoiceBySelf"]) {
        console.debug("YHSKDIM：参会人申请发言");
        obj.members.forEach(function (item) {});
        self.handUser();
      } else if (obj.action == 126 || obj.action == NoteTypesAction["KControlStopPublishVoiceBySelf"]) {
        console.debug("YHSKDIM：参会人取消申请发言");
        obj.members.forEach(function (item) {});
        self.handUser();
      } else if (obj.action == NoteTypesAction["kControlSetRole"]) {
        console.debug("YHSKDIM：权限变更");
        obj.members.forEach(function (item) {
          console.log(item.memberId, self.IsHost(item.roleId));
          if (self.memberInObj[item.memberId]) {
            self.MerberiList[item.memberId].roleId = item.roleId;
            self.$store.commit('SET_MemberInObj', self.MerberiList);
          }
          var state = (self.memberInObj[item.memberId] || self.memberOutObj[item.memberId]).state;
          if (item.state && item.state !== state) self.updateMemberConfStatus(item);
          if (item.memberId == self.SelfMeetUserId) {
            if (self.IsHost(item.roleId)) {
              self.isHost = true;
            } else {
              self.isHost = false;
            }
          }
        });
      } else if (obj.action == NoteTypesAction["kControlAllowShareCamera"]) {
        console.debug("YHSKDIM：发布视频");
        self.updateMemberMediaStatus(obj.members, 'isOpenVideo', true);
      } else if (obj.action == NoteTypesAction["kControlForbidShareCamera"]) {
        console.debug("YHSKDIM：取消发布视频");
        self.updateMemberMediaStatus(obj.members, 'isOpenVideo', false);
      } else if (obj.action == NoteTypesAction["kControlUserInfo"]) {
        console.debug("YHSKDIM：更新成员信息");
        obj.members.forEach(function (item) {
          var state = (self.memberInObj[item.memberId] || self.memberOutObj[item.memberId]).state;
          if (item.state && item.state !== state) self.updateMemberConfStatus(item);
          // self.$set(self.MerberiList, item.memberId, {
          //     ...self.MerberiList[item.memberId],
          //     ...item
          // });
        });
        // self.$store.commit('SET_MemberInObj', self.MerberiList);
      } else if (obj.action == NoteTypesAction["KControlStopPublishVoiceByModerator"]) {
        console.debug("YHSKDIM:主持人 取消发言人权限，即更改发言人角色为 普通成员");
        obj.members.forEach(function (item) {
          self.$set(self.MerberiList[item.memberId], 'state', item.state);
          self.$set(self.MerberiList[item.memberId], 'roleId', item.roleId);
          if (item.memberId == self.SelfMeetUserId) {
            self.closeMicrophone();
            if (self.MerberiList[self.SelfMeetUserId].state & 0x00020000) {
              self.closePlanHand();
            }
          }
          self.$store.commit('SET_MemberInObj', self.MerberiList);
        });
      } else if (obj.action == NoteTypesAction['KControlUserRejectInvitation']) {
        console.debug("YHSKDIM：拒绝会议邀请");
        obj.members.forEach(function (item) {
          self.updateMemberConfStatus(item);
        });
      } else if (obj.action == NoteTypesAction['KControlUserUnDoInvitation']) {
        console.debug("YHSKDIM：会议邀请超时未处理");
        obj.members.forEach(function (item) {
          self.updateMemberConfStatus(item);
        });
      }
      console.log('MerberiList', self.MerberiList);
    },

    //自己的信息变更
    selfInfoChange: function selfInfoChange(obj) {
      var _this18 = this;

      var self = this;
      if (obj.action === NoteTypesAction["kControlForbidListen"]) {
        console.debug("YHSKDIM:禁听");
      } else if (obj.action === NoteTypesAction["kControlAllowSListen"]) {
        console.debug("YHSKDIM:可听");
      } else if (obj.action === NoteTypesAction["kControlForbidSpeak"]) {
        if (!this.isAllmuet) self.systemMsgPush(this.$t('meeting.turnedOffYourMicrophone'));
        self.closeMicrophone();
        if (self.MerberiList[self.SelfMeetUserId].state & 0x00020000) {
          self.closePlanHand();
        }
        console.debug("YHSKDIM:主持人关闭了您的麦克风");
        self.$message.info(this.$t('meeting.turnedOffYourMicrophone'));
      } else if (obj.action === NoteTypesAction["kControlAllowSpeak"]) {
        self.systemMsgPush(this.$t('meeting.turnedOnYourMicrophone'));
        if (self.MerberiList[self.SelfMeetUserId].state & 0x00020000) {
          self.closePlanHand();
        }
        self.openMicrophone();
        self.$message.info(this.$t('meeting.turnedOnYourMicrophone'));
        console.debug("YHSKDIM:主持人开启了您的麦克风");
      } else if (obj.action === NoteTypesAction["kControlForbidWatchCamera"]) {
        console.debug("YHSKDIM:禁看");
      } else if (obj.action === NoteTypesAction["kControlAllowSWatchCamera"]) {
        console.debug("YHSKDIM:可看");
      } else if (obj.action === NoteTypesAction["kControlForbidShareCamera"]) {
        self.closeCameraAndPubVideo();
        self.systemMsgPush(this.$t('meeting.turnedFffYourCamera'));
        self.$message.info(this.$t('meeting.turnedFffYourCamera'));
        console.debug("YHSKDIM:主持人关闭了您的摄像头");
      } else if (obj.action === NoteTypesAction["kControlAllowShareCamera"]) {
        self.$confirm(this.$t('meeting.doYouAgree'), this.$t('btn.determine'), {
          confirmButtonText: this.$t('btn.determine'),
          cancelButtonText: this.$t('btn.cancel'),
          customClass: "confirm",
          roundButton: true,
          center: true
        }).then(function () {
          self.openCamera();
          self.systemMsgPush(_this18.$t('meeting.agreedToTurnOnYourCamera'));
        }).catch(function () {
          self.systemMsgPush(_this18.$t('meeting.refusedTurnOnYourCamera'));
          self.$message.warning(_this18.$t('meeting.refused'));
        });
        console.debug("YHSKDIM:主持人将打开您的摄像头");
      } else if (obj.action == NoteTypesAction["kControlForbidShareScreen"]) {
        console.debug("YHSKDIM:主持人将关闭您的屏幕共享");
        if (obj.members[0].memberId == this.SelfMeetUserId) {
          return;
        }
        self.cancelReqVideo(2, 0, obj.members[0].memberId);
      } else if (obj.action == NoteTypesAction["KControlStopPublishVoiceByModerator"]) {
        console.debug("YHSKDIM:主持人 取消发言人权限，即更改发言人角色为 普通成员");
        self.closeMicrophone();
        if (self.MerberiList[self.SelfMeetUserId].state & 0x00020000) {
          self.closePlanHand();
        }
      }
    },

    //会议信息变更
    meetInfoChange: function meetInfoChange(obj) {
      var self = this;
      var meetInfo = self.meetInfo;
      meetInfo = extends_default()({}, meetInfo, obj);
      if (obj.action == NoteTypesAction["KControlConfMaxMember"]) {
        console.debug("YHSKDIM:最大人数变更");
      } else if (obj.action == NoteTypesAction["KControlConfLockUnlock"]) {
        console.debug("YHSKDIM:会议锁状态变更");
        if (self.SelfMeetUserId == obj.memberId) {
          self.$store.commit('SET_MeetInfo', meetInfo);
          return;
        }
        console.log(self.SelfMeetUserId, obj.memberId);
        if (self.isScreenlockMeet && (obj.state & 0x0004) == 0) {
          self.$message({
            message: this.$t('meeting.closeTheSharingLock'),
            type: "warning"
          });
          self.systemMsgPush(this.$t('meeting.closeTheSharingLock'));
          self.isScreenlockMeet = false;
        }
        if (!self.isScreenlockMeet && obj.state & 0x0004) {
          self.isScreenlockMeet = true;
          self.$message({
            message: this.$t('meeting.openTheSharingLock'),
            type: "warning"
          });
          self.systemMsgPush(this.$t('meeting.openTheSharingLock'));
        }
        if (self.isLockMeet && (obj.state & 0x0002) == 0) {
          self.$message({
            message: this.$t('meeting.closeTheMeetingLock'),
            type: "warning"
          });
          self.systemMsgPush(this.$t('meeting.closeTheMeetingLock'));
          self.isLockMeet = false;
        }
        if (!self.isLockMeet && obj.state & 0x0002) {
          self.isLockMeet = true;
          self.$message({
            message: this.$t('meeting.openTheMeetingLock'),
            type: "warning"
          });
          self.systemMsgPush(this.$t('meeting.openTheMeetingLock'));
        }
        var userName = self.MerberiList[obj.memberId].userName;
        // 白板标注加锁
        if (obj.state === 25) {
          if (!self.isWhiteBoarOrganiser) {
            self.whiteBoardControllerDisabled = true;
            // 禁用画笔
            self.$refs.WhiteBoard.isMouseEventEnable(false);
          }
          self.$message({
            message: userName + this.$t('meeting.openWhiteboardAnnotaLock'),
            type: "warning"
          });
          self.systemMsgPush(userName + this.$t('meeting.openWhiteboardAnnotaLock'));
        } else if (obj.state === 17) {
          if (!self.isWhiteBoarOrganiser) {
            self.whiteBoardControllerDisabled = false;
            // 启用画笔
            self.$refs.WhiteBoard.isMouseEventEnable(true);
          }
          self.$message({
            message: userName + this.$t('meeting.closeWhiteboardAnnotaLock'),
            type: "warning"
          });
          self.systemMsgPush(userName + this.$t('meeting.closeWhiteboardAnnotaLock'));
        }
      } else if (obj.action == NoteTypesAction["KControlConfInfo"]) {
        console.debug("YHSKDIM:会议信息变更");
      } else if (obj.action == NoteTypesAction["KControlConfTopic"]) {
        console.debug("YHSKDIM:更新会议议题");
      } else if (obj.action == NoteTypesAction["kControlForbidSpeak"]) {
        self.isAllmuet = true;
        self.systemMsgPush(this.$t('meeting.moderatorTurnedOnMuteAll'));
        console.debug("YHSKDIM:主持人开启了全体静音");
      } else if (obj.action == NoteTypesAction["kControlAllowSpeak"]) {
        self.systemMsgPush(this.$t('meeting.moderatorUnlockedMuteAll'));
        self.isAllmuet = false;
        console.debug("YHSKDIM:主持人解除了全体静音");
      } else if (obj.action == NoteTypesAction["KControlConfFileChanged"]) {
        console.debug("YHSKDIM:更新会议资料");
      } else if (obj.action == NoteTypesAction["KControlConfEndTime"]) {
        console.debug("YHSKDIM:会议时长变更");
        this.prolongDialogVisible = false;
      } else if (obj.action == NoteTypesAction["kControlAllowShareWhiteboard"]) {
        var wbInfo = JSON.parse(obj.wbInfo);
        if (wbInfo.userid !== self.SelfMeetUserId && !this.isShow) {
          self.whiteBoardRoomId = wbInfo.roomId;
          self.joinWhiteBoardRoom(Number(wbInfo.roomId), wbInfo.userid);
        }
        if (this.isShow) {
          self.whiteBoardRoomId = wbInfo.roomId;
          self.whiteBoardUserId = wbInfo.userid;
          this.shareType = 2;
          this.IsShareIng = true;
        }
      } else if (obj.action == NoteTypesAction["kControlForbidShareWhiteboard"]) {
        if (obj.memberId && self.SelfMeetUserId !== obj.memberId) {
          self.$message({
            message: self.memberInObj[obj.memberId].userName + this.$t('meeting.closeTheWhiteboardShar'),
            type: "warning"
          });
          if (self.shareType === 2 && self.IsShareIng) {
            if (self.isShow) {
              self.whiteBoardRoomId = '';
              self.whiteBoardUserId = '';
              this.shareType = 0;
              this.IsShareIng = false;
            } else {
              try {
                YTX_WBSS_API.clearCurrentPage();
              } catch (error) {} finally {
                self.leaveWbRoom();
              }
            }
          }
          this.miniBoard = false;
        }
      } else if (obj.action == NoteTypesAction["KControlConfSetMainHall"]) {
        if (obj.mainVenue) {
          self.$message({
            message: this.$t('meeting.setTheMainVenue'),
            type: "warning"
          });
        }
        this.mainVenue = obj.mainVenue;
        this.IsMainHall = Boolean(obj.mainVenue);
        self.$store.commit('SET_MainVenue', obj.mainVenue);
        console.log('===收到主会场通知===', self.SelfMeetUserId, obj.mainVenue);
        if (obj.mainVenue && obj.mainVenue !== self.SelfMeetUserId) {
          console.log('===设置主会场===', obj.mainVenue);
          self.changeScreenMember('setFirstMember', [obj.mainVenue]);
        }
      }
      self.$store.commit('SET_MeetInfo', meetInfo);
    },
    nextScreen: function nextScreen(roundTour) {
      var _this19 = this;

      var imgUserList = [],
          noImgUserList = [];
      //有主会场时
      var memberInArrary = JSON.parse(stringify_default()(this.memberInArrary));
      console.log('memberInArrary====', memberInArrary);
      var PlayUserList = JSON.parse(stringify_default()(this.PlayUserList));
      var num = 3;
      if (this.IsMainHall && this.IsShareIng && this.shareType == 1) {
        num = 2;
      }
      // 设置跳过无图像用户
      if (!!roundTour && !!roundTour.skipNoImgeUser) {
        // 获取有图像的用户
        imgUserList = this.memberInArrary.filter(function (item) {
          return _this19.memberInObj[item] && _this19.memberInObj[item].isOpenVideo;
        });
        if (imgUserList.length < num) {
          noImgUserList = this.memberInArrary.filter(function (item) {
            return _this19.memberInObj[item] && !_this19.memberInObj[item].isOpenVideo;
          });
          memberInArrary = imgUserList.concat(noImgUserList.slice(0, num - imgUserList.length));
        }
      }
      var last = PlayUserList[PlayUserList.length - 1];
      // 屏幕上最后一个在列表中的位置
      var index = memberInArrary.indexOf(last);
      console.log('===memberInArrary===', memberInArrary);
      console.log(last, index);
      var lastMemberIndex = memberInArrary.length - 1;
      var getArr = void 0;
      if (memberInArrary.length - 1 - index < num) {
        //循环到尾了
        if (!!roundTour && !!roundTour.state) {
          // 后面人员不足num时，从前面开始取不足num的部分
          getArr = memberInArrary.slice(index + 1, memberInArrary.length);
          if (getArr.length != num) {
            getArr = getArr.concat(memberInArrary.slice(0, num - getArr.length));
          }
        } else {
          getArr = memberInArrary.slice(memberInArrary.length - num, memberInArrary.length);
        }
      } else {
        getArr = memberInArrary.slice(index + 1, index + 1 + num);
      }
      console.log('===getArr===', stringify_default()(getArr));
      var judge = function judge() {
        if (getArr.length === 1) {
          _this19.$message.info(_this19.$t('meeting.lastPage'));
          return false;
        } else {
          //判断后面是否还有成员可以取
          var firstIndex = memberInArrary.indexOf(getArr[0]);
          var lastIndex = memberInArrary.indexOf(getArr[getArr.length - 1]);
          if (lastIndex !== memberInArrary.length - 1) {
            getArr.push(memberInArrary[lastIndex + 1]);
          } else {
            if (!!roundTour && !!roundTour.state) {
              //从前面取一个
              if (!!roundTour.skipNoImgeUser && noImgUserList.length > 0) {
                // 从无图像列表中取
                getArr.push(noImgUserList[lastIndex + 1]);
              } else {
                getArr.push(memberInArrary[0]);
              }
            } else {
              getArr.unshift(memberInArrary[firstIndex - 1]);
            }
          }
          getArr.splice(getArr.indexOf(PlayUserList[0]), 1);
          num = getArr.length;
          return true;
        }
      };
      //判断所取成员中是否有发言人、主会场或屏幕共享
      if (getArr.includes(PlayUserList[0])) {
        if (!judge()) return;
      }
      if (getArr.includes(PlayUserList[1]) && num === 2) {
        if (!judge()) return;
      }

      console.log('num++++++', num);
      PlayUserList.splice(4 - num, num);
      PlayUserList = PlayUserList.concat(getArr);
      this.PlayUserList = PlayUserList;
      console.log('===this.PlayUserList===', stringify_default()(PlayUserList));
    },
    preScreen: function preScreen() {
      var _this20 = this;

      var PlayUserList = JSON.parse(stringify_default()(this.PlayUserList));
      var num = 3;
      if (this.IsMainHall && this.IsShareIng && this.shareType == 1) {
        num = 2;
      }
      var last = PlayUserList[4 - num];
      var index = this.memberInArrary.indexOf(last);
      var max = 0;
      PlayUserList.forEach(function (item) {
        if (_this20.memberInArrary.indexOf(item) > max) max = _this20.memberInArrary.indexOf(item);
      });
      //当最小的位置为0，或者最小位置为1，第0个为PlayUserList[0]
      if (index === 0 || index === 1 && this.memberInArrary.indexOf(PlayUserList[0]) === 0 || num === 2 && index === 1 && this.memberInArrary.indexOf(PlayUserList[1]) === 0) {
        this.$message.info(this.$t('meeting.firstPage'));
        return;
      }
      console.log('===this.memberInArrary===', this.memberInArrary);
      console.log(last, index);
      var getArr = void 0;
      if (index < num) {
        getArr = this.memberInArrary.slice(0, num);
      } else {
        getArr = this.memberInArrary.slice(index - num, index);
      }
      if ((getArr.includes(PlayUserList[0]) && getArr.length === 1 && num === 3 || num === 2 && getArr.includes(PlayUserList[0]) && getArr.includes(PlayUserList[1]) && getArr.length === 2) && max > num) {
        //当取到的数组无成员，且最大位置大于所取数量时，以最大的下标为准，往前取
        last = PlayUserList[3];
        index = this.memberInArrary.indexOf(last);
        getArr = this.memberInArrary.slice(index - num, index);
      }
      var judge = function judge() {
        var firstIndex = _this20.memberInArrary.indexOf(getArr[0]);
        var lastIndex = _this20.memberInArrary.indexOf(getArr[getArr.length - 1]);
        if (firstIndex !== 0) {
          getArr.unshift(_this20.memberInArrary[firstIndex - 1]);
        } else {
          getArr.push(_this20.memberInArrary[lastIndex + 1]);
        }
        getArr.splice(getArr.indexOf(PlayUserList[0]), 1);
      };
      //判断所取成员中是否有发言人、主会场或屏幕共享
      if (getArr.includes(PlayUserList[0])) {
        judge();
      }
      if (getArr.includes(PlayUserList[1]) && num === 2) {
        judge();
      }
      console.log("===getArr===", getArr);
      PlayUserList.splice(4 - num, num);
      PlayUserList = PlayUserList.concat(getArr);
      this.PlayUserList = PlayUserList;
      console.log('===this.PlayUserList===', stringify_default()(PlayUserList));
    },

    /**
     * changeType：'setFirstMember':设置主会场，发言人; 'pre':前一页切换，'next':后一页切换;
     * members: 要设置为屏幕第一个的成员
     */
    changeScreenMember: function changeScreenMember(changeType, members) {
      var self = this;
      if (changeType == 'pre') {
        this.preScreen();
      } else if (changeType == 'next') {
        this.nextScreen();
      } else if (changeType == 'setFirstMember') {
        //修改PlayUserList数据
        var voiceMax = members[0];
        var PlayUserList = JSON.parse(stringify_default()(this.PlayUserList));
        var currentProfileIndex = null;
        if (PlayUserList.includes(voiceMax)) {
          currentProfileIndex = PlayUserList.findIndex(function (user) {
            return user === voiceMax;
          });
          PlayUserList.splice(currentProfileIndex, 1);
        } else {
          //当前视频显示界面中无发言人视频流时，需要删掉最后一个人
          // self.cancelReqVideo(1, 1, self.PlayUserList[self.PlayUserList.length-1]);
          PlayUserList.splice(PlayUserList.length - 1, 1);
        }
        var memberInArrary = JSON.parse(stringify_default()(this.memberInArrary));
        var newArr = [voiceMax, this.SelfMeetUserId];
        memberInArrary.splice(memberInArrary.indexOf(voiceMax), 1);
        memberInArrary.splice(memberInArrary.indexOf(this.SelfMeetUserId), 1);
        this.memberInArrary = newArr.concat(memberInArrary);
        console.log('===memberInArrary===', this.memberInArrary);
        if (currentProfileIndex === 0) {
          PlayUserList.unshift(voiceMax);
        } else {
          if (PlayUserList.includes(this.SelfMeetUserId)) {
            if (this.IsShareIng && this.shareType === 1) {
              newArr = [PlayUserList[0], voiceMax, this.SelfMeetUserId];
              PlayUserList.splice(0, 1);
              PlayUserList.splice(PlayUserList.indexOf(this.SelfMeetUserId), 1);
              PlayUserList = newArr.concat(PlayUserList);
            } else {
              PlayUserList.unshift(PlayUserList.splice(1, 1)[0]);
              PlayUserList.unshift(voiceMax);
            }
          } else {
            PlayUserList.unshift(voiceMax);
            if (this.IsShareIng && this.shareType == 1) {
              PlayUserList.unshift(PlayUserList.splice(1, 1));
            }
          }
        }
        this.PlayUserList = PlayUserList;
      }
      //根据当前屏幕成员进行视频流渲染
      console.log('===PlayUserList===', stringify_default()(self.PlayUserList));
      console.log('saveStreamList', self.SaveStreamList);
      self.PlayUserList.forEach(function (item, index) {
        console.log('change video', item, index);
        if (!self.SaveStreamList[item] && self.memberInObj[item]) {
          //缓存stream区无该视频流时，拉取该成员视频流
          var tar = self.memberInObj[item];
          if (tar.isOpenVideo) {
            console.log('拉取当前屏幕成员视频流', tar);
            self.pullStream(tar);
          }
        }
      });
    },
    ConferenceNotify: function ConferenceNotify(obj) {
      //通知
      console.debug("YHSKD：", stringify_default()(obj));
      var self = this;
      if (obj.msgContent) {
        obj = JSON.parse(obj.msgContent);
      }
      console.log("ConferenceNotify---", obj);
      if (obj.confId && this.roomId !== obj.confId) return;
      if (obj.noteType === NoteTypes["KNoteDeleteConf"]) {
        self.$message({
          message: this.$t('meeting.meetingIsClose'),
          type: "error"
        });
        console.debug("YHSKDIM：会议已关闭");
        self.leaveAllMeet();
      } else if (obj.noteType === NoteTypes["KNoteMemberJoin"]) {
        self.memberListChange(1, obj);
      } else if (obj.noteType === NoteTypes["KNoteMemberQuit"]) {
        self.memberListChange(2, obj);
      } else if (obj.noteType === NoteTypes["KNoteKickMember"]) {
        self.memberListChange(3, obj);
      } else if (obj.noteType === NoteTypes["KNoteUpdateMemberInfo"]) {
        self.memberInfoChange(obj);
      } else if (obj.noteType === NoteTypes["KNoteInviteMember"]) {
        console.log('收到会议邀请');
        // self.memberInfoChange(obj);
      } else if (obj.noteType === NoteTypes["KNoteInviteResult"]) {
        self.memberInfoChange(obj);
      } else if (obj.noteType == NoteTypes["KNoteMediaControl"]) {
        self.selfInfoChange(obj);
      } else if (obj.noteType == NoteTypes["KNoteUpdateConf"]) {
        self.meetInfoChange(obj);
      } else if (obj.noteType == NoteTypes["KNoteInviteResult"]) {} else if (obj.noteType == NoteTypes["KNoteReserveRemindBeforeEnd"]) {
        console.debug("YHSKDIM:会议结束前的通知");
        self.nextEndTime = obj.nextEndTime;
        if (self.isHost) {
          self.prolongDialogVisible = true;
          if (window.Notification) {
            var notification = new Notification(this.$t('meeting.haveNewMessage'), {
              body: this.$t('meeting.meetingIsGoingToEnd')
            });
            setTimeout(function () {
              notification.close();
            }, 5000);
          }
          setTimeout(function () {
            self.prolongDialogVisible = false;
            console.log('15s关闭弹框');
          }, 15000);
        }
      } else if (obj.noteType == NoteTypes["KNoteUpdateImpelMember"]) {
        console.log('语音激励通知');
        // 语音激励成员通知;
        var voiceMax = obj.members[0].memberId;
        self.voiceIncentiveId = voiceMax;
        if (voiceMax == self.SelfMeetUserId || !self.memberInObj[voiceMax]) {
          return;
        } else {
          //没有主会场或屏幕共享时语音激励才生效
          if (!(this.IsMainHall || this.IsShareIng && this.shareType === 1)) {
            self.changeScreenMember('setFirstMember', [voiceMax]);
          }
        }
      } else if (obj.noteType == NoteTypes["KNoteConfEndTime"]) {
        console.log('会议倒计时通知');
        this.$refs.meetHeader.showTimerTips();
      }
    },
    closeDialog: function closeDialog(el) {
      if (el == "meetInfoDialog") {
        this.meetInfoDialog = false;
      }
      if (el == "prolongDialogVisible") {
        this.prolongDialogVisible = false;
      }
      if (el == "meetShare") {
        this.meetShareDialog = false;
      }
      if (el == "merberDialog") {
        this.merberDialog = false;
      }
      if (el == "chatDialog") {
        this.chatDialog = false;
      }
      if (el == "setMainHallDialog") {
        this.setMainHallDialog = false;
      }
      if (el == "setRoundTourDialog") {
        this.setRoundTourDialog = false;
      }
      if (el == "isSetLayout") {
        this.SetLayoutDialog = false;
      }
    },
    Meetlistener: function Meetlistener(obj) {
      console.log('this.joinMeetingState=============================', this.joinMeetingState);
      console.log('Meetlistener', obj);
      if (!obj) return;
      var state = obj.state;
      var self = this;
      if (state == 1) {
        // 发起呼叫中
      } else if (state == 2) {
        // 服务端已收到请求
      } else if (state == 3) {
        //服务端已经处理请求
      } else if (state == 4) {
        //取消呼叫  有异常
        this.loading.close();
        // 匿名入会
        if (this.SelfMeetUserId.indexOf("vistor") > -1) {
          this.$router.replace({
            path: "/yuntongxun/cloudmeet"
          });
          setTimeout(function () {
            // window.location.reload();
          }, 1500);
          // location.reload();
        } else {
          this.$router.replace({
            path: "/yuntongxun/cloudmeet"
          });
        }
        //媒体异常
        RL_MEET.meetingLsn(obj);
      } else if (state == 16) {
        //会议连接已经建立
        this.isMediaConnect = true;

        this.closeCameraAndPubVideo(true);
        this.closeMicrophone(true);
        self.getMeetInfo(function (res) {
          console.log('getMeetInfo', res);
          self.$store.commit('SET_MeetInfo', res);
          if (res.chatGroupId) {
            self.GroupId = res.chatGroupId;
          }
          self.getMediaDeviceList();
          if (res.state & 0x0002) {
            self.isLockMeet = true; //会议锁
          } else {
            self.isLockMeet = false; //无会议锁
          }
          //共享锁
          if (res.state & 0x0004) {
            self.isScreenlockMeet = true;
          } else {
            self.isScreenlockMeet = false;
          }
          self.loading.close();
          if (res.mainVenue) {
            self.$store.commit('SET_MainVenue', res.mainVenue);
            if (res.mainVenue !== self.SelfMeetUserId) {
              self.PlayUserList.unshift(res.mainVenue);
              self.memberInArrary.unshift(res.mainVenue);
            }
            self.IsMainHall = true;
            self.mainVenue = res.mainVenue;
          }
          // let memberObj = {}
          res.members.forEach(function (item) {
            // memberObj[item.memberId] = item.memberId.split('@')[1]
            if (item.memberId === self.SelfMeetUserId) {
              self.MerberiList[item.memberId] = item;
              if (self.IsHost(item.roleId)) {
                self.isHost = true;
              } else {
                self.isHost = false;
              }
              if (self.LoginServe.Profile && self.LoginServe.Profile.PhotoUrl) item.photourl = self.LoginServe.Profile.PhotoUrl;
              self.$store.commit('SET_MemberInObj', self.MerberiList);
            } else {
              self.updateMemberConfStatus(item, true);
            }
          });
          self.confirmShow();
          console.log('self.MerberiList----', self.MerberiList);
          // 获取聊天室缓存数据
          console.log('获取聊天室缓存数据====');
          // 清除allMessages数据
          if (self.allMessages && self.allMessages[self.GroupId] && self.allMessages[self.GroupId].msgs.length > 0) {
            self.allMessages[self.GroupId].msgs.length = 0;
            self.SET_AllMessages(self.allMessages);
            self.$bus.emit('firstGetHistoryChat', self.GroupId);
          }
          if (self.roundTourTimer) clearInterval(self.roundTourTimer);
        });
      } else {
        console.log("some one else ? ++", obj);
      }
    },

    connectState: function connectState(obj) {
      // obj.code;//变更状态 1 断开连接 2 重练中 3 重练成功 4 被踢下线 5 断开连接，需重新登录
      // 断线需要人工重连
      if (1 == obj.code) {
        console.log("onConnectStateChangeLisenter obj.code:" + obj.msg);
      } else if (2 == obj.code) {
        console.log("网络状况不佳，正在试图重连服务器");
      } else if (3 == obj.code) {
        console.log("连接成功", console.log.TYPE_OK);
      } else if (4 == obj.code) {
        //被踢  登出
        console.log(obj.msg, "vue:", this);
        RL_MEET.leaveMeeting(function (e) {
          console.debug("退会：CCM退会成功", e);
        }, function (err) {
          console.debug("退会：CCM退会失败", err);
        });
        if (this.roundTourTimer) clearInterval(this.roundTourTimer);
        this.$router.replace({
          path: "/"
        });
        this.$alert(obj.msg, this.$t('modelMessage.prompt'), {
          confirmButtonText: this.$t('btn.determine'),
          callback: function callback(action) {
            // setTimeout(() => {
            // location.reload();
            // }, 3000);
          }
        });
      } else if (5 == obj.code) {
        console.log("网络状况不佳，正在试图重连服务器");
        mediaMeeting.Login(this.LoginServe.UserId, function (e) {
          console.log(e, "重连成功");
        }, function (err) {
          console.log(err, "重连失败");
        });
      } else {
        console.log("onConnectStateChangeLisenter obj.code:" + obj.msg);
      }
    },
    recordStart: function recordStart() {
      var data = {
        confId: this.confId,
        recordType: 'mp4', //目前只支持flv,aac,h264,mp4
        outputPath: 'aaa/bbb',
        outputFilename: '会议录制test',
        model: 'auto', //model为manual(手动) member必选（成员ID: memberId String ID类型: idType Number ）
        layoutIdx: '-1'
      };
      RL_MEET.RecordStart(data, function (res) {
        console.log('/REST/Conference/Record/Start', res);
      }, function (error) {
        console.info(error);
      });
    }
  })
});
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-ab4c7178","hasScoped":true,"transformToRequire":{"video":["src","poster"],"source":"src","img":"src","image":"xlink:href"},"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/meet/Meeting.vue
var Meeting_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"MeetingBg"},[_c('video',{directives:[{name:"show",rawName:"v-show",value:(false),expression:"false"}],ref:"selfVideo",attrs:{"autoplay":"","muted":""},domProps:{"muted":true}}),_vm._v(" "),_c('audio',{ref:"audioTar",attrs:{"autoplay":""}}),_vm._v(" "),_c('meetingHeader',{directives:[{name:"show",rawName:"v-show",value:(!(_vm.IsShareIng && _vm.shareType==2)),expression:"!(IsShareIng && shareType==2)"}],ref:"meetHeader",attrs:{"isLogin":_vm.isLogin,"netStatus":_vm.netStatus,"roomInfo":_vm.meetInfo,"isHost":_vm.isHost,"showShareBtn":_vm.miniBoard}}),_vm._v(" "),(_vm.memberInObj[_vm.SelfMeetUserId])?_c('merberlist',{attrs:{"isshow":_vm.merberDialog,"SelfMeetUserId":_vm.SelfMeetUserId,"isHost":_vm.isHost,"screenUserId":_vm.screenUserId,"voiceIncentiveId":_vm.voiceIncentiveId}}):_vm._e(),_vm._v(" "),_c('WhiteBoard',{directives:[{name:"show",rawName:"v-show",value:(_vm.IsShareIng && _vm.shareType==2),expression:"IsShareIng && shareType==2"}],ref:"WhiteBoard",attrs:{"roomId":_vm.roomId,"userId":_vm.SelfMeetUserId,"isWhiteBoarOrganiser":_vm.isWhiteBoarOrganiser,"whiteBoardControllerDisabled":_vm.whiteBoardControllerDisabled,"wbInfo":_vm.wbInfo}}),_vm._v(" "),_c('div',{staticClass:"MeetUserVideo"},[_c('div',{staticStyle:{"height":"100%"}},[_c('selfmeetVideo',{directives:[{name:"show",rawName:"v-show",value:(Object.getOwnPropertyNames(_vm.memberInObj).length==1),expression:"Object.getOwnPropertyNames(memberInObj).length==1"}],attrs:{"userId":_vm.SelfMeetUserId}}),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(!_vm.MoreWithMore&&Object.getOwnPropertyNames(_vm.memberInObj).length>1),expression:"!MoreWithMore&&Object.getOwnPropertyNames(memberInObj).length>1"}],staticClass:"OneWithOneBg"},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.IsShareIng && _vm.shareType == 1),expression:"IsShareIng && shareType == 1"}],staticClass:"oneMainScreenBg"},[_c('video',{ref:"oneMainScreen",staticStyle:{"object-fit":"contain","width":"100%","height":"100%"},attrs:{"autoplay":"","muted":""},domProps:{"muted":true}}),_vm._v(" "),_c('p',{staticClass:"userNameP"},[_vm._v(_vm._s(_vm.screenShareIsMSG))])]),_vm._v(" "),(Object.getOwnPropertyNames(_vm.memberInObj).length&&_vm.PlayUserList[0])?_c('meetVideo',{directives:[{name:"show",rawName:"v-show",value:(!_vm.IsShareIng),expression:"!IsShareIng"}],attrs:{"userId":_vm.PlayUserList[0]}}):_vm._e(),_vm._v(" "),_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.isshowdargLi),expression:"isshowdargLi"}],staticClass:"isShowdargLiIcon"},[_c('i',{staticClass:"RSIcon RSIcon-guanbishexiangtou col2a5",staticStyle:{"font-size":"50px"},on:{"click":function($event){_vm.isshowdargLi=!_vm.isshowdargLi}}})]),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(!_vm.isshowdargLi),expression:"!isshowdargLi"}],attrs:{"id":"dargLi"}},[_c('selfmeetVideo',{attrs:{"userId":_vm.SelfMeetUserId}})],1)],1),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.MoreWithMore&&Object.getOwnPropertyNames(_vm.memberInObj).length>1),expression:"MoreWithMore&&Object.getOwnPropertyNames(memberInObj).length>1"}],staticClass:"MoreWithMore"},[_c('ul',{staticClass:"meet"},[_c('li',{staticClass:"Main",on:{"mouseover":function($event){_vm.showLeftArrow = true},"mouseout":function($event){_vm.showLeftArrow = false}}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.IsShareIng && _vm.shareType == 1),expression:"IsShareIng && shareType == 1"}],staticClass:"MainScreenBg"},[_c('video',{ref:"moreMainScreen",staticStyle:{"object-fit":"contain"},attrs:{"autoplay":"","muted":""},domProps:{"muted":true}}),_vm._v(" "),_c('p',{staticClass:"userNameP"},[_vm._v(_vm._s(_vm.screenShareIsMSG))])]),_vm._v(" "),(_vm.PlayUserList[0])?_c('meetVideo',{directives:[{name:"show",rawName:"v-show",value:(_vm.PlayUserList[0]&&!_vm.IsShareIng),expression:"PlayUserList[0]&&!IsShareIng"}],attrs:{"userId":_vm.PlayUserList[0]}}):_vm._e(),_vm._v(" "),_c('img',{directives:[{name:"show",rawName:"v-show",value:(_vm.showLeftArrow &&
            (Object.getOwnPropertyNames(_vm.memberInObj).length > 4 || (_vm.IsShareIng && _vm.shareType == 1 && Object.getOwnPropertyNames(_vm.memberInObj).length > 3)) ),expression:"showLeftArrow &&\n            (Object.getOwnPropertyNames(memberInObj).length > 4 || (IsShareIng && shareType == 1 && Object.getOwnPropertyNames(memberInObj).length > 3)) "},{name:"preventReClick",rawName:"v-preventReClick",value:(2000),expression:"2000"}],staticClass:"arrow-left",staticStyle:{"position":"absolute","left":"0","top":"49%","margin-top":"-40px","cursor":"pointer","pointer-events":"auto"},attrs:{"src":__webpack_require__("ePrg")},on:{"click":function($event){return _vm.changeScreenMember('pre')}}})],1),_vm._v(" "),_c('ul',{staticClass:"meet-right",on:{"mouseover":function($event){_vm.showRightArrow = true},"mouseout":function($event){_vm.showRightArrow = false}}},[_c('li',[_c('div',{directives:[{name:"show",rawName:"v-show",value:(!_vm.PlayUserList[1]),expression:"!PlayUserList[1]"}],staticClass:"NoMerber"},[_vm._v(_vm._s(_vm.$t('meeting.waitingForEnter')))]),_vm._v(" "),_c('meetVideo',{directives:[{name:"show",rawName:"v-show",value:(_vm.PlayUserList[1]),expression:"PlayUserList[1]"}],attrs:{"userId":_vm.PlayUserList[1]}})],1),_vm._v(" "),_c('li',[_c('div',{directives:[{name:"show",rawName:"v-show",value:(!_vm.PlayUserList[2]),expression:"!PlayUserList[2]"}],staticClass:"NoMerber"},[_vm._v(_vm._s(_vm.$t('meeting.waitingForEnter')))]),_vm._v(" "),_c('meetVideo',{directives:[{name:"show",rawName:"v-show",value:(_vm.PlayUserList[2]),expression:"PlayUserList[2]"}],attrs:{"userId":_vm.PlayUserList[2]}})],1),_vm._v(" "),_c('li',[_c('div',{directives:[{name:"show",rawName:"v-show",value:(!_vm.PlayUserList[3]),expression:"!PlayUserList[3]"}],staticClass:"NoMerber"},[_vm._v(_vm._s(_vm.$t('meeting.waitingForEnter')))]),_vm._v(" "),_c('meetVideo',{directives:[{name:"show",rawName:"v-show",value:(_vm.PlayUserList[3]),expression:"PlayUserList[3]"}],attrs:{"userId":_vm.PlayUserList[3]}})],1),_vm._v(" "),_c('img',{directives:[{name:"show",rawName:"v-show",value:((Object.getOwnPropertyNames(_vm.memberInObj).length > 4 || (_vm.IsShareIng && _vm.shareType == 1 && Object.getOwnPropertyNames(_vm.memberInObj).length > 3))  && _vm.showRightArrow),expression:"(Object.getOwnPropertyNames(memberInObj).length > 4 || (IsShareIng && shareType == 1 && Object.getOwnPropertyNames(memberInObj).length > 3))  && showRightArrow"},{name:"preventReClick",rawName:"v-preventReClick",value:(2000),expression:"2000"}],staticClass:"arrow-right",staticStyle:{"position":"absolute","right":"0","top":"49%","margin-top":"-40px","cursor":"pointer","pointer-events":"auto"},attrs:{"src":__webpack_require__("BIQG")},on:{"click":function($event){return _vm.changeScreenMember('next')}}})])])])],1)]),_vm._v(" "),(_vm.memberInObj[_vm.SelfMeetUserId])?_c('footer',{directives:[{name:"show",rawName:"v-show",value:(!(_vm.IsShareIng && _vm.shareType==2)),expression:"!(IsShareIng && shareType==2)"}]},[_c('ul',[(_vm.needAV === 'all' || _vm.needAV === 'video' || _vm.SelfMeetUserId.includes('vistor'))?_c('el-tooltip',{attrs:{"effect":"dark","content":_vm.memberInObj[_vm.SelfMeetUserId].isOpenVideo?_vm.$t('meeting.closeCamera'):_vm.$t('meeting.openCamera'),"placement":"top"}},[_c('li',{directives:[{name:"preventReClick",rawName:"v-preventReClick"}],class:{isActive:_vm.memberInObj[_vm.SelfMeetUserId].isOpenVideo},staticStyle:{"pointer-events":"auto"},on:{"click":function($event){_vm.memberInObj[_vm.SelfMeetUserId].isOpenVideo?_vm.closeCameraAndPubVideo():_vm.openCamera()}}},[_c('i',{staticClass:"RSIcon",class:_vm.memberInObj[_vm.SelfMeetUserId].isOpenVideo ? 'RSIcon-kaiqishexiangtou':'RSIcon-guanbishexiangtou',staticStyle:{"font-size":"48px"}})])]):_vm._e(),_vm._v(" "),(_vm.memberInObj[_vm.SelfMeetUserId] && (_vm.needAV === 'all' || _vm.needAV === 'audio' || _vm.SelfMeetUserId.includes('vistor')))?_c('el-tooltip',{attrs:{"effect":"dark","content":_vm.memberInObj[_vm.SelfMeetUserId].isOpenAudio?_vm.$t('meeting.closeMicrophone'):_vm.$t('meeting.openMicrophone'),"placement":"top"}},[_c('li',{directives:[{name:"preventReClick",rawName:"v-preventReClick"}],class:{isActive:_vm.memberInObj[_vm.SelfMeetUserId].isOpenAudio},staticStyle:{"pointer-events":"auto"},on:{"click":function($event){_vm.memberInObj[_vm.SelfMeetUserId].isOpenAudio?_vm.closeMicrophone():_vm.openMicrophone()}}},[_c('i',{staticClass:"RSIcon",class:_vm.memberInObj[_vm.SelfMeetUserId].isOpenAudio ? 'RSIcon-kaiqimaikefeng':'RSIcon-guanbimaikefeng',staticStyle:{"font-size":"30px"}})])]):_vm._e(),_vm._v(" "),_c('el-tooltip',{directives:[{name:"show",rawName:"v-show",value:(false),expression:"false"}],attrs:{"effect":"dark","content":_vm.videoStart?_vm.$t('meeting.stopRecord'):_vm.$t('meeting.startRecord'),"placement":"top"}},[_c('li',{class:{isActive:_vm.videoStart},on:{"click":function($event){_vm.videoStart?_vm.stopRecording():_vm.startRecording()}}},[_c('i',{staticClass:"RSIcon RSIcon-luzhi",staticStyle:{"font-size":"48px"}})])]),_vm._v(" "),_c('el-tooltip',{attrs:{"effect":"dark","content":_vm.$t('meeting.layout'),"placement":"top"}},[_c('li',{on:{"click":function($event){return _vm.isChangeLayout()}}},[_c('i',{staticClass:"RSIcon RSIcon-buju",staticStyle:{"font-size":"48px"}})])]),_vm._v(" "),(!_vm.screenShareIsShow)?_c('li',{class:{isActive:_vm.screenShareIsShow}},[_c('el-dropdown',{attrs:{"split-button":false,"placement":"top"}},[_c('span',{staticClass:"el-dropdown-link"},[_c('i',{staticClass:"RSIcon RSIcon-gongxiang",staticStyle:{"font-size":"48px"}})]),_vm._v(" "),_c('el-dropdown-menu',{staticClass:"screenShare",attrs:{"slot":"dropdown"},slot:"dropdown"},[(_vm.shareType != 2)?_c('el-dropdown-item',[_c('p',{on:{"click":_vm.screenShare}},[_vm._v(_vm._s(_vm.$t('meeting.shareDesktop')))])]):_vm._e()],1)],1)],1):_c('el-tooltip',{attrs:{"effect":"dark","content":_vm.shareType===1?_vm.$t('meeting.closeScreenShar'):_vm.$t('meeting.closeWhiteSharing'),"placement":"top"}},[_c('li',{style:({background:'red'}),on:{"click":function($event){_vm.shareType===1?_vm.SelfCloseScreenShare():_vm.closeWhiteBoardShare()}}},[_c('i',{staticClass:"RSIcon RSIcon-guanbigongxiang",staticStyle:{"font-size":"48px"}})])]),_vm._v(" "),_c('el-dropdown',{attrs:{"split-button":false,"placement":"top-start"}},[_c('span',{staticClass:"el-dropdown-link"},[_c('li',[_c('i',{staticClass:"RSIcon RSIcon-yaoqing",staticStyle:{"font-size":"48px"}})])]),_vm._v(" "),_c('el-dropdown-menu',{attrs:{"slot":"dropdown"},slot:"dropdown"},[(!(_vm.SelfMeetUserId.indexOf('vistor') > -1))?_c('el-dropdown-item',[_c('p',{on:{"click":_vm.inviteMerbers}},[_vm._v("邀请人员入会")])]):_vm._e(),_vm._v(" "),_c('el-dropdown-item',[_c('p',{on:{"click":function($event){_vm.meetShareDialog = true}}},[_vm._v(_vm._s(_vm.$t('connect.metting'))+_vm._s(_vm.$t('btn.share')))])])],1)],1),_vm._v(" "),_c('el-tooltip',{attrs:{"effect":"dark","content":_vm.$t('meeting.participant'),"placement":"top"}},[_c('li',{class:{isActive:_vm.merberDialog},on:{"click":function($event){_vm.merberDialog=!_vm.merberDialog}}},[_c('i',{staticClass:"RSIcon RSIcon-canhuiren",staticStyle:{"font-size":"48px"}})])]),_vm._v(" "),_c('el-dropdown',{attrs:{"split-button":false,"placement":"top-start"}},[_c('span',{staticClass:"el-dropdown-link"},[_c('li',[_c('i',{staticClass:"RSIcon RSIcon-gengduo1",staticStyle:{"font-size":"48px"}})])]),_vm._v(" "),_c('el-dropdown-menu',{attrs:{"slot":"dropdown"},slot:"dropdown"},[(_vm.isHost)?_c('el-dropdown-item',[_c('p',{on:{"click":_vm.screenlockMeet}},[_vm._v("\n              "+_vm._s(_vm.$t('meeting.lockSharing'))+"\n              "),_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.isScreenlockMeet),expression:"isScreenlockMeet"}]},[_vm._v(_vm._s(_vm.$t('meeting.turnedOn')))]),_vm._v(" "),_c('span',{directives:[{name:"show",rawName:"v-show",value:(!_vm.isScreenlockMeet),expression:"!isScreenlockMeet"}]},[_vm._v(_vm._s(_vm.$t('meeting.turnedOff')))])])]):_vm._e(),_vm._v(" "),(_vm.isHost)?_c('el-dropdown-item',[_c('p',{on:{"click":_vm.lockMeet}},[_vm._v("\n              "+_vm._s(_vm.$t('meeting.lockMeeting'))+"\n              "),_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.isLockMeet),expression:"isLockMeet"}]},[_vm._v(_vm._s(_vm.$t('meeting.turnedOn')))]),_vm._v(" "),_c('span',{directives:[{name:"show",rawName:"v-show",value:(!_vm.isLockMeet),expression:"!isLockMeet"}]},[_vm._v(_vm._s(_vm.$t('meeting.turnedOff')))])])]):_vm._e(),_vm._v(" "),_c('el-dropdown-item',{directives:[{name:"show",rawName:"v-show",value:(false),expression:"false"}]},[_c('p',{on:{"click":function($event){_vm.SetLayoutDialog=!_vm.SetLayoutDialog}}},[_vm._v(_vm._s(_vm.$t('meeting.moderatorLayout')))])]),_vm._v(" "),_c('el-dropdown-item',[_c('p',{on:{"click":function($event){_vm.meetInfoDialog=true}}},[_vm._v(_vm._s(_vm.$t('meeting.meetingDetail')))])]),_vm._v(" "),_c('el-dropdown-item',[_c('p',{on:{"click":function($event){return _vm.setvidedoialog()}}},[_vm._v(_vm._s(_vm.$t('meeting.meetingSetting')))])]),_vm._v(" "),(_vm.isHost && Object.getOwnPropertyNames(this.memberInObj).length > 2)?_c('el-dropdown-item',[_c('p',{on:{"click":function($event){_vm.setMainHallDialog=true}}},[_vm._v(_vm._s(_vm.$t('meeting.setMainVenue')))])]):_vm._e(),_vm._v(" "),(Object.getOwnPropertyNames(_vm.memberInObj).length > 4)?_c('el-dropdown-item',[_c('p',{on:{"click":function($event){_vm.setRoundTourDialog=true}}},[_vm._v(_vm._s(_vm.$t('meeting.setRoundTour')))])]):_vm._e(),_vm._v(" "),(false)?_c('el-dropdown-item',[_c('p',{on:{"click":_vm.recordStart}},[_vm._v("录像")])]):_vm._e()],1)],1)],1)]):_vm._e(),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.handUserMsg&&_vm.isHost&&_vm.isAllmuet),expression:"handUserMsg&&isHost&&isAllmuet"}],staticClass:"handUser"},[_vm._v(_vm._s(_vm.handUserMsg))]),_vm._v(" "),_c('el-dialog',{attrs:{"title":_vm.$t('modelMessage.prompt'),"visible":_vm.confirmLeavep,"width":"450px","modal":false,"close-on-click-modal":false,"custom-class":"confirmLeavepDialog","center":""},on:{"update:visible":function($event){_vm.confirmLeavep=$event}}},[_c('div',{staticStyle:{"width":"210px","margin":"0 auto","line-height":"25px"}},[_c('p',{staticStyle:{"font-size":"18px","margin-bottom":"20px"}},[_vm._v(_vm._s(_vm.$t('meeting.meetingConfirm')))]),_vm._v(" "),(_vm.isHost)?_c('el-checkbox',{model:{value:(_vm.isDelChecked),callback:function ($$v) {_vm.isDelChecked=$$v},expression:"isDelChecked"}},[_vm._v(_vm._s(_vm.$t('meeting.exitEndMeeting')))]):_vm._e()],1),_vm._v(" "),_c('span',{staticClass:"dialog-footer clearfix",attrs:{"slot":"footer"},slot:"footer"},[_c('el-button',{attrs:{"type":"default"},on:{"click":function($event){_vm.confirmLeavep=false}}},[_vm._v(_vm._s(_vm.$t('btn.cancel')))]),_vm._v(" "),_c('el-button',{staticStyle:{"margin-left":"50px"},attrs:{"type":"success"},on:{"click":_vm.leaveAllMeet}},[_vm._v(_vm._s(_vm.$t('btn.determine')))])],1)]),_vm._v(" "),_c('el-dialog',{attrs:{"title":_vm.$t('meeting.windowLayout'),"visible":_vm.selectMain,"modal":false,"width":"500px","close-on-click-modal":false},on:{"update:visible":function($event){_vm.selectMain=$event}}},[_c('el-row',{attrs:{"gutter":20}},[_c('el-col',{attrs:{"span":12}},[_c('ul',{staticClass:"selectOneVSOne",class:{selecctMainActive:_vm.selecctMainIndex==0},on:{"click":function($event){_vm.selecctMainIndex=0}}},[_c('li',[_vm._v("\n            "+_vm._s(_vm.$t('meeting.smartMode'))+"\n            "),_c('span')])])]),_vm._v(" "),_c('el-col',{attrs:{"span":12}},[_c('ul',{staticClass:"selectOneVMore",class:{selecctMainActive:_vm.selecctMainIndex==1},on:{"click":function($event){_vm.selecctMainIndex=1}}},[_c('li',[_vm._v(_vm._s(_vm.$t('meeting.smartMode')))]),_vm._v(" "),_c('li'),_vm._v(" "),_c('li'),_vm._v(" "),_c('li')])])],1),_vm._v(" "),_c('span',{staticClass:"dialog-footer",attrs:{"slot":"footer"},slot:"footer"},[_c('el-button',{on:{"click":function($event){_vm.selectMain = false;_vm.selecctMainIndex=_vm.MoreWithMore?0:1}}},[_vm._v(_vm._s(_vm.$t('btn.cancel')))]),_vm._v(" "),_c('el-button',{attrs:{"type":"primary"},on:{"click":_vm.changelaout}},[_vm._v(_vm._s(_vm.$t('btn.determine')))])],1)],1),_vm._v(" "),_c('el-dialog',{directives:[{name:"dialogDrag",rawName:"v-dialogDrag"}],attrs:{"title":_vm.$t('connect.settings'),"visible":_vm.setVideoDialog,"width":"500px","modal":false,"close-on-click-modal":false,"modal-append-to-body":false,"custom-class":"setMedia"},on:{"update:visible":function($event){_vm.setVideoDialog=$event}}},[_c('el-tabs',{attrs:{"tab-position":"left"},model:{value:(_vm.activeName),callback:function ($$v) {_vm.activeName=$$v},expression:"activeName"}},[_c('el-tab-pane',{attrs:{"label":_vm.$t('meeting.audio'),"name":"1"}},[_c('p',{staticClass:"chooseEqu"},[_vm._v(_vm._s(_vm.$t('meeting.microphone')))]),_vm._v(" "),_c('el-select',{staticClass:"w100",attrs:{"placeholder":_vm.$t('meeting.pleaseChoose')},model:{value:(_vm.CurrentMicrophoneID),callback:function ($$v) {_vm.CurrentMicrophoneID=$$v},expression:"CurrentMicrophoneID"}},_vm._l((_vm.MicrophoneList),function(item){return _c('el-option',{key:item.id,attrs:{"label":item.name,"value":item.id}})}),1),_vm._v(" "),_c('p',{staticClass:"chooseEqu"},[_vm._v(_vm._s(_vm.$t('meeting.speaker')))]),_vm._v(" "),_c('el-select',{staticClass:"w100 audioChoose",attrs:{"placeholder":_vm.$t('meeting.pleaseChoose')},on:{"change":function($event){return _vm.changeAudioDestination()}},model:{value:(_vm.CurrentSpeakerID),callback:function ($$v) {_vm.CurrentSpeakerID=$$v},expression:"CurrentSpeakerID"}},_vm._l((_vm.SpeakerList),function(item){return _c('el-option',{key:item.id,attrs:{"label":item.name,"value":item.id}})}),1)],1),_vm._v(" "),_c('el-tab-pane',{attrs:{"label":_vm.$t('message.video'),"name":"2"}},[_c('p',{staticClass:"chooseEqu"},[_vm._v(_vm._s(_vm.$t('meeting.camera')))]),_vm._v(" "),_c('el-select',{staticClass:"w100",attrs:{"placeholder":_vm.$t('meeting.pleaseChoose')},on:{"change":function($event){return _vm.PreviewingVideo()}},model:{value:(_vm.CurrentCameraID),callback:function ($$v) {_vm.CurrentCameraID=$$v},expression:"CurrentCameraID"}},_vm._l((_vm.CameraList),function(item){return _c('el-option',{key:item.id,attrs:{"label":item.name,"value":item.id}})}),1),_vm._v(" "),_c('video',{ref:"SelectVideo2",staticClass:"selfvide",attrs:{"muted":"","autoplay":""},domProps:{"muted":true}})],1),_vm._v(" "),_c('div',{staticClass:"save-media",on:{"click":_vm.saveSet}},[_vm._v(_vm._s(_vm.$t('btn.save')))])],1)],1),_vm._v(" "),(_vm.memberInObj[_vm.SelfMeetUserId])?_c('setMainHall',{attrs:{"isShow":_vm.setMainHallDialog,"SelfMeetUserId":_vm.SelfMeetUserId}}):_vm._e(),_vm._v(" "),_c('meetShare',{attrs:{"isshow":_vm.meetShareDialog,"meetInfos":_vm.meetInfo}}),_vm._v(" "),_c('delayed',{attrs:{"isshow":_vm.prolongDialogVisible,"willNextEndTime":_vm.nextEndTime}}),_vm._v(" "),_c('meetInfo',{attrs:{"isShow":_vm.meetInfoDialog,"roomInfo":_vm.meetInfo,"isHost":_vm.isHost}}),_vm._v(" "),(_vm.memberInObj[_vm.SelfMeetUserId])?_c('setRoundTour',{attrs:{"isShow":_vm.setRoundTourDialog,"SelfMeetUserId":_vm.SelfMeetUserId}}):_vm._e(),_vm._v(" "),_c('setLayout',{attrs:{"isShow":_vm.SetLayoutDialog,"merberLists":_vm.MerberiList2,"isHost":_vm.isHost}})],1)}
var Meeting_staticRenderFns = []
var Meeting_esExports = { render: Meeting_render, staticRenderFns: Meeting_staticRenderFns }
/* harmony default export */ var meet_Meeting = (Meeting_esExports);
// CONCATENATED MODULE: ./src/components/meet/Meeting.vue
function Meeting_injectStyle (ssrContext) {
  __webpack_require__("s+aQ")
  __webpack_require__("i7KQ")
  __webpack_require__("aU0I")
}
var Meeting_normalizeComponent = __webpack_require__("VU/8")
/* script */


/* template */

/* template functional */
var Meeting___vue_template_functional__ = false
/* styles */
var Meeting___vue_styles__ = Meeting_injectStyle
/* scopeId */
var Meeting___vue_scopeId__ = "data-v-ab4c7178"
/* moduleIdentifier (server only) */
var Meeting___vue_module_identifier__ = null
var Meeting_Component = Meeting_normalizeComponent(
  Meeting,
  meet_Meeting,
  Meeting___vue_template_functional__,
  Meeting___vue_styles__,
  Meeting___vue_scopeId__,
  Meeting___vue_module_identifier__
)

/* harmony default export */ var components_meet_Meeting = __webpack_exports__["default"] = (Meeting_Component.exports);


/***/ }),

/***/ "8ijg":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "8vhj":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./src/components/meeting/meetShare.vue
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ var meetShare = ({
  props: ['isshow', 'meetInfos'],
  watch: {
    meetInfos: function meetInfos(val) {
      // this.hostURL = '';
      this.hostURL = window.location.href.split('?')[0].replace(/CloudMeet_New/, "connect");
      this.meetInfo = val;
      this.hostURL = this.hostURL + "?confId=" + this.meetInfo.confId + "&anonymous=1";
      if (this.meetInfo.startTime || this.meetInfo.reserveStartTime) {
        var st = (this.meetInfo.startTime || this.meetInfo.reserveStartTime).replace(/-/g, "/").split(" ")[0];
        var sth = (this.meetInfo.startTime || this.meetInfo.reserveStartTime).split(" ")[1].slice(0, 5);
        var et = this.meetInfo.endTime.replace(/-/g, "/").split(" ")[0];
        var eth = this.meetInfo.endTime.split(" ")[1].slice(0, 5);
        this.sts = st + " " + sth;
        this.ets = et + " " + eth;
      }
      this.shareMessage = '\n        ' + this.$t('meeting.conferenceTheme') + '\uFF1A' + this.meetInfo.confName + ';\n        ' + this.$t('last.meetTime') + '\uFF1A' + this.sts + ' - ' + this.ets + ';\n        ' + this.$t('last.confId') + '\uFF1A' + this.meetInfo.confId + ';\n        ' + this.$t('last.confLink') + '\uFF1A' + this.hostURL;
    }
  },
  data: function data() {
    return {
      shareMessage: '',
      meetInfo: '',
      hostURL: "",
      sts: '',
      ets: ''
    };
  },
  created: function created() {
    this.hostURL = window.location.href.split('?')[0].replace(/CloudMeet_New/, "connect");
  },

  methods: {
    handleClose: function handleClose() {
      this.$parent.closeDialog('meetShare');
    },
    onCopy: function onCopy(e) {
      this.$message.success(this.$t('last.copySuccess'), e);
    },
    onError: function onError(e) {
      this.$message.error(this.$t('last.copyFail'));
    }
  }
});
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-520f6a81","hasScoped":true,"transformToRequire":{"video":["src","poster"],"source":"src","img":"src","image":"xlink:href"},"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/meeting/meetShare.vue
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('el-dialog',{directives:[{name:"dialogDrag",rawName:"v-dialogDrag"}],attrs:{"title":_vm.$t('last.meetShare'),"custom-class":"meetShareDialog","visible":_vm.isshow,"modal":false,"width":"440px","close-on-click-modal":false,"before-close":_vm.handleClose},on:{"update:visible":function($event){_vm.isshow=$event}}},[_c('div',[_c('p',[_c('span',{staticClass:"meetInfoTitle"},[_vm._v(_vm._s(_vm.$t('meeting.conferenceTheme'))+"：")]),_c('span',{staticClass:"meetInfoCon"},[_vm._v(_vm._s(_vm.meetInfo.confName))])]),_vm._v(" "),_c('p',[_c('span',{staticClass:"meetInfoTitle"},[_vm._v(_vm._s(_vm.$t('last.meetTime'))+"：")]),_c('span',{staticClass:"meetInfoCon"},[_vm._v(_vm._s(_vm.sts)+" - "+_vm._s(_vm.ets))])]),_vm._v(" "),_c('p',[_c('span',{staticClass:"meetInfoTitle"},[_vm._v(_vm._s(_vm.$t('last.confId'))+"：")]),_c('span',{staticClass:"meetInfoCon"},[_vm._v(_vm._s(_vm.meetInfo.confId))])]),_vm._v(" "),_c('p',[_c('span',{staticClass:"meetInfoTitle"},[_vm._v(_vm._s(_vm.$t('last.confLink'))+"：")]),_c('span',{staticClass:"meetInfoCon"},[_vm._v(_vm._s(_vm.hostURL))])])]),_vm._v(" "),_c('span',{staticClass:"dialog-footer",attrs:{"slot":"footer"},slot:"footer"},[_c('el-button',{directives:[{name:"clipboard",rawName:"v-clipboard:copy",value:(_vm.shareMessage),expression:"shareMessage",arg:"copy"},{name:"clipboard",rawName:"v-clipboard:success",value:(_vm.onCopy),expression:"onCopy",arg:"success"},{name:"clipboard",rawName:"v-clipboard:error",value:(_vm.onError),expression:"onError",arg:"error"}],attrs:{"type":"primary"},on:{"click":_vm.handleClose}},[_vm._v(_vm._s(_vm.$t('last.copyShare')))]),_vm._v(" "),_c('el-button',{directives:[{name:"clipboard",rawName:"v-clipboard:copy",value:(_vm.hostURL),expression:"hostURL",arg:"copy"},{name:"clipboard",rawName:"v-clipboard:success",value:(_vm.onCopy),expression:"onCopy",arg:"success"},{name:"clipboard",rawName:"v-clipboard:error",value:(_vm.onError),expression:"onError",arg:"error"}],staticClass:"copyLinkStyle",on:{"click":function($event){_vm.meetShare = false,_vm.handleClose()}}},[_vm._v(_vm._s(_vm.$t('context.copyLink')))])],1)])],1)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var meeting_meetShare = (esExports);
// CONCATENATED MODULE: ./src/components/meeting/meetShare.vue
function injectStyle (ssrContext) {
  __webpack_require__("+Jap")
  __webpack_require__("b0pA")
}
var normalizeComponent = __webpack_require__("VU/8")
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = "data-v-520f6a81"
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  meetShare,
  meeting_meetShare,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ var components_meeting_meetShare = __webpack_exports__["a"] = (Component.exports);


/***/ }),

/***/ "BIQG":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "CoeO":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "DoPr":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "FeHq":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "Hmds":
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./FileTypeS_pdf.png": "fEUG",
	"./FileTypeS_ppt.png": "QVtT",
	"./FileTypeS_word.png": "2oL2",
	"./FileTypeS_xls.png": "peeZ"
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number or string
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "Hmds";

/***/ }),

/***/ "HrYf":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "LfR4":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 Object.getOwnPropertyNames(O)
__webpack_require__("30vf")('getOwnPropertyNames', function () {
  return __webpack_require__("6tLb").f;
});


/***/ }),

/***/ "MTFV":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "N7PQ":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "QVtT":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "YxoK":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "ZsmM":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "a53c":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "aFK5":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("vwWJ"), __esModule: true };

/***/ }),

/***/ "aU0I":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "ae99":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAAC0CAMAAAAKE/YAAAAAV1BMVEWSpMfe5vbf6Pbi6vfh6ffv9/3y+f7k7Pjz+v/x+P31+//t9Pzp8Prs8/vu9f3l7fnq8vvn7/nK1umjs9Ha5PPAzeKXqcrW4O+drc6uvdint9Szwdq4xd6T+5vRAAAEDUlEQVR42uzBAQEAAACCoP6vbojAAAAAAAAAAICGU192SwqDMBjN6oDYAmo7Sm19/+dckpT+TLdjL789QhLQizMOE9rX0KRHdK5+pGZ40X/gnWy1wKU3ofO+VBsu2NqvVP1JAj4kra928C2B0pvKVVscD9MTJF0QQ+ecRFlMuAD5X78uTvUyEmZ/sb8gnutGRctHvSVrrBqCo7Vusp5RZc0W74Ak95VEYLRsZd0GO21avL+6sVa8Jklel52yQDvVns1krnGL4DxB0Y+GX8C6YZ72EE9CIm38rjJLGiNW/3iw31Xd5nKx0vWNkDDZjmFDUdRSkUIhIDpb3LbYZdURDq1ImWtJuyBdLz2rGqO6mrQs0YwZqef1rLyQM7KaAu8xV6hXgd4cA0q6NQdBOtOdOQhS9yBzEELiFo2JMQcjk8NM5CE/wLoRU1RUXUvJpVRvrGePRtQ2ZNUVWG8BQyzUsda0RjcGQqKr2ZaHFFGGkBMvtIJqHkQ/dTHjOOsKpfghLJ71AbBeXIhalgohz7pMDqVUkO5DIYWgnqLJqHPghfpjNTxmYLld5Eus3iGcwxfOhMfnHhiNWq7zhwA5hfs9Dw5BhtaceZ4IkeG+h/gDnmgmrUz9WhyvdSit9yLrx7CacD260Pgs69l5Qoxzwnq+W9LdZlkNZd7AHpV+2TWj3UZhIIqasSW/rIQwhiYl//+dy3i4eCJIs1sVMpVywOZOXZITyyIkimb48wBrdx2asd137gxPtHNpkZw3wNHuimam1bnrxLcEo9fohU/WZc2Oe+ydpS+WdqS7Leal+31p279S6duNcDvvxqVnw7abN975BZRmfKY/20pXo8lb6ZVbu4vp6/SY96W9xR+ogCFuhaPxqR5mxRh1K9Jxxuod05jiSgtnVDGZXCF9jl+S7X12GYf4CI8wGJvsa47/QLb0JnNJ0cucejlKKZWkZU9WPg2MQ2BbL6qeczmgkBYlBRtr5Jo9I4IKCANgYI30yf83qXevAivjO7xyjUzZe20dpAuq0H39p5An9xr6DyiE6si5NL/AGQOomI/T1whWRqjIDNeKS4kSfOnUGJ2/Rq45PAaytEQqqgCZTr6OXJIIAaJApQfIG+gunvleMzUixaK8kTQpCUa15E4ChrA1kzuHS2IFzWJdbKrRjAwtg7wDmJ812ddMq01F6UH/0ctCEMIZK3ugbwL1LYM7mEQHkJzmdzgfbH2jLc28fQGPPj/r5o4jq6dqpKleRznir+tZNTQ4lJTdcTQFzFTRXoKMsAKKu7nmAdiWAifhUdxxwKo6SkQFW4mQajSEXp16tDQgZfQcejJwrPSP85Z+S79eOjcA5PvqaYHyPdNv/rYHhwQAAAAAgv6/doYFAAAAAAAAAIBZnydvj3hJ0cQAAAAASUVORK5CYII="

/***/ }),

/***/ "afkt":
/***/ (function(module, exports) {

module.exports=function (initdebug) {
	if (initdebug) return console.log;
	return function(){}
}

/***/ }),

/***/ "b0pA":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "cgeL":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "ePrg":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "fEUG":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "i7KQ":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "jM3i":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "mbvs":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

// Last time updated: 2021-03-09 3:20:22 AM UTC

// ________________
// RecordRTC v5.6.2

// Open-Sourced: https://github.com/muaz-khan/RecordRTC

// --------------------------------------------------
// Muaz Khan     - www.MuazKhan.com
// MIT License   - www.WebRTC-Experiment.com/licence
// --------------------------------------------------

// ____________
// RecordRTC.js

/**
 * {@link https://github.com/muaz-khan/RecordRTC|RecordRTC} is a WebRTC JavaScript library for audio/video as well as screen activity recording. It supports Chrome, Firefox, Opera, Android, and Microsoft Edge. Platforms: Linux, Mac and Windows. 
 * @summary Record audio, video or screen inside the browser.
 * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
 * @author {@link https://MuazKhan.com|Muaz Khan}
 * @typedef RecordRTC
 * @class
 * @example
 * var recorder = RecordRTC(mediaStream or [arrayOfMediaStream], {
 *     type: 'video', // audio or video or gif or canvas
 *     recorderType: MediaStreamRecorder || CanvasRecorder || StereoAudioRecorder || Etc
 * });
 * recorder.startRecording();
 * @see For further information:
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 * @param {MediaStream} mediaStream - Single media-stream object, array of media-streams, html-canvas-element, etc.
 * @param {object} config - {type:"video", recorderType: MediaStreamRecorder, disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, desiredSampRate: 16000, video: HTMLVideoElement, etc.}
 */

function RecordRTC(mediaStream, config) {
    if (!mediaStream) {
        throw 'First parameter is required.';
    }

    config = config || {
        type: 'video'
    };

    config = new RecordRTCConfiguration(mediaStream, config);

    // a reference to user's recordRTC object
    var self = this;

    function startRecording(config2) {
        if (!config.disableLogs) {
            console.log('RecordRTC version: ', self.version);
        }

        if (!!config2) {
            // allow users to set options using startRecording method
            // config2 is similar to main "config" object (second parameter over RecordRTC constructor)
            config = new RecordRTCConfiguration(mediaStream, config2);
        }

        if (!config.disableLogs) {
            console.log('started recording ' + config.type + ' stream.');
        }

        if (mediaRecorder) {
            mediaRecorder.clearRecordedData();
            mediaRecorder.record();

            setState('recording');

            if (self.recordingDuration) {
                handleRecordingDuration();
            }
            return self;
        }

        initRecorder(function() {
            if (self.recordingDuration) {
                handleRecordingDuration();
            }
        });

        return self;
    }

    function initRecorder(initCallback) {
        if (initCallback) {
            config.initCallback = function() {
                initCallback();
                initCallback = config.initCallback = null; // recorder.initRecorder should be call-backed once.
            };
        }

        var Recorder = new GetRecorderType(mediaStream, config);

        mediaRecorder = new Recorder(mediaStream, config);
        mediaRecorder.record();

        setState('recording');

        if (!config.disableLogs) {
            console.log('Initialized recorderType:', mediaRecorder.constructor.name, 'for output-type:', config.type);
        }
    }

    function stopRecording(callback) {
        callback = callback || function() {};

        if (!mediaRecorder) {
            warningLog();
            return;
        }

        if (self.state === 'paused') {
            self.resumeRecording();

            setTimeout(function() {
                stopRecording(callback);
            }, 1);
            return;
        }

        if (self.state !== 'recording' && !config.disableLogs) {
            console.warn('Recording state should be: "recording", however current state is: ', self.state);
        }

        if (!config.disableLogs) {
            console.log('Stopped recording ' + config.type + ' stream.');
        }

        if (config.type !== 'gif') {
            mediaRecorder.stop(_callback);
        } else {
            mediaRecorder.stop();
            _callback();
        }

        setState('stopped');

        function _callback(__blob) {
            if (!mediaRecorder) {
                if (typeof callback.call === 'function') {
                    callback.call(self, '');
                } else {
                    callback('');
                }
                return;
            }

            Object.keys(mediaRecorder).forEach(function(key) {
                if (typeof mediaRecorder[key] === 'function') {
                    return;
                }

                self[key] = mediaRecorder[key];
            });

            var blob = mediaRecorder.blob;

            if (!blob) {
                if (__blob) {
                    mediaRecorder.blob = blob = __blob;
                } else {
                    throw 'Recording failed.';
                }
            }

            if (blob && !config.disableLogs) {
                console.log(blob.type, '->', bytesToSize(blob.size));
            }

            if (callback) {
                var url;

                try {
                    url = URL.createObjectURL(blob);
                } catch (e) {}

                if (typeof callback.call === 'function') {
                    callback.call(self, url);
                } else {
                    callback(url);
                }
            }

            if (!config.autoWriteToDisk) {
                return;
            }

            getDataURL(function(dataURL) {
                var parameter = {};
                parameter[config.type + 'Blob'] = dataURL;
                DiskStorage.Store(parameter);
            });
        }
    }

    function pauseRecording() {
        if (!mediaRecorder) {
            warningLog();
            return;
        }

        if (self.state !== 'recording') {
            if (!config.disableLogs) {
                console.warn('Unable to pause the recording. Recording state: ', self.state);
            }
            return;
        }

        setState('paused');

        mediaRecorder.pause();

        if (!config.disableLogs) {
            console.log('Paused recording.');
        }
    }

    function resumeRecording() {
        if (!mediaRecorder) {
            warningLog();
            return;
        }

        if (self.state !== 'paused') {
            if (!config.disableLogs) {
                console.warn('Unable to resume the recording. Recording state: ', self.state);
            }
            return;
        }

        setState('recording');

        // not all libs have this method yet
        mediaRecorder.resume();

        if (!config.disableLogs) {
            console.log('Resumed recording.');
        }
    }

    function readFile(_blob) {
        postMessage(new FileReaderSync().readAsDataURL(_blob));
    }

    function getDataURL(callback, _mediaRecorder) {
        if (!callback) {
            throw 'Pass a callback function over getDataURL.';
        }

        var blob = _mediaRecorder ? _mediaRecorder.blob : (mediaRecorder || {}).blob;

        if (!blob) {
            if (!config.disableLogs) {
                console.warn('Blob encoder did not finish its job yet.');
            }

            setTimeout(function() {
                getDataURL(callback, _mediaRecorder);
            }, 1000);
            return;
        }

        if (typeof Worker !== 'undefined' && !navigator.mozGetUserMedia) {
            var webWorker = processInWebWorker(readFile);

            webWorker.onmessage = function(event) {
                callback(event.data);
            };

            webWorker.postMessage(blob);
        } else {
            var reader = new FileReader();
            reader.readAsDataURL(blob);
            reader.onload = function(event) {
                callback(event.target.result);
            };
        }

        function processInWebWorker(_function) {
            try {
                var blob = URL.createObjectURL(new Blob([_function.toString(),
                    'this.onmessage =  function (eee) {' + _function.name + '(eee.data);}'
                ], {
                    type: 'application/javascript'
                }));

                var worker = new Worker(blob);
                URL.revokeObjectURL(blob);
                return worker;
            } catch (e) {}
        }
    }

    function handleRecordingDuration(counter) {
        counter = counter || 0;

        if (self.state === 'paused') {
            setTimeout(function() {
                handleRecordingDuration(counter);
            }, 1000);
            return;
        }

        if (self.state === 'stopped') {
            return;
        }

        if (counter >= self.recordingDuration) {
            stopRecording(self.onRecordingStopped);
            return;
        }

        counter += 1000; // 1-second

        setTimeout(function() {
            handleRecordingDuration(counter);
        }, 1000);
    }

    function setState(state) {
        if (!self) {
            return;
        }

        self.state = state;

        if (typeof self.onStateChanged.call === 'function') {
            self.onStateChanged.call(self, state);
        } else {
            self.onStateChanged(state);
        }
    }

    var WARNING = 'It seems that recorder is destroyed or "startRecording" is not invoked for ' + config.type + ' recorder.';

    function warningLog() {
        if (config.disableLogs === true) {
            return;
        }

        console.warn(WARNING);
    }

    var mediaRecorder;

    var returnObject = {
        /**
         * This method starts the recording.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * var recorder = RecordRTC(mediaStream, {
         *     type: 'video'
         * });
         * recorder.startRecording();
         */
        startRecording: startRecording,

        /**
         * This method stops the recording. It is strongly recommended to get "blob" or "URI" inside the callback to make sure all recorders finished their job.
         * @param {function} callback - Callback to get the recorded blob.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * recorder.stopRecording(function() {
         *     // use either "this" or "recorder" object; both are identical
         *     video.src = this.toURL();
         *     var blob = this.getBlob();
         * });
         */
        stopRecording: stopRecording,

        /**
         * This method pauses the recording. You can resume recording using "resumeRecording" method.
         * @method
         * @memberof RecordRTC
         * @instance
         * @todo Firefox is unable to pause the recording. Fix it.
         * @example
         * recorder.pauseRecording();  // pause the recording
         * recorder.resumeRecording(); // resume again
         */
        pauseRecording: pauseRecording,

        /**
         * This method resumes the recording.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * recorder.pauseRecording();  // first of all, pause the recording
         * recorder.resumeRecording(); // now resume it
         */
        resumeRecording: resumeRecording,

        /**
         * This method initializes the recording.
         * @method
         * @memberof RecordRTC
         * @instance
         * @todo This method should be deprecated.
         * @example
         * recorder.initRecorder();
         */
        initRecorder: initRecorder,

        /**
         * Ask RecordRTC to auto-stop the recording after 5 minutes.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * var fiveMinutes = 5 * 1000 * 60;
         * recorder.setRecordingDuration(fiveMinutes, function() {
         *    var blob = this.getBlob();
         *    video.src = this.toURL();
         * });
         * 
         * // or otherwise
         * recorder.setRecordingDuration(fiveMinutes).onRecordingStopped(function() {
         *    var blob = this.getBlob();
         *    video.src = this.toURL();
         * });
         */
        setRecordingDuration: function(recordingDuration, callback) {
            if (typeof recordingDuration === 'undefined') {
                throw 'recordingDuration is required.';
            }

            if (typeof recordingDuration !== 'number') {
                throw 'recordingDuration must be a number.';
            }

            self.recordingDuration = recordingDuration;
            self.onRecordingStopped = callback || function() {};

            return {
                onRecordingStopped: function(callback) {
                    self.onRecordingStopped = callback;
                }
            };
        },

        /**
         * This method can be used to clear/reset all the recorded data.
         * @method
         * @memberof RecordRTC
         * @instance
         * @todo Figure out the difference between "reset" and "clearRecordedData" methods.
         * @example
         * recorder.clearRecordedData();
         */
        clearRecordedData: function() {
            if (!mediaRecorder) {
                warningLog();
                return;
            }

            mediaRecorder.clearRecordedData();

            if (!config.disableLogs) {
                console.log('Cleared old recorded data.');
            }
        },

        /**
         * Get the recorded blob. Use this method inside the "stopRecording" callback.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * recorder.stopRecording(function() {
         *     var blob = this.getBlob();
         *
         *     var file = new File([blob], 'filename.webm', {
         *         type: 'video/webm'
         *     });
         *
         *     var formData = new FormData();
         *     formData.append('file', file); // upload "File" object rather than a "Blob"
         *     uploadToServer(formData);
         * });
         * @returns {Blob} Returns recorded data as "Blob" object.
         */
        getBlob: function() {
            if (!mediaRecorder) {
                warningLog();
                return;
            }

            return mediaRecorder.blob;
        },

        /**
         * Get data-URI instead of Blob.
         * @param {function} callback - Callback to get the Data-URI.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * recorder.stopRecording(function() {
         *     recorder.getDataURL(function(dataURI) {
         *         video.src = dataURI;
         *     });
         * });
         */
        getDataURL: getDataURL,

        /**
         * Get virtual/temporary URL. Usage of this URL is limited to current tab.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * recorder.stopRecording(function() {
         *     video.src = this.toURL();
         * });
         * @returns {String} Returns a virtual/temporary URL for the recorded "Blob".
         */
        toURL: function() {
            if (!mediaRecorder) {
                warningLog();
                return;
            }

            return URL.createObjectURL(mediaRecorder.blob);
        },

        /**
         * Get internal recording object (i.e. internal module) e.g. MutliStreamRecorder, MediaStreamRecorder, StereoAudioRecorder or WhammyRecorder etc.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * var internalRecorder = recorder.getInternalRecorder();
         * if(internalRecorder instanceof MultiStreamRecorder) {
         *     internalRecorder.addStreams([newAudioStream]);
         *     internalRecorder.resetVideoStreams([screenStream]);
         * }
         * @returns {Object} Returns internal recording object.
         */
        getInternalRecorder: function() {
            return mediaRecorder;
        },

        /**
         * Invoke save-as dialog to save the recorded blob into your disk.
         * @param {string} fileName - Set your own file name.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * recorder.stopRecording(function() {
         *     this.save('file-name');
         *
         *     // or manually:
         *     invokeSaveAsDialog(this.getBlob(), 'filename.webm');
         * });
         */
        save: function(fileName) {
            if (!mediaRecorder) {
                warningLog();
                return;
            }

            invokeSaveAsDialog(mediaRecorder.blob, fileName);
        },

        /**
         * This method gets a blob from indexed-DB storage.
         * @param {function} callback - Callback to get the recorded blob.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * recorder.getFromDisk(function(dataURL) {
         *     video.src = dataURL;
         * });
         */
        getFromDisk: function(callback) {
            if (!mediaRecorder) {
                warningLog();
                return;
            }

            RecordRTC.getFromDisk(config.type, callback);
        },

        /**
         * This method appends an array of webp images to the recorded video-blob. It takes an "array" object.
         * @type {Array.<Array>}
         * @param {Array} arrayOfWebPImages - Array of webp images.
         * @method
         * @memberof RecordRTC
         * @instance
         * @todo This method should be deprecated.
         * @example
         * var arrayOfWebPImages = [];
         * arrayOfWebPImages.push({
         *     duration: index,
         *     image: 'data:image/webp;base64,...'
         * });
         * recorder.setAdvertisementArray(arrayOfWebPImages);
         */
        setAdvertisementArray: function(arrayOfWebPImages) {
            config.advertisement = [];

            var length = arrayOfWebPImages.length;
            for (var i = 0; i < length; i++) {
                config.advertisement.push({
                    duration: i,
                    image: arrayOfWebPImages[i]
                });
            }
        },

        /**
         * It is equivalent to <code class="str">"recorder.getBlob()"</code> method. Usage of "getBlob" is recommended, though.
         * @property {Blob} blob - Recorded Blob can be accessed using this property.
         * @memberof RecordRTC
         * @instance
         * @readonly
         * @example
         * recorder.stopRecording(function() {
         *     var blob = this.blob;
         *
         *     // below one is recommended
         *     var blob = this.getBlob();
         * });
         */
        blob: null,

        /**
         * This works only with {recorderType:StereoAudioRecorder}. Use this property on "stopRecording" to verify the encoder's sample-rates.
         * @property {number} bufferSize - Buffer-size used to encode the WAV container
         * @memberof RecordRTC
         * @instance
         * @readonly
         * @example
         * recorder.stopRecording(function() {
         *     alert('Recorder used this buffer-size: ' + this.bufferSize);
         * });
         */
        bufferSize: 0,

        /**
         * This works only with {recorderType:StereoAudioRecorder}. Use this property on "stopRecording" to verify the encoder's sample-rates.
         * @property {number} sampleRate - Sample-rates used to encode the WAV container
         * @memberof RecordRTC
         * @instance
         * @readonly
         * @example
         * recorder.stopRecording(function() {
         *     alert('Recorder used these sample-rates: ' + this.sampleRate);
         * });
         */
        sampleRate: 0,

        /**
         * {recorderType:StereoAudioRecorder} returns ArrayBuffer object.
         * @property {ArrayBuffer} buffer - Audio ArrayBuffer, supported only in Chrome.
         * @memberof RecordRTC
         * @instance
         * @readonly
         * @example
         * recorder.stopRecording(function() {
         *     var arrayBuffer = this.buffer;
         *     alert(arrayBuffer.byteLength);
         * });
         */
        buffer: null,

        /**
         * This method resets the recorder. So that you can reuse single recorder instance many times.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * recorder.reset();
         * recorder.startRecording();
         */
        reset: function() {
            if (self.state === 'recording' && !config.disableLogs) {
                console.warn('Stop an active recorder.');
            }

            if (mediaRecorder && typeof mediaRecorder.clearRecordedData === 'function') {
                mediaRecorder.clearRecordedData();
            }
            mediaRecorder = null;
            setState('inactive');
            self.blob = null;
        },

        /**
         * This method is called whenever recorder's state changes. Use this as an "event".
         * @property {String} state - A recorder's state can be: recording, paused, stopped or inactive.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * recorder.onStateChanged = function(state) {
         *     console.log('Recorder state: ', state);
         * };
         */
        onStateChanged: function(state) {
            if (!config.disableLogs) {
                console.log('Recorder state changed:', state);
            }
        },

        /**
         * A recorder can have inactive, recording, paused or stopped states.
         * @property {String} state - A recorder's state can be: recording, paused, stopped or inactive.
         * @memberof RecordRTC
         * @static
         * @readonly
         * @example
         * // this looper function will keep you updated about the recorder's states.
         * (function looper() {
         *     document.querySelector('h1').innerHTML = 'Recorder\'s state is: ' + recorder.state;
         *     if(recorder.state === 'stopped') return; // ignore+stop
         *     setTimeout(looper, 1000); // update after every 3-seconds
         * })();
         * recorder.startRecording();
         */
        state: 'inactive',

        /**
         * Get recorder's readonly state.
         * @method
         * @memberof RecordRTC
         * @example
         * var state = recorder.getState();
         * @returns {String} Returns recording state.
         */
        getState: function() {
            return self.state;
        },

        /**
         * Destroy RecordRTC instance. Clear all recorders and objects.
         * @method
         * @memberof RecordRTC
         * @example
         * recorder.destroy();
         */
        destroy: function() {
            var disableLogsCache = config.disableLogs;

            config = {
                disableLogs: true
            };
            self.reset();
            setState('destroyed');
            returnObject = self = null;

            if (Storage.AudioContextConstructor) {
                Storage.AudioContextConstructor.close();
                Storage.AudioContextConstructor = null;
            }

            config.disableLogs = disableLogsCache;

            if (!config.disableLogs) {
                console.log('RecordRTC is destroyed.');
            }
        },

        /**
         * RecordRTC version number
         * @property {String} version - Release version number.
         * @memberof RecordRTC
         * @static
         * @readonly
         * @example
         * alert(recorder.version);
         */
        version: '5.6.2'
    };

    if (!this) {
        self = returnObject;
        return returnObject;
    }

    // if someone wants to use RecordRTC with the "new" keyword.
    for (var prop in returnObject) {
        this[prop] = returnObject[prop];
    }

    self = this;

    return returnObject;
}

RecordRTC.version = '5.6.2';

if (true /* && !!module.exports*/ ) {
    module.exports = RecordRTC;
}

if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
        return RecordRTC;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}

RecordRTC.getFromDisk = function(type, callback) {
    if (!callback) {
        throw 'callback is mandatory.';
    }

    console.log('Getting recorded ' + (type === 'all' ? 'blobs' : type + ' blob ') + ' from disk!');
    DiskStorage.Fetch(function(dataURL, _type) {
        if (type !== 'all' && _type === type + 'Blob' && callback) {
            callback(dataURL);
        }

        if (type === 'all' && callback) {
            callback(dataURL, _type.replace('Blob', ''));
        }
    });
};

/**
 * This method can be used to store recorded blobs into IndexedDB storage.
 * @param {object} options - {audio: Blob, video: Blob, gif: Blob}
 * @method
 * @memberof RecordRTC
 * @example
 * RecordRTC.writeToDisk({
 *     audio: audioBlob,
 *     video: videoBlob,
 *     gif  : gifBlob
 * });
 */
RecordRTC.writeToDisk = function(options) {
    console.log('Writing recorded blob(s) to disk!');
    options = options || {};
    if (options.audio && options.video && options.gif) {
        options.audio.getDataURL(function(audioDataURL) {
            options.video.getDataURL(function(videoDataURL) {
                options.gif.getDataURL(function(gifDataURL) {
                    DiskStorage.Store({
                        audioBlob: audioDataURL,
                        videoBlob: videoDataURL,
                        gifBlob: gifDataURL
                    });
                });
            });
        });
    } else if (options.audio && options.video) {
        options.audio.getDataURL(function(audioDataURL) {
            options.video.getDataURL(function(videoDataURL) {
                DiskStorage.Store({
                    audioBlob: audioDataURL,
                    videoBlob: videoDataURL
                });
            });
        });
    } else if (options.audio && options.gif) {
        options.audio.getDataURL(function(audioDataURL) {
            options.gif.getDataURL(function(gifDataURL) {
                DiskStorage.Store({
                    audioBlob: audioDataURL,
                    gifBlob: gifDataURL
                });
            });
        });
    } else if (options.video && options.gif) {
        options.video.getDataURL(function(videoDataURL) {
            options.gif.getDataURL(function(gifDataURL) {
                DiskStorage.Store({
                    videoBlob: videoDataURL,
                    gifBlob: gifDataURL
                });
            });
        });
    } else if (options.audio) {
        options.audio.getDataURL(function(audioDataURL) {
            DiskStorage.Store({
                audioBlob: audioDataURL
            });
        });
    } else if (options.video) {
        options.video.getDataURL(function(videoDataURL) {
            DiskStorage.Store({
                videoBlob: videoDataURL
            });
        });
    } else if (options.gif) {
        options.gif.getDataURL(function(gifDataURL) {
            DiskStorage.Store({
                gifBlob: gifDataURL
            });
        });
    }
};

// __________________________
// RecordRTC-Configuration.js

/**
 * {@link RecordRTCConfiguration} is an inner/private helper for {@link RecordRTC}.
 * @summary It configures the 2nd parameter passed over {@link RecordRTC} and returns a valid "config" object.
 * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
 * @author {@link https://MuazKhan.com|Muaz Khan}
 * @typedef RecordRTCConfiguration
 * @class
 * @example
 * var options = RecordRTCConfiguration(mediaStream, options);
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
 * @param {object} config - {type:"video", disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, video: HTMLVideoElement, getNativeBlob:true, etc.}
 */

function RecordRTCConfiguration(mediaStream, config) {
    if (!config.recorderType && !config.type) {
        if (!!config.audio && !!config.video) {
            config.type = 'video';
        } else if (!!config.audio && !config.video) {
            config.type = 'audio';
        }
    }

    if (config.recorderType && !config.type) {
        if (config.recorderType === WhammyRecorder || config.recorderType === CanvasRecorder || (typeof WebAssemblyRecorder !== 'undefined' && config.recorderType === WebAssemblyRecorder)) {
            config.type = 'video';
        } else if (config.recorderType === GifRecorder) {
            config.type = 'gif';
        } else if (config.recorderType === StereoAudioRecorder) {
            config.type = 'audio';
        } else if (config.recorderType === MediaStreamRecorder) {
            if (getTracks(mediaStream, 'audio').length && getTracks(mediaStream, 'video').length) {
                config.type = 'video';
            } else if (!getTracks(mediaStream, 'audio').length && getTracks(mediaStream, 'video').length) {
                config.type = 'video';
            } else if (getTracks(mediaStream, 'audio').length && !getTracks(mediaStream, 'video').length) {
                config.type = 'audio';
            } else {
                // config.type = 'UnKnown';
            }
        }
    }

    if (typeof MediaStreamRecorder !== 'undefined' && typeof MediaRecorder !== 'undefined' && 'requestData' in MediaRecorder.prototype) {
        if (!config.mimeType) {
            config.mimeType = 'video/webm';
        }

        if (!config.type) {
            config.type = config.mimeType.split('/')[0];
        }

        if (!config.bitsPerSecond) {
            // config.bitsPerSecond = 128000;
        }
    }

    // consider default type=audio
    if (!config.type) {
        if (config.mimeType) {
            config.type = config.mimeType.split('/')[0];
        }
        if (!config.type) {
            config.type = 'audio';
        }
    }

    return config;
}

// __________________
// GetRecorderType.js

/**
 * {@link GetRecorderType} is an inner/private helper for {@link RecordRTC}.
 * @summary It returns best recorder-type available for your browser.
 * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
 * @author {@link https://MuazKhan.com|Muaz Khan}
 * @typedef GetRecorderType
 * @class
 * @example
 * var RecorderType = GetRecorderType(options);
 * var recorder = new RecorderType(options);
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
 * @param {object} config - {type:"video", disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, video: HTMLVideoElement, etc.}
 */

function GetRecorderType(mediaStream, config) {
    var recorder;

    // StereoAudioRecorder can work with all three: Edge, Firefox and Chrome
    // todo: detect if it is Edge, then auto use: StereoAudioRecorder
    if (isChrome || isEdge || isOpera) {
        // Media Stream Recording API has not been implemented in chrome yet;
        // That's why using WebAudio API to record stereo audio in WAV format
        recorder = StereoAudioRecorder;
    }

    if (typeof MediaRecorder !== 'undefined' && 'requestData' in MediaRecorder.prototype && !isChrome) {
        recorder = MediaStreamRecorder;
    }

    // video recorder (in WebM format)
    if (config.type === 'video' && (isChrome || isOpera)) {
        recorder = WhammyRecorder;

        if (typeof WebAssemblyRecorder !== 'undefined' && typeof ReadableStream !== 'undefined') {
            recorder = WebAssemblyRecorder;
        }
    }

    // video recorder (in Gif format)
    if (config.type === 'gif') {
        recorder = GifRecorder;
    }

    // html2canvas recording!
    if (config.type === 'canvas') {
        recorder = CanvasRecorder;
    }

    if (isMediaRecorderCompatible() && recorder !== CanvasRecorder && recorder !== GifRecorder && typeof MediaRecorder !== 'undefined' && 'requestData' in MediaRecorder.prototype) {
        if (getTracks(mediaStream, 'video').length || getTracks(mediaStream, 'audio').length) {
            // audio-only recording
            if (config.type === 'audio') {
                if (typeof MediaRecorder.isTypeSupported === 'function' && MediaRecorder.isTypeSupported('audio/webm')) {
                    recorder = MediaStreamRecorder;
                }
                // else recorder = StereoAudioRecorder;
            } else {
                // video or screen tracks
                if (typeof MediaRecorder.isTypeSupported === 'function' && MediaRecorder.isTypeSupported('video/webm')) {
                    recorder = MediaStreamRecorder;
                }
            }
        }
    }

    if (mediaStream instanceof Array && mediaStream.length) {
        recorder = MultiStreamRecorder;
    }

    if (config.recorderType) {
        recorder = config.recorderType;
    }

    if (!config.disableLogs && !!recorder && !!recorder.name) {
        console.log('Using recorderType:', recorder.name || recorder.constructor.name);
    }

    if (!recorder && isSafari) {
        recorder = MediaStreamRecorder;
    }

    return recorder;
}

// _____________
// MRecordRTC.js

/**
 * MRecordRTC runs on top of {@link RecordRTC} to bring multiple recordings in a single place, by providing simple API.
 * @summary MRecordRTC stands for "Multiple-RecordRTC".
 * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
 * @author {@link https://MuazKhan.com|Muaz Khan}
 * @typedef MRecordRTC
 * @class
 * @example
 * var recorder = new MRecordRTC();
 * recorder.addStream(MediaStream);
 * recorder.mediaType = {
 *     audio: true, // or StereoAudioRecorder or MediaStreamRecorder
 *     video: true, // or WhammyRecorder or MediaStreamRecorder or WebAssemblyRecorder or CanvasRecorder
 *     gif: true    // or GifRecorder
 * };
 * // mimeType is optional and should be set only in advance cases.
 * recorder.mimeType = {
 *     audio: 'audio/wav',
 *     video: 'video/webm',
 *     gif:   'image/gif'
 * };
 * recorder.startRecording();
 * @see For further information:
 * @see {@link https://github.com/muaz-khan/RecordRTC/tree/master/MRecordRTC|MRecordRTC Source Code}
 * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
 * @requires {@link RecordRTC}
 */

function MRecordRTC(mediaStream) {

    /**
     * This method attaches MediaStream object to {@link MRecordRTC}.
     * @param {MediaStream} mediaStream - A MediaStream object, either fetched using getUserMedia API, or generated using captureStreamUntilEnded or WebAudio API.
     * @method
     * @memberof MRecordRTC
     * @example
     * recorder.addStream(MediaStream);
     */
    this.addStream = function(_mediaStream) {
        if (_mediaStream) {
            mediaStream = _mediaStream;
        }
    };

    /**
     * This property can be used to set the recording type e.g. audio, or video, or gif, or canvas.
     * @property {object} mediaType - {audio: true, video: true, gif: true}
     * @memberof MRecordRTC
     * @example
     * var recorder = new MRecordRTC();
     * recorder.mediaType = {
     *     audio: true, // TRUE or StereoAudioRecorder or MediaStreamRecorder
     *     video: true, // TRUE or WhammyRecorder or MediaStreamRecorder or WebAssemblyRecorder or CanvasRecorder
     *     gif  : true  // TRUE or GifRecorder
     * };
     */
    this.mediaType = {
        audio: true,
        video: true
    };

    /**
     * This method starts recording.
     * @method
     * @memberof MRecordRTC
     * @example
     * recorder.startRecording();
     */
    this.startRecording = function() {
        var mediaType = this.mediaType;
        var recorderType;
        var mimeType = this.mimeType || {
            audio: null,
            video: null,
            gif: null
        };

        if (typeof mediaType.audio !== 'function' && isMediaRecorderCompatible() && !getTracks(mediaStream, 'audio').length) {
            mediaType.audio = false;
        }

        if (typeof mediaType.video !== 'function' && isMediaRecorderCompatible() && !getTracks(mediaStream, 'video').length) {
            mediaType.video = false;
        }

        if (typeof mediaType.gif !== 'function' && isMediaRecorderCompatible() && !getTracks(mediaStream, 'video').length) {
            mediaType.gif = false;
        }

        if (!mediaType.audio && !mediaType.video && !mediaType.gif) {
            throw 'MediaStream must have either audio or video tracks.';
        }

        if (!!mediaType.audio) {
            recorderType = null;
            if (typeof mediaType.audio === 'function') {
                recorderType = mediaType.audio;
            }

            this.audioRecorder = new RecordRTC(mediaStream, {
                type: 'audio',
                bufferSize: this.bufferSize,
                sampleRate: this.sampleRate,
                numberOfAudioChannels: this.numberOfAudioChannels || 2,
                disableLogs: this.disableLogs,
                recorderType: recorderType,
                mimeType: mimeType.audio,
                timeSlice: this.timeSlice,
                onTimeStamp: this.onTimeStamp
            });

            if (!mediaType.video) {
                this.audioRecorder.startRecording();
            }
        }

        if (!!mediaType.video) {
            recorderType = null;
            if (typeof mediaType.video === 'function') {
                recorderType = mediaType.video;
            }

            var newStream = mediaStream;

            if (isMediaRecorderCompatible() && !!mediaType.audio && typeof mediaType.audio === 'function') {
                var videoTrack = getTracks(mediaStream, 'video')[0];

                if (isFirefox) {
                    newStream = new MediaStream();
                    newStream.addTrack(videoTrack);

                    if (recorderType && recorderType === WhammyRecorder) {
                        // Firefox does NOT supports webp-encoding yet
                        // But Firefox do supports WebAssemblyRecorder
                        recorderType = MediaStreamRecorder;
                    }
                } else {
                    newStream = new MediaStream();
                    newStream.addTrack(videoTrack);
                }
            }

            this.videoRecorder = new RecordRTC(newStream, {
                type: 'video',
                video: this.video,
                canvas: this.canvas,
                frameInterval: this.frameInterval || 10,
                disableLogs: this.disableLogs,
                recorderType: recorderType,
                mimeType: mimeType.video,
                timeSlice: this.timeSlice,
                onTimeStamp: this.onTimeStamp,
                workerPath: this.workerPath,
                webAssemblyPath: this.webAssemblyPath,
                frameRate: this.frameRate, // used by WebAssemblyRecorder; values: usually 30; accepts any.
                bitrate: this.bitrate // used by WebAssemblyRecorder; values: 0 to 1000+
            });

            if (!mediaType.audio) {
                this.videoRecorder.startRecording();
            }
        }

        if (!!mediaType.audio && !!mediaType.video) {
            var self = this;

            var isSingleRecorder = isMediaRecorderCompatible() === true;

            if (mediaType.audio instanceof StereoAudioRecorder && !!mediaType.video) {
                isSingleRecorder = false;
            } else if (mediaType.audio !== true && mediaType.video !== true && mediaType.audio !== mediaType.video) {
                isSingleRecorder = false;
            }

            if (isSingleRecorder === true) {
                self.audioRecorder = null;
                self.videoRecorder.startRecording();
            } else {
                self.videoRecorder.initRecorder(function() {
                    self.audioRecorder.initRecorder(function() {
                        // Both recorders are ready to record things accurately
                        self.videoRecorder.startRecording();
                        self.audioRecorder.startRecording();
                    });
                });
            }
        }

        if (!!mediaType.gif) {
            recorderType = null;
            if (typeof mediaType.gif === 'function') {
                recorderType = mediaType.gif;
            }
            this.gifRecorder = new RecordRTC(mediaStream, {
                type: 'gif',
                frameRate: this.frameRate || 200,
                quality: this.quality || 10,
                disableLogs: this.disableLogs,
                recorderType: recorderType,
                mimeType: mimeType.gif
            });
            this.gifRecorder.startRecording();
        }
    };

    /**
     * This method stops recording.
     * @param {function} callback - Callback function is invoked when all encoders finished their jobs.
     * @method
     * @memberof MRecordRTC
     * @example
     * recorder.stopRecording(function(recording){
     *     var audioBlob = recording.audio;
     *     var videoBlob = recording.video;
     *     var gifBlob   = recording.gif;
     * });
     */
    this.stopRecording = function(callback) {
        callback = callback || function() {};

        if (this.audioRecorder) {
            this.audioRecorder.stopRecording(function(blobURL) {
                callback(blobURL, 'audio');
            });
        }

        if (this.videoRecorder) {
            this.videoRecorder.stopRecording(function(blobURL) {
                callback(blobURL, 'video');
            });
        }

        if (this.gifRecorder) {
            this.gifRecorder.stopRecording(function(blobURL) {
                callback(blobURL, 'gif');
            });
        }
    };

    /**
     * This method pauses recording.
     * @method
     * @memberof MRecordRTC
     * @example
     * recorder.pauseRecording();
     */
    this.pauseRecording = function() {
        if (this.audioRecorder) {
            this.audioRecorder.pauseRecording();
        }

        if (this.videoRecorder) {
            this.videoRecorder.pauseRecording();
        }

        if (this.gifRecorder) {
            this.gifRecorder.pauseRecording();
        }
    };

    /**
     * This method resumes recording.
     * @method
     * @memberof MRecordRTC
     * @example
     * recorder.resumeRecording();
     */
    this.resumeRecording = function() {
        if (this.audioRecorder) {
            this.audioRecorder.resumeRecording();
        }

        if (this.videoRecorder) {
            this.videoRecorder.resumeRecording();
        }

        if (this.gifRecorder) {
            this.gifRecorder.resumeRecording();
        }
    };

    /**
     * This method can be used to manually get all recorded blobs.
     * @param {function} callback - All recorded blobs are passed back to the "callback" function.
     * @method
     * @memberof MRecordRTC
     * @example
     * recorder.getBlob(function(recording){
     *     var audioBlob = recording.audio;
     *     var videoBlob = recording.video;
     *     var gifBlob   = recording.gif;
     * });
     * // or
     * var audioBlob = recorder.getBlob().audio;
     * var videoBlob = recorder.getBlob().video;
     */
    this.getBlob = function(callback) {
        var output = {};

        if (this.audioRecorder) {
            output.audio = this.audioRecorder.getBlob();
        }

        if (this.videoRecorder) {
            output.video = this.videoRecorder.getBlob();
        }

        if (this.gifRecorder) {
            output.gif = this.gifRecorder.getBlob();
        }

        if (callback) {
            callback(output);
        }

        return output;
    };

    /**
     * Destroy all recorder instances.
     * @method
     * @memberof MRecordRTC
     * @example
     * recorder.destroy();
     */
    this.destroy = function() {
        if (this.audioRecorder) {
            this.audioRecorder.destroy();
            this.audioRecorder = null;
        }

        if (this.videoRecorder) {
            this.videoRecorder.destroy();
            this.videoRecorder = null;
        }

        if (this.gifRecorder) {
            this.gifRecorder.destroy();
            this.gifRecorder = null;
        }
    };

    /**
     * This method can be used to manually get all recorded blobs' DataURLs.
     * @param {function} callback - All recorded blobs' DataURLs are passed back to the "callback" function.
     * @method
     * @memberof MRecordRTC
     * @example
     * recorder.getDataURL(function(recording){
     *     var audioDataURL = recording.audio;
     *     var videoDataURL = recording.video;
     *     var gifDataURL   = recording.gif;
     * });
     */
    this.getDataURL = function(callback) {
        this.getBlob(function(blob) {
            if (blob.audio && blob.video) {
                getDataURL(blob.audio, function(_audioDataURL) {
                    getDataURL(blob.video, function(_videoDataURL) {
                        callback({
                            audio: _audioDataURL,
                            video: _videoDataURL
                        });
                    });
                });
            } else if (blob.audio) {
                getDataURL(blob.audio, function(_audioDataURL) {
                    callback({
                        audio: _audioDataURL
                    });
                });
            } else if (blob.video) {
                getDataURL(blob.video, function(_videoDataURL) {
                    callback({
                        video: _videoDataURL
                    });
                });
            }
        });

        function getDataURL(blob, callback00) {
            if (typeof Worker !== 'undefined') {
                var webWorker = processInWebWorker(function readFile(_blob) {
                    postMessage(new FileReaderSync().readAsDataURL(_blob));
                });

                webWorker.onmessage = function(event) {
                    callback00(event.data);
                };

                webWorker.postMessage(blob);
            } else {
                var reader = new FileReader();
                reader.readAsDataURL(blob);
                reader.onload = function(event) {
                    callback00(event.target.result);
                };
            }
        }

        function processInWebWorker(_function) {
            var blob = URL.createObjectURL(new Blob([_function.toString(),
                'this.onmessage =  function (eee) {' + _function.name + '(eee.data);}'
            ], {
                type: 'application/javascript'
            }));

            var worker = new Worker(blob);
            var url;
            if (typeof URL !== 'undefined') {
                url = URL;
            } else if (typeof webkitURL !== 'undefined') {
                url = webkitURL;
            } else {
                throw 'Neither URL nor webkitURL detected.';
            }
            url.revokeObjectURL(blob);
            return worker;
        }
    };

    /**
     * This method can be used to ask {@link MRecordRTC} to write all recorded blobs into IndexedDB storage.
     * @method
     * @memberof MRecordRTC
     * @example
     * recorder.writeToDisk();
     */
    this.writeToDisk = function() {
        RecordRTC.writeToDisk({
            audio: this.audioRecorder,
            video: this.videoRecorder,
            gif: this.gifRecorder
        });
    };

    /**
     * This method can be used to invoke a save-as dialog for all recorded blobs.
     * @param {object} args - {audio: 'audio-name', video: 'video-name', gif: 'gif-name'}
     * @method
     * @memberof MRecordRTC
     * @example
     * recorder.save({
     *     audio: 'audio-file-name',
     *     video: 'video-file-name',
     *     gif  : 'gif-file-name'
     * });
     */
    this.save = function(args) {
        args = args || {
            audio: true,
            video: true,
            gif: true
        };

        if (!!args.audio && this.audioRecorder) {
            this.audioRecorder.save(typeof args.audio === 'string' ? args.audio : '');
        }

        if (!!args.video && this.videoRecorder) {
            this.videoRecorder.save(typeof args.video === 'string' ? args.video : '');
        }
        if (!!args.gif && this.gifRecorder) {
            this.gifRecorder.save(typeof args.gif === 'string' ? args.gif : '');
        }
    };
}

/**
 * This method can be used to get all recorded blobs from IndexedDB storage.
 * @param {string} type - 'all' or 'audio' or 'video' or 'gif'
 * @param {function} callback - Callback function to get all stored blobs.
 * @method
 * @memberof MRecordRTC
 * @example
 * MRecordRTC.getFromDisk('all', function(dataURL, type){
 *     if(type === 'audio') { }
 *     if(type === 'video') { }
 *     if(type === 'gif')   { }
 * });
 */
MRecordRTC.getFromDisk = RecordRTC.getFromDisk;

/**
 * This method can be used to store recorded blobs into IndexedDB storage.
 * @param {object} options - {audio: Blob, video: Blob, gif: Blob}
 * @method
 * @memberof MRecordRTC
 * @example
 * MRecordRTC.writeToDisk({
 *     audio: audioBlob,
 *     video: videoBlob,
 *     gif  : gifBlob
 * });
 */
MRecordRTC.writeToDisk = RecordRTC.writeToDisk;

if (typeof RecordRTC !== 'undefined') {
    RecordRTC.MRecordRTC = MRecordRTC;
}

var browserFakeUserAgent = 'Fake/5.0 (FakeOS) AppleWebKit/123 (KHTML, like Gecko) Fake/12.3.4567.89 Fake/123.45';

(function(that) {
    if (!that) {
        return;
    }

    if (typeof window !== 'undefined') {
        return;
    }

    if (typeof global === 'undefined') {
        return;
    }

    global.navigator = {
        userAgent: browserFakeUserAgent,
        getUserMedia: function() {}
    };

    if (!global.console) {
        global.console = {};
    }

    if (typeof global.console.log === 'undefined' || typeof global.console.error === 'undefined') {
        global.console.error = global.console.log = global.console.log || function() {
            console.log(arguments);
        };
    }

    if (typeof document === 'undefined') {
        /*global document:true */
        that.document = {
            documentElement: {
                appendChild: function() {
                    return '';
                }
            }
        };

        document.createElement = document.captureStream = document.mozCaptureStream = function() {
            var obj = {
                getContext: function() {
                    return obj;
                },
                play: function() {},
                pause: function() {},
                drawImage: function() {},
                toDataURL: function() {
                    return '';
                },
                style: {}
            };
            return obj;
        };

        that.HTMLVideoElement = function() {};
    }

    if (typeof location === 'undefined') {
        /*global location:true */
        that.location = {
            protocol: 'file:',
            href: '',
            hash: ''
        };
    }

    if (typeof screen === 'undefined') {
        /*global screen:true */
        that.screen = {
            width: 0,
            height: 0
        };
    }

    if (typeof URL === 'undefined') {
        /*global screen:true */
        that.URL = {
            createObjectURL: function() {
                return '';
            },
            revokeObjectURL: function() {
                return '';
            }
        };
    }

    /*global window:true */
    that.window = global;
})(typeof global !== 'undefined' ? global : null);

// _____________________________
// Cross-Browser-Declarations.js

// animation-frame used in WebM recording

/*jshint -W079 */
var requestAnimationFrame = window.requestAnimationFrame;
if (typeof requestAnimationFrame === 'undefined') {
    if (typeof webkitRequestAnimationFrame !== 'undefined') {
        /*global requestAnimationFrame:true */
        requestAnimationFrame = webkitRequestAnimationFrame;
    } else if (typeof mozRequestAnimationFrame !== 'undefined') {
        /*global requestAnimationFrame:true */
        requestAnimationFrame = mozRequestAnimationFrame;
    } else if (typeof msRequestAnimationFrame !== 'undefined') {
        /*global requestAnimationFrame:true */
        requestAnimationFrame = msRequestAnimationFrame;
    } else if (typeof requestAnimationFrame === 'undefined') {
        // via: https://gist.github.com/paulirish/1579671
        var lastTime = 0;

        /*global requestAnimationFrame:true */
        requestAnimationFrame = function(callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = setTimeout(function() {
                callback(currTime + timeToCall);
            }, timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };
    }
}

/*jshint -W079 */
var cancelAnimationFrame = window.cancelAnimationFrame;
if (typeof cancelAnimationFrame === 'undefined') {
    if (typeof webkitCancelAnimationFrame !== 'undefined') {
        /*global cancelAnimationFrame:true */
        cancelAnimationFrame = webkitCancelAnimationFrame;
    } else if (typeof mozCancelAnimationFrame !== 'undefined') {
        /*global cancelAnimationFrame:true */
        cancelAnimationFrame = mozCancelAnimationFrame;
    } else if (typeof msCancelAnimationFrame !== 'undefined') {
        /*global cancelAnimationFrame:true */
        cancelAnimationFrame = msCancelAnimationFrame;
    } else if (typeof cancelAnimationFrame === 'undefined') {
        /*global cancelAnimationFrame:true */
        cancelAnimationFrame = function(id) {
            clearTimeout(id);
        };
    }
}

// WebAudio API representer
var AudioContext = window.AudioContext;

if (typeof AudioContext === 'undefined') {
    if (typeof webkitAudioContext !== 'undefined') {
        /*global AudioContext:true */
        AudioContext = webkitAudioContext;
    }

    if (typeof mozAudioContext !== 'undefined') {
        /*global AudioContext:true */
        AudioContext = mozAudioContext;
    }
}

/*jshint -W079 */
var URL = window.URL;

if (typeof URL === 'undefined' && typeof webkitURL !== 'undefined') {
    /*global URL:true */
    URL = webkitURL;
}

if (typeof navigator !== 'undefined' && typeof navigator.getUserMedia === 'undefined') { // maybe window.navigator?
    if (typeof navigator.webkitGetUserMedia !== 'undefined') {
        navigator.getUserMedia = navigator.webkitGetUserMedia;
    }

    if (typeof navigator.mozGetUserMedia !== 'undefined') {
        navigator.getUserMedia = navigator.mozGetUserMedia;
    }
}

var isEdge = navigator.userAgent.indexOf('Edge') !== -1 && (!!navigator.msSaveBlob || !!navigator.msSaveOrOpenBlob);
var isOpera = !!window.opera || navigator.userAgent.indexOf('OPR/') !== -1;
var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1 && ('netscape' in window) && / rv:/.test(navigator.userAgent);
var isChrome = (!isOpera && !isEdge && !!navigator.webkitGetUserMedia) || isElectron() || navigator.userAgent.toLowerCase().indexOf('chrome/') !== -1;

var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);

if (isSafari && !isChrome && navigator.userAgent.indexOf('CriOS') !== -1) {
    isSafari = false;
    isChrome = true;
}

var MediaStream = window.MediaStream;

if (typeof MediaStream === 'undefined' && typeof webkitMediaStream !== 'undefined') {
    MediaStream = webkitMediaStream;
}

/*global MediaStream:true */
if (typeof MediaStream !== 'undefined') {
    // override "stop" method for all browsers
    if (typeof MediaStream.prototype.stop === 'undefined') {
        MediaStream.prototype.stop = function() {
            this.getTracks().forEach(function(track) {
                track.stop();
            });
        };
    }
}

// below function via: http://goo.gl/B3ae8c
/**
 * Return human-readable file size.
 * @param {number} bytes - Pass bytes and get formatted string.
 * @returns {string} - formatted string
 * @example
 * bytesToSize(1024*1024*5) === '5 GB'
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 */
function bytesToSize(bytes) {
    var k = 1000;
    var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    if (bytes === 0) {
        return '0 Bytes';
    }
    var i = parseInt(Math.floor(Math.log(bytes) / Math.log(k)), 10);
    return (bytes / Math.pow(k, i)).toPrecision(3) + ' ' + sizes[i];
}

/**
 * @param {Blob} file - File or Blob object. This parameter is required.
 * @param {string} fileName - Optional file name e.g. "Recorded-Video.webm"
 * @example
 * invokeSaveAsDialog(blob or file, [optional] fileName);
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 */
function invokeSaveAsDialog(file, fileName) {
    if (!file) {
        throw 'Blob object is required.';
    }

    if (!file.type) {
        try {
            file.type = 'video/webm';
        } catch (e) {}
    }

    var fileExtension = (file.type || 'video/webm').split('/')[1];
    if (fileExtension.indexOf(';') !== -1) {
        // extended mimetype, e.g. 'video/webm;codecs=vp8,opus'
        fileExtension = fileExtension.split(';')[0];
    }
    if (fileName && fileName.indexOf('.') !== -1) {
        var splitted = fileName.split('.');
        fileName = splitted[0];
        fileExtension = splitted[1];
    }

    var fileFullName = (fileName || (Math.round(Math.random() * 9999999999) + 888888888)) + '.' + fileExtension;

    if (typeof navigator.msSaveOrOpenBlob !== 'undefined') {
        return navigator.msSaveOrOpenBlob(file, fileFullName);
    } else if (typeof navigator.msSaveBlob !== 'undefined') {
        return navigator.msSaveBlob(file, fileFullName);
    }

    var hyperlink = document.createElement('a');
    hyperlink.href = URL.createObjectURL(file);
    hyperlink.download = fileFullName;

    hyperlink.style = 'display:none;opacity:0;color:transparent;';
    (document.body || document.documentElement).appendChild(hyperlink);

    if (typeof hyperlink.click === 'function') {
        hyperlink.click();
    } else {
        hyperlink.target = '_blank';
        hyperlink.dispatchEvent(new MouseEvent('click', {
            view: window,
            bubbles: true,
            cancelable: true
        }));
    }

    URL.revokeObjectURL(hyperlink.href);
}

/**
 * from: https://github.com/cheton/is-electron/blob/master/index.js
 **/
function isElectron() {
    // Renderer process
    if (typeof window !== 'undefined' && typeof window.process === 'object' && window.process.type === 'renderer') {
        return true;
    }

    // Main process
    if (typeof process !== 'undefined' && typeof process.versions === 'object' && !!process.versions.electron) {
        return true;
    }

    // Detect the user agent when the `nodeIntegration` option is set to true
    if (typeof navigator === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent.indexOf('Electron') >= 0) {
        return true;
    }

    return false;
}

function getTracks(stream, kind) {
    if (!stream || !stream.getTracks) {
        return [];
    }

    return stream.getTracks().filter(function(t) {
        return t.kind === (kind || 'audio');
    });
}

function setSrcObject(stream, element) {
    if ('srcObject' in element) {
        element.srcObject = stream;
    } else if ('mozSrcObject' in element) {
        element.mozSrcObject = stream;
    } else {
        element.srcObject = stream;
    }
}

/**
 * @param {Blob} file - File or Blob object.
 * @param {function} callback - Callback function.
 * @example
 * getSeekableBlob(blob or file, callback);
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 */
function getSeekableBlob(inputBlob, callback) {
    // EBML.js copyrights goes to: https://github.com/legokichi/ts-ebml
    if (typeof EBML === 'undefined') {
        throw new Error('Please link: https://www.webrtc-experiment.com/EBML.js');
    }

    var reader = new EBML.Reader();
    var decoder = new EBML.Decoder();
    var tools = EBML.tools;

    var fileReader = new FileReader();
    fileReader.onload = function(e) {
        var ebmlElms = decoder.decode(this.result);
        ebmlElms.forEach(function(element) {
            reader.read(element);
        });
        reader.stop();
        var refinedMetadataBuf = tools.makeMetadataSeekable(reader.metadatas, reader.duration, reader.cues);
        var body = this.result.slice(reader.metadataSize);
        var newBlob = new Blob([refinedMetadataBuf, body], {
            type: 'video/webm'
        });

        callback(newBlob);
    };
    fileReader.readAsArrayBuffer(inputBlob);
}

if (typeof RecordRTC !== 'undefined') {
    RecordRTC.invokeSaveAsDialog = invokeSaveAsDialog;
    RecordRTC.getTracks = getTracks;
    RecordRTC.getSeekableBlob = getSeekableBlob;
    RecordRTC.bytesToSize = bytesToSize;
    RecordRTC.isElectron = isElectron;
}

// __________ (used to handle stuff like http://goo.gl/xmE5eg) issue #129
// Storage.js

/**
 * Storage is a standalone object used by {@link RecordRTC} to store reusable objects e.g. "new AudioContext".
 * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
 * @author {@link https://MuazKhan.com|Muaz Khan}
 * @example
 * Storage.AudioContext === webkitAudioContext
 * @property {webkitAudioContext} AudioContext - Keeps a reference to AudioContext object.
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 */

var Storage = {};

if (typeof AudioContext !== 'undefined') {
    Storage.AudioContext = AudioContext;
} else if (typeof webkitAudioContext !== 'undefined') {
    Storage.AudioContext = webkitAudioContext;
}

if (typeof RecordRTC !== 'undefined') {
    RecordRTC.Storage = Storage;
}

function isMediaRecorderCompatible() {
    if (isFirefox || isSafari || isEdge) {
        return true;
    }

    var nVer = navigator.appVersion;
    var nAgt = navigator.userAgent;
    var fullVersion = '' + parseFloat(navigator.appVersion);
    var majorVersion = parseInt(navigator.appVersion, 10);
    var nameOffset, verOffset, ix;

    if (isChrome || isOpera) {
        verOffset = nAgt.indexOf('Chrome');
        fullVersion = nAgt.substring(verOffset + 7);
    }

    // trim the fullVersion string at semicolon/space if present
    if ((ix = fullVersion.indexOf(';')) !== -1) {
        fullVersion = fullVersion.substring(0, ix);
    }

    if ((ix = fullVersion.indexOf(' ')) !== -1) {
        fullVersion = fullVersion.substring(0, ix);
    }

    majorVersion = parseInt('' + fullVersion, 10);

    if (isNaN(majorVersion)) {
        fullVersion = '' + parseFloat(navigator.appVersion);
        majorVersion = parseInt(navigator.appVersion, 10);
    }

    return majorVersion >= 49;
}

// ______________________
// MediaStreamRecorder.js

/**
 * MediaStreamRecorder is an abstraction layer for {@link https://w3c.github.io/mediacapture-record/MediaRecorder.html|MediaRecorder API}. It is used by {@link RecordRTC} to record MediaStream(s) in both Chrome and Firefox.
 * @summary Runs top over {@link https://w3c.github.io/mediacapture-record/MediaRecorder.html|MediaRecorder API}.
 * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
 * @author {@link https://github.com/muaz-khan|Muaz Khan}
 * @typedef MediaStreamRecorder
 * @class
 * @example
 * var config = {
 *     mimeType: 'video/webm', // vp8, vp9, h264, mkv, opus/vorbis
 *     audioBitsPerSecond : 256 * 8 * 1024,
 *     videoBitsPerSecond : 256 * 8 * 1024,
 *     bitsPerSecond: 256 * 8 * 1024,  // if this is provided, skip above two
 *     checkForInactiveTracks: true,
 *     timeSlice: 1000, // concatenate intervals based blobs
 *     ondataavailable: function() {} // get intervals based blobs
 * }
 * var recorder = new MediaStreamRecorder(mediaStream, config);
 * recorder.record();
 * recorder.stop(function(blob) {
 *     video.src = URL.createObjectURL(blob);
 *
 *     // or
 *     var blob = recorder.blob;
 * });
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
 * @param {object} config - {disableLogs:true, initCallback: function, mimeType: "video/webm", timeSlice: 1000}
 * @throws Will throw an error if first argument "MediaStream" is missing. Also throws error if "MediaRecorder API" are not supported by the browser.
 */

function MediaStreamRecorder(mediaStream, config) {
    var self = this;

    if (typeof mediaStream === 'undefined') {
        throw 'First argument "MediaStream" is required.';
    }

    if (typeof MediaRecorder === 'undefined') {
        throw 'Your browser does not support the Media Recorder API. Please try other modules e.g. WhammyRecorder or StereoAudioRecorder.';
    }

    config = config || {
        // bitsPerSecond: 256 * 8 * 1024,
        mimeType: 'video/webm'
    };

    if (config.type === 'audio') {
        if (getTracks(mediaStream, 'video').length && getTracks(mediaStream, 'audio').length) {
            var stream;
            if (!!navigator.mozGetUserMedia) {
                stream = new MediaStream();
                stream.addTrack(getTracks(mediaStream, 'audio')[0]);
            } else {
                // webkitMediaStream
                stream = new MediaStream(getTracks(mediaStream, 'audio'));
            }
            mediaStream = stream;
        }

        if (!config.mimeType || config.mimeType.toString().toLowerCase().indexOf('audio') === -1) {
            config.mimeType = isChrome ? 'audio/webm' : 'audio/ogg';
        }

        if (config.mimeType && config.mimeType.toString().toLowerCase() !== 'audio/ogg' && !!navigator.mozGetUserMedia) {
            // forcing better codecs on Firefox (via #166)
            config.mimeType = 'audio/ogg';
        }
    }

    var arrayOfBlobs = [];

    /**
     * This method returns array of blobs. Use only with "timeSlice". Its useful to preview recording anytime, without using the "stop" method.
     * @method
     * @memberof MediaStreamRecorder
     * @example
     * var arrayOfBlobs = recorder.getArrayOfBlobs();
     * @returns {Array} Returns array of recorded blobs.
     */
    this.getArrayOfBlobs = function() {
        return arrayOfBlobs;
    };

    /**
     * This method records MediaStream.
     * @method
     * @memberof MediaStreamRecorder
     * @example
     * recorder.record();
     */
    this.record = function() {
        // set defaults
        self.blob = null;
        self.clearRecordedData();
        self.timestamps = [];
        allStates = [];
        arrayOfBlobs = [];

        var recorderHints = config;

        if (!config.disableLogs) {
            console.log('Passing following config over MediaRecorder API.', recorderHints);
        }

        if (mediaRecorder) {
            // mandatory to make sure Firefox doesn't fails to record streams 3-4 times without reloading the page.
            mediaRecorder = null;
        }

        if (isChrome && !isMediaRecorderCompatible()) {
            // to support video-only recording on stable
            recorderHints = 'video/vp8';
        }

        if (typeof MediaRecorder.isTypeSupported === 'function' && recorderHints.mimeType) {
            if (!MediaRecorder.isTypeSupported(recorderHints.mimeType)) {
                if (!config.disableLogs) {
                    console.warn('MediaRecorder API seems unable to record mimeType:', recorderHints.mimeType);
                }

                recorderHints.mimeType = config.type === 'audio' ? 'audio/webm' : 'video/webm';
            }
        }

        // using MediaRecorder API here
        try {
            mediaRecorder = new MediaRecorder(mediaStream, recorderHints);

            // reset
            config.mimeType = recorderHints.mimeType;
        } catch (e) {
            // chrome-based fallback
            mediaRecorder = new MediaRecorder(mediaStream);
        }

        // old hack?
        if (recorderHints.mimeType && !MediaRecorder.isTypeSupported && 'canRecordMimeType' in mediaRecorder && mediaRecorder.canRecordMimeType(recorderHints.mimeType) === false) {
            if (!config.disableLogs) {
                console.warn('MediaRecorder API seems unable to record mimeType:', recorderHints.mimeType);
            }
        }

        // Dispatching OnDataAvailable Handler
        mediaRecorder.ondataavailable = function(e) {
            if (e.data) {
                allStates.push('ondataavailable: ' + bytesToSize(e.data.size));
            }

            if (typeof config.timeSlice === 'number') {
                if (e.data && e.data.size) {
                    arrayOfBlobs.push(e.data);
                    updateTimeStamp();

                    if (typeof config.ondataavailable === 'function') {
                        // intervals based blobs
                        var blob = config.getNativeBlob ? e.data : new Blob([e.data], {
                            type: getMimeType(recorderHints)
                        });
                        config.ondataavailable(blob);
                    }
                }
                return;
            }

            if (!e.data || !e.data.size || e.data.size < 100 || self.blob) {
                // make sure that stopRecording always getting fired
                // even if there is invalid data
                if (self.recordingCallback) {
                    self.recordingCallback(new Blob([], {
                        type: getMimeType(recorderHints)
                    }));
                    self.recordingCallback = null;
                }
                return;
            }

            self.blob = config.getNativeBlob ? e.data : new Blob([e.data], {
                type: getMimeType(recorderHints)
            });

            if (self.recordingCallback) {
                self.recordingCallback(self.blob);
                self.recordingCallback = null;
            }
        };

        mediaRecorder.onstart = function() {
            allStates.push('started');
        };

        mediaRecorder.onpause = function() {
            allStates.push('paused');
        };

        mediaRecorder.onresume = function() {
            allStates.push('resumed');
        };

        mediaRecorder.onstop = function() {
            allStates.push('stopped');
        };

        mediaRecorder.onerror = function(error) {
            if (!error) {
                return;
            }

            if (!error.name) {
                error.name = 'UnknownError';
            }

            allStates.push('error: ' + error);

            if (!config.disableLogs) {
                // via: https://w3c.github.io/mediacapture-record/MediaRecorder.html#exception-summary
                if (error.name.toString().toLowerCase().indexOf('invalidstate') !== -1) {
                    console.error('The MediaRecorder is not in a state in which the proposed operation is allowed to be executed.', error);
                } else if (error.name.toString().toLowerCase().indexOf('notsupported') !== -1) {
                    console.error('MIME type (', recorderHints.mimeType, ') is not supported.', error);
                } else if (error.name.toString().toLowerCase().indexOf('security') !== -1) {
                    console.error('MediaRecorder security error', error);
                }

                // older code below
                else if (error.name === 'OutOfMemory') {
                    console.error('The UA has exhaused the available memory. User agents SHOULD provide as much additional information as possible in the message attribute.', error);
                } else if (error.name === 'IllegalStreamModification') {
                    console.error('A modification to the stream has occurred that makes it impossible to continue recording. An example would be the addition of a Track while recording is occurring. User agents SHOULD provide as much additional information as possible in the message attribute.', error);
                } else if (error.name === 'OtherRecordingError') {
                    console.error('Used for an fatal error other than those listed above. User agents SHOULD provide as much additional information as possible in the message attribute.', error);
                } else if (error.name === 'GenericError') {
                    console.error('The UA cannot provide the codec or recording option that has been requested.', error);
                } else {
                    console.error('MediaRecorder Error', error);
                }
            }

            (function(looper) {
                if (!self.manuallyStopped && mediaRecorder && mediaRecorder.state === 'inactive') {
                    delete config.timeslice;

                    // 10 minutes, enough?
                    mediaRecorder.start(10 * 60 * 1000);
                    return;
                }

                setTimeout(looper, 1000);
            })();

            if (mediaRecorder.state !== 'inactive' && mediaRecorder.state !== 'stopped') {
                mediaRecorder.stop();
            }
        };

        if (typeof config.timeSlice === 'number') {
            updateTimeStamp();
            mediaRecorder.start(config.timeSlice);
        } else {
            // default is 60 minutes; enough?
            // use config => {timeSlice: 1000} otherwise

            mediaRecorder.start(3.6e+6);
        }

        if (config.initCallback) {
            config.initCallback(); // old code
        }
    };

    /**
     * @property {Array} timestamps - Array of time stamps
     * @memberof MediaStreamRecorder
     * @example
     * console.log(recorder.timestamps);
     */
    this.timestamps = [];

    function updateTimeStamp() {
        self.timestamps.push(new Date().getTime());

        if (typeof config.onTimeStamp === 'function') {
            config.onTimeStamp(self.timestamps[self.timestamps.length - 1], self.timestamps);
        }
    }

    function getMimeType(secondObject) {
        if (mediaRecorder && mediaRecorder.mimeType) {
            return mediaRecorder.mimeType;
        }

        return secondObject.mimeType || 'video/webm';
    }

    /**
     * This method stops recording MediaStream.
     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.
     * @method
     * @memberof MediaStreamRecorder
     * @example
     * recorder.stop(function(blob) {
     *     video.src = URL.createObjectURL(blob);
     * });
     */
    this.stop = function(callback) {
        callback = callback || function() {};

        self.manuallyStopped = true; // used inside the mediaRecorder.onerror

        if (!mediaRecorder) {
            return;
        }

        this.recordingCallback = callback;

        if (mediaRecorder.state === 'recording') {
            mediaRecorder.stop();
        }

        if (typeof config.timeSlice === 'number') {
            setTimeout(function() {
                self.blob = new Blob(arrayOfBlobs, {
                    type: getMimeType(config)
                });

                self.recordingCallback(self.blob);
            }, 100);
        }
    };

    /**
     * This method pauses the recording process.
     * @method
     * @memberof MediaStreamRecorder
     * @example
     * recorder.pause();
     */
    this.pause = function() {
        if (!mediaRecorder) {
            return;
        }

        if (mediaRecorder.state === 'recording') {
            mediaRecorder.pause();
        }
    };

    /**
     * This method resumes the recording process.
     * @method
     * @memberof MediaStreamRecorder
     * @example
     * recorder.resume();
     */
    this.resume = function() {
        if (!mediaRecorder) {
            return;
        }

        if (mediaRecorder.state === 'paused') {
            mediaRecorder.resume();
        }
    };

    /**
     * This method resets currently recorded data.
     * @method
     * @memberof MediaStreamRecorder
     * @example
     * recorder.clearRecordedData();
     */
    this.clearRecordedData = function() {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
            self.stop(clearRecordedDataCB);
        }

        clearRecordedDataCB();
    };

    function clearRecordedDataCB() {
        arrayOfBlobs = [];
        mediaRecorder = null;
        self.timestamps = [];
    }

    // Reference to "MediaRecorder" object
    var mediaRecorder;

    /**
     * Access to native MediaRecorder API
     * @method
     * @memberof MediaStreamRecorder
     * @instance
     * @example
     * var internal = recorder.getInternalRecorder();
     * internal.ondataavailable = function() {}; // override
     * internal.stream, internal.onpause, internal.onstop, etc.
     * @returns {Object} Returns internal recording object.
     */
    this.getInternalRecorder = function() {
        return mediaRecorder;
    };

    function isMediaStreamActive() {
        if ('active' in mediaStream) {
            if (!mediaStream.active) {
                return false;
            }
        } else if ('ended' in mediaStream) { // old hack
            if (mediaStream.ended) {
                return false;
            }
        }
        return true;
    }

    /**
     * @property {Blob} blob - Recorded data as "Blob" object.
     * @memberof MediaStreamRecorder
     * @example
     * recorder.stop(function() {
     *     var blob = recorder.blob;
     * });
     */
    this.blob = null;


    /**
     * Get MediaRecorder readonly state.
     * @method
     * @memberof MediaStreamRecorder
     * @example
     * var state = recorder.getState();
     * @returns {String} Returns recording state.
     */
    this.getState = function() {
        if (!mediaRecorder) {
            return 'inactive';
        }

        return mediaRecorder.state || 'inactive';
    };

    // list of all recording states
    var allStates = [];

    /**
     * Get MediaRecorder all recording states.
     * @method
     * @memberof MediaStreamRecorder
     * @example
     * var state = recorder.getAllStates();
     * @returns {Array} Returns all recording states
     */
    this.getAllStates = function() {
        return allStates;
    };

    // if any Track within the MediaStream is muted or not enabled at any time, 
    // the browser will only record black frames 
    // or silence since that is the content produced by the Track
    // so we need to stopRecording as soon as any single track ends.
    if (typeof config.checkForInactiveTracks === 'undefined') {
        config.checkForInactiveTracks = false; // disable to minimize CPU usage
    }

    var self = this;

    // this method checks if media stream is stopped
    // or if any track is ended.
    (function looper() {
        if (!mediaRecorder || config.checkForInactiveTracks === false) {
            return;
        }

        if (isMediaStreamActive() === false) {
            if (!config.disableLogs) {
                console.log('MediaStream seems stopped.');
            }
            self.stop();
            return;
        }

        setTimeout(looper, 1000); // check every second
    })();

    // for debugging
    this.name = 'MediaStreamRecorder';
    this.toString = function() {
        return this.name;
    };
}

if (typeof RecordRTC !== 'undefined') {
    RecordRTC.MediaStreamRecorder = MediaStreamRecorder;
}

// source code from: http://typedarray.org/wp-content/projects/WebAudioRecorder/script.js
// https://github.com/mattdiamond/Recorderjs#license-mit
// ______________________
// StereoAudioRecorder.js

/**
 * StereoAudioRecorder is a standalone class used by {@link RecordRTC} to bring "stereo" audio-recording in chrome.
 * @summary JavaScript standalone object for stereo audio recording.
 * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
 * @author {@link https://MuazKhan.com|Muaz Khan}
 * @typedef StereoAudioRecorder
 * @class
 * @example
 * var recorder = new StereoAudioRecorder(MediaStream, {
 *     sampleRate: 44100,
 *     bufferSize: 4096
 * });
 * recorder.record();
 * recorder.stop(function(blob) {
 *     video.src = URL.createObjectURL(blob);
 * });
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
 * @param {object} config - {sampleRate: 44100, bufferSize: 4096, numberOfAudioChannels: 1, etc.}
 */

function StereoAudioRecorder(mediaStream, config) {
    if (!getTracks(mediaStream, 'audio').length) {
        throw 'Your stream has no audio tracks.';
    }

    config = config || {};

    var self = this;

    // variables
    var leftchannel = [];
    var rightchannel = [];
    var recording = false;
    var recordingLength = 0;
    var jsAudioNode;

    var numberOfAudioChannels = 2;

    /**
     * Set sample rates such as 8K or 16K. Reference: http://stackoverflow.com/a/28977136/552182
     * @property {number} desiredSampRate - Desired Bits per sample * 1000
     * @memberof StereoAudioRecorder
     * @instance
     * @example
     * var recorder = StereoAudioRecorder(mediaStream, {
     *   desiredSampRate: 16 * 1000 // bits-per-sample * 1000
     * });
     */
    var desiredSampRate = config.desiredSampRate;

    // backward compatibility
    if (config.leftChannel === true) {
        numberOfAudioChannels = 1;
    }

    if (config.numberOfAudioChannels === 1) {
        numberOfAudioChannels = 1;
    }

    if (!numberOfAudioChannels || numberOfAudioChannels < 1) {
        numberOfAudioChannels = 2;
    }

    if (!config.disableLogs) {
        console.log('StereoAudioRecorder is set to record number of channels: ' + numberOfAudioChannels);
    }

    // if any Track within the MediaStream is muted or not enabled at any time, 
    // the browser will only record black frames 
    // or silence since that is the content produced by the Track
    // so we need to stopRecording as soon as any single track ends.
    if (typeof config.checkForInactiveTracks === 'undefined') {
        config.checkForInactiveTracks = true;
    }

    function isMediaStreamActive() {
        if (config.checkForInactiveTracks === false) {
            // always return "true"
            return true;
        }

        if ('active' in mediaStream) {
            if (!mediaStream.active) {
                return false;
            }
        } else if ('ended' in mediaStream) { // old hack
            if (mediaStream.ended) {
                return false;
            }
        }
        return true;
    }

    /**
     * This method records MediaStream.
     * @method
     * @memberof StereoAudioRecorder
     * @example
     * recorder.record();
     */
    this.record = function() {
        if (isMediaStreamActive() === false) {
            throw 'Please make sure MediaStream is active.';
        }

        resetVariables();

        isAudioProcessStarted = isPaused = false;
        recording = true;

        if (typeof config.timeSlice !== 'undefined') {
            looper();
        }
    };

    function mergeLeftRightBuffers(config, callback) {
        function mergeAudioBuffers(config, cb) {
            var numberOfAudioChannels = config.numberOfAudioChannels;

            // todo: "slice(0)" --- is it causes loop? Should be removed?
            var leftBuffers = config.leftBuffers.slice(0);
            var rightBuffers = config.rightBuffers.slice(0);
            var sampleRate = config.sampleRate;
            var internalInterleavedLength = config.internalInterleavedLength;
            var desiredSampRate = config.desiredSampRate;

            if (numberOfAudioChannels === 2) {
                leftBuffers = mergeBuffers(leftBuffers, internalInterleavedLength);
                rightBuffers = mergeBuffers(rightBuffers, internalInterleavedLength);

                if (desiredSampRate) {
                    leftBuffers = interpolateArray(leftBuffers, desiredSampRate, sampleRate);
                    rightBuffers = interpolateArray(rightBuffers, desiredSampRate, sampleRate);
                }
            }

            if (numberOfAudioChannels === 1) {
                leftBuffers = mergeBuffers(leftBuffers, internalInterleavedLength);

                if (desiredSampRate) {
                    leftBuffers = interpolateArray(leftBuffers, desiredSampRate, sampleRate);
                }
            }

            // set sample rate as desired sample rate
            if (desiredSampRate) {
                sampleRate = desiredSampRate;
            }

            // for changing the sampling rate, reference:
            // http://stackoverflow.com/a/28977136/552182
            function interpolateArray(data, newSampleRate, oldSampleRate) {
                var fitCount = Math.round(data.length * (newSampleRate / oldSampleRate));
                var newData = [];
                var springFactor = Number((data.length - 1) / (fitCount - 1));
                newData[0] = data[0];
                for (var i = 1; i < fitCount - 1; i++) {
                    var tmp = i * springFactor;
                    var before = Number(Math.floor(tmp)).toFixed();
                    var after = Number(Math.ceil(tmp)).toFixed();
                    var atPoint = tmp - before;
                    newData[i] = linearInterpolate(data[before], data[after], atPoint);
                }
                newData[fitCount - 1] = data[data.length - 1];
                return newData;
            }

            function linearInterpolate(before, after, atPoint) {
                return before + (after - before) * atPoint;
            }

            function mergeBuffers(channelBuffer, rLength) {
                var result = new Float64Array(rLength);
                var offset = 0;
                var lng = channelBuffer.length;

                for (var i = 0; i < lng; i++) {
                    var buffer = channelBuffer[i];
                    result.set(buffer, offset);
                    offset += buffer.length;
                }

                return result;
            }

            function interleave(leftChannel, rightChannel) {
                var length = leftChannel.length + rightChannel.length;

                var result = new Float64Array(length);

                var inputIndex = 0;

                for (var index = 0; index < length;) {
                    result[index++] = leftChannel[inputIndex];
                    result[index++] = rightChannel[inputIndex];
                    inputIndex++;
                }
                return result;
            }

            function writeUTFBytes(view, offset, string) {
                var lng = string.length;
                for (var i = 0; i < lng; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }

            // interleave both channels together
            var interleaved;

            if (numberOfAudioChannels === 2) {
                interleaved = interleave(leftBuffers, rightBuffers);
            }

            if (numberOfAudioChannels === 1) {
                interleaved = leftBuffers;
            }

            var interleavedLength = interleaved.length;

            // create wav file
            var resultingBufferLength = 44 + interleavedLength * 2;

            var buffer = new ArrayBuffer(resultingBufferLength);

            var view = new DataView(buffer);

            // RIFF chunk descriptor/identifier 
            writeUTFBytes(view, 0, 'RIFF');

            // RIFF chunk length
            // changed "44" to "36" via #401
            view.setUint32(4, 36 + interleavedLength * 2, true);

            // RIFF type 
            writeUTFBytes(view, 8, 'WAVE');

            // format chunk identifier 
            // FMT sub-chunk
            writeUTFBytes(view, 12, 'fmt ');

            // format chunk length 
            view.setUint32(16, 16, true);

            // sample format (raw)
            view.setUint16(20, 1, true);

            // stereo (2 channels)
            view.setUint16(22, numberOfAudioChannels, true);

            // sample rate 
            view.setUint32(24, sampleRate, true);

            // byte rate (sample rate * block align)
            view.setUint32(28, sampleRate * numberOfAudioChannels * 2, true);

            // block align (channel count * bytes per sample) 
            view.setUint16(32, numberOfAudioChannels * 2, true);

            // bits per sample 
            view.setUint16(34, 16, true);

            // data sub-chunk
            // data chunk identifier 
            writeUTFBytes(view, 36, 'data');

            // data chunk length 
            view.setUint32(40, interleavedLength * 2, true);

            // write the PCM samples
            var lng = interleavedLength;
            var index = 44;
            var volume = 1;
            for (var i = 0; i < lng; i++) {
                view.setInt16(index, interleaved[i] * (0x7FFF * volume), true);
                index += 2;
            }

            if (cb) {
                return cb({
                    buffer: buffer,
                    view: view
                });
            }

            postMessage({
                buffer: buffer,
                view: view
            });
        }

        if (config.noWorker) {
            mergeAudioBuffers(config, function(data) {
                callback(data.buffer, data.view);
            });
            return;
        }


        var webWorker = processInWebWorker(mergeAudioBuffers);

        webWorker.onmessage = function(event) {
            callback(event.data.buffer, event.data.view);

            // release memory
            URL.revokeObjectURL(webWorker.workerURL);

            // kill webworker (or Chrome will kill your page after ~25 calls)
            webWorker.terminate();
        };

        webWorker.postMessage(config);
    }

    function processInWebWorker(_function) {
        var workerURL = URL.createObjectURL(new Blob([_function.toString(),
            ';this.onmessage =  function (eee) {' + _function.name + '(eee.data);}'
        ], {
            type: 'application/javascript'
        }));

        var worker = new Worker(workerURL);
        worker.workerURL = workerURL;
        return worker;
    }

    /**
     * This method stops recording MediaStream.
     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.
     * @method
     * @memberof StereoAudioRecorder
     * @example
     * recorder.stop(function(blob) {
     *     video.src = URL.createObjectURL(blob);
     * });
     */
    this.stop = function(callback) {
        callback = callback || function() {};

        // stop recording
        recording = false;

        mergeLeftRightBuffers({
            desiredSampRate: desiredSampRate,
            sampleRate: sampleRate,
            numberOfAudioChannels: numberOfAudioChannels,
            internalInterleavedLength: recordingLength,
            leftBuffers: leftchannel,
            rightBuffers: numberOfAudioChannels === 1 ? [] : rightchannel,
            noWorker: config.noWorker
        }, function(buffer, view) {
            /**
             * @property {Blob} blob - The recorded blob object.
             * @memberof StereoAudioRecorder
             * @example
             * recorder.stop(function(){
             *     var blob = recorder.blob;
             * });
             */
            self.blob = new Blob([view], {
                type: 'audio/wav'
            });

            /**
             * @property {ArrayBuffer} buffer - The recorded buffer object.
             * @memberof StereoAudioRecorder
             * @example
             * recorder.stop(function(){
             *     var buffer = recorder.buffer;
             * });
             */
            self.buffer = new ArrayBuffer(view.buffer.byteLength);

            /**
             * @property {DataView} view - The recorded data-view object.
             * @memberof StereoAudioRecorder
             * @example
             * recorder.stop(function(){
             *     var view = recorder.view;
             * });
             */
            self.view = view;

            self.sampleRate = desiredSampRate || sampleRate;
            self.bufferSize = bufferSize;

            // recorded audio length
            self.length = recordingLength;

            isAudioProcessStarted = false;

            if (callback) {
                callback(self.blob);
            }
        });
    };

    if (typeof RecordRTC.Storage === 'undefined') {
        RecordRTC.Storage = {
            AudioContextConstructor: null,
            AudioContext: window.AudioContext || window.webkitAudioContext
        };
    }

    if (!RecordRTC.Storage.AudioContextConstructor || RecordRTC.Storage.AudioContextConstructor.state === 'closed') {
        RecordRTC.Storage.AudioContextConstructor = new RecordRTC.Storage.AudioContext();
    }

    var context = RecordRTC.Storage.AudioContextConstructor;

    // creates an audio node from the microphone incoming stream
    var audioInput = context.createMediaStreamSource(mediaStream);

    var legalBufferValues = [0, 256, 512, 1024, 2048, 4096, 8192, 16384];

    /**
     * From the spec: This value controls how frequently the audioprocess event is
     * dispatched and how many sample-frames need to be processed each call.
     * Lower values for buffer size will result in a lower (better) latency.
     * Higher values will be necessary to avoid audio breakup and glitches
     * The size of the buffer (in sample-frames) which needs to
     * be processed each time onprocessaudio is called.
     * Legal values are (256, 512, 1024, 2048, 4096, 8192, 16384).
     * @property {number} bufferSize - Buffer-size for how frequently the audioprocess event is dispatched.
     * @memberof StereoAudioRecorder
     * @example
     * recorder = new StereoAudioRecorder(mediaStream, {
     *     bufferSize: 4096
     * });
     */

    // "0" means, let chrome decide the most accurate buffer-size for current platform.
    var bufferSize = typeof config.bufferSize === 'undefined' ? 4096 : config.bufferSize;

    if (legalBufferValues.indexOf(bufferSize) === -1) {
        if (!config.disableLogs) {
            console.log('Legal values for buffer-size are ' + JSON.stringify(legalBufferValues, null, '\t'));
        }
    }

    if (context.createJavaScriptNode) {
        jsAudioNode = context.createJavaScriptNode(bufferSize, numberOfAudioChannels, numberOfAudioChannels);
    } else if (context.createScriptProcessor) {
        jsAudioNode = context.createScriptProcessor(bufferSize, numberOfAudioChannels, numberOfAudioChannels);
    } else {
        throw 'WebAudio API has no support on this browser.';
    }

    // connect the stream to the script processor
    audioInput.connect(jsAudioNode);

    if (!config.bufferSize) {
        bufferSize = jsAudioNode.bufferSize; // device buffer-size
    }

    /**
     * The sample rate (in sample-frames per second) at which the
     * AudioContext handles audio. It is assumed that all AudioNodes
     * in the context run at this rate. In making this assumption,
     * sample-rate converters or "varispeed" processors are not supported
     * in real-time processing.
     * The sampleRate parameter describes the sample-rate of the
     * linear PCM audio data in the buffer in sample-frames per second.
     * An implementation must support sample-rates in at least
     * the range 22050 to 96000.
     * @property {number} sampleRate - Buffer-size for how frequently the audioprocess event is dispatched.
     * @memberof StereoAudioRecorder
     * @example
     * recorder = new StereoAudioRecorder(mediaStream, {
     *     sampleRate: 44100
     * });
     */
    var sampleRate = typeof config.sampleRate !== 'undefined' ? config.sampleRate : context.sampleRate || 44100;

    if (sampleRate < 22050 || sampleRate > 96000) {
        // Ref: http://stackoverflow.com/a/26303918/552182
        if (!config.disableLogs) {
            console.log('sample-rate must be under range 22050 and 96000.');
        }
    }

    if (!config.disableLogs) {
        if (config.desiredSampRate) {
            console.log('Desired sample-rate: ' + config.desiredSampRate);
        }
    }

    var isPaused = false;
    /**
     * This method pauses the recording process.
     * @method
     * @memberof StereoAudioRecorder
     * @example
     * recorder.pause();
     */
    this.pause = function() {
        isPaused = true;
    };

    /**
     * This method resumes the recording process.
     * @method
     * @memberof StereoAudioRecorder
     * @example
     * recorder.resume();
     */
    this.resume = function() {
        if (isMediaStreamActive() === false) {
            throw 'Please make sure MediaStream is active.';
        }

        if (!recording) {
            if (!config.disableLogs) {
                console.log('Seems recording has been restarted.');
            }
            this.record();
            return;
        }

        isPaused = false;
    };

    /**
     * This method resets currently recorded data.
     * @method
     * @memberof StereoAudioRecorder
     * @example
     * recorder.clearRecordedData();
     */
    this.clearRecordedData = function() {
        config.checkForInactiveTracks = false;

        if (recording) {
            this.stop(clearRecordedDataCB);
        }

        clearRecordedDataCB();
    };

    function resetVariables() {
        leftchannel = [];
        rightchannel = [];
        recordingLength = 0;
        isAudioProcessStarted = false;
        recording = false;
        isPaused = false;
        context = null;

        self.leftchannel = leftchannel;
        self.rightchannel = rightchannel;
        self.numberOfAudioChannels = numberOfAudioChannels;
        self.desiredSampRate = desiredSampRate;
        self.sampleRate = sampleRate;
        self.recordingLength = recordingLength;

        intervalsBasedBuffers = {
            left: [],
            right: [],
            recordingLength: 0
        };
    }

    function clearRecordedDataCB() {
        if (jsAudioNode) {
            jsAudioNode.onaudioprocess = null;
            jsAudioNode.disconnect();
            jsAudioNode = null;
        }

        if (audioInput) {
            audioInput.disconnect();
            audioInput = null;
        }

        resetVariables();
    }

    // for debugging
    this.name = 'StereoAudioRecorder';
    this.toString = function() {
        return this.name;
    };

    var isAudioProcessStarted = false;

    function onAudioProcessDataAvailable(e) {
        if (isPaused) {
            return;
        }

        if (isMediaStreamActive() === false) {
            if (!config.disableLogs) {
                console.log('MediaStream seems stopped.');
            }
            jsAudioNode.disconnect();
            recording = false;
        }

        if (!recording) {
            if (audioInput) {
                audioInput.disconnect();
                audioInput = null;
            }
            return;
        }

        /**
         * This method is called on "onaudioprocess" event's first invocation.
         * @method {function} onAudioProcessStarted
         * @memberof StereoAudioRecorder
         * @example
         * recorder.onAudioProcessStarted: function() { };
         */
        if (!isAudioProcessStarted) {
            isAudioProcessStarted = true;
            if (config.onAudioProcessStarted) {
                config.onAudioProcessStarted();
            }

            if (config.initCallback) {
                config.initCallback();
            }
        }

        var left = e.inputBuffer.getChannelData(0);

        // we clone the samples
        var chLeft = new Float32Array(left);
        leftchannel.push(chLeft);

        if (numberOfAudioChannels === 2) {
            var right = e.inputBuffer.getChannelData(1);
            var chRight = new Float32Array(right);
            rightchannel.push(chRight);
        }

        recordingLength += bufferSize;

        // export raw PCM
        self.recordingLength = recordingLength;

        if (typeof config.timeSlice !== 'undefined') {
            intervalsBasedBuffers.recordingLength += bufferSize;
            intervalsBasedBuffers.left.push(chLeft);

            if (numberOfAudioChannels === 2) {
                intervalsBasedBuffers.right.push(chRight);
            }
        }
    }

    jsAudioNode.onaudioprocess = onAudioProcessDataAvailable;

    // to prevent self audio to be connected with speakers
    if (context.createMediaStreamDestination) {
        jsAudioNode.connect(context.createMediaStreamDestination());
    } else {
        jsAudioNode.connect(context.destination);
    }

    // export raw PCM
    this.leftchannel = leftchannel;
    this.rightchannel = rightchannel;
    this.numberOfAudioChannels = numberOfAudioChannels;
    this.desiredSampRate = desiredSampRate;
    this.sampleRate = sampleRate;
    self.recordingLength = recordingLength;

    // helper for intervals based blobs
    var intervalsBasedBuffers = {
        left: [],
        right: [],
        recordingLength: 0
    };

    // this looper is used to support intervals based blobs (via timeSlice+ondataavailable)
    function looper() {
        if (!recording || typeof config.ondataavailable !== 'function' || typeof config.timeSlice === 'undefined') {
            return;
        }

        if (intervalsBasedBuffers.left.length) {
            mergeLeftRightBuffers({
                desiredSampRate: desiredSampRate,
                sampleRate: sampleRate,
                numberOfAudioChannels: numberOfAudioChannels,
                internalInterleavedLength: intervalsBasedBuffers.recordingLength,
                leftBuffers: intervalsBasedBuffers.left,
                rightBuffers: numberOfAudioChannels === 1 ? [] : intervalsBasedBuffers.right
            }, function(buffer, view) {
                var blob = new Blob([view], {
                    type: 'audio/wav'
                });
                config.ondataavailable(blob);

                setTimeout(looper, config.timeSlice);
            });

            intervalsBasedBuffers = {
                left: [],
                right: [],
                recordingLength: 0
            };
        } else {
            setTimeout(looper, config.timeSlice);
        }
    }
}

if (typeof RecordRTC !== 'undefined') {
    RecordRTC.StereoAudioRecorder = StereoAudioRecorder;
}

// _________________
// CanvasRecorder.js

/**
 * CanvasRecorder is a standalone class used by {@link RecordRTC} to bring HTML5-Canvas recording into video WebM. It uses HTML2Canvas library and runs top over {@link Whammy}.
 * @summary HTML2Canvas recording into video WebM.
 * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
 * @author {@link https://MuazKhan.com|Muaz Khan}
 * @typedef CanvasRecorder
 * @class
 * @example
 * var recorder = new CanvasRecorder(htmlElement, { disableLogs: true, useWhammyRecorder: true });
 * recorder.record();
 * recorder.stop(function(blob) {
 *     video.src = URL.createObjectURL(blob);
 * });
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 * @param {HTMLElement} htmlElement - querySelector/getElementById/getElementsByTagName[0]/etc.
 * @param {object} config - {disableLogs:true, initCallback: function}
 */

function CanvasRecorder(htmlElement, config) {
    if (typeof html2canvas === 'undefined') {
        throw 'Please link: https://www.webrtc-experiment.com/screenshot.js';
    }

    config = config || {};
    if (!config.frameInterval) {
        config.frameInterval = 10;
    }

    // via DetectRTC.js
    var isCanvasSupportsStreamCapturing = false;
    ['captureStream', 'mozCaptureStream', 'webkitCaptureStream'].forEach(function(item) {
        if (item in document.createElement('canvas')) {
            isCanvasSupportsStreamCapturing = true;
        }
    });

    var _isChrome = (!!window.webkitRTCPeerConnection || !!window.webkitGetUserMedia) && !!window.chrome;

    var chromeVersion = 50;
    var matchArray = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
    if (_isChrome && matchArray && matchArray[2]) {
        chromeVersion = parseInt(matchArray[2], 10);
    }

    if (_isChrome && chromeVersion < 52) {
        isCanvasSupportsStreamCapturing = false;
    }

    if (config.useWhammyRecorder) {
        isCanvasSupportsStreamCapturing = false;
    }

    var globalCanvas, mediaStreamRecorder;

    if (isCanvasSupportsStreamCapturing) {
        if (!config.disableLogs) {
            console.log('Your browser supports both MediRecorder API and canvas.captureStream!');
        }

        if (htmlElement instanceof HTMLCanvasElement) {
            globalCanvas = htmlElement;
        } else if (htmlElement instanceof CanvasRenderingContext2D) {
            globalCanvas = htmlElement.canvas;
        } else {
            throw 'Please pass either HTMLCanvasElement or CanvasRenderingContext2D.';
        }
    } else if (!!navigator.mozGetUserMedia) {
        if (!config.disableLogs) {
            console.error('Canvas recording is NOT supported in Firefox.');
        }
    }

    var isRecording;

    /**
     * This method records Canvas.
     * @method
     * @memberof CanvasRecorder
     * @example
     * recorder.record();
     */
    this.record = function() {
        isRecording = true;

        if (isCanvasSupportsStreamCapturing && !config.useWhammyRecorder) {
            // CanvasCaptureMediaStream
            var canvasMediaStream;
            if ('captureStream' in globalCanvas) {
                canvasMediaStream = globalCanvas.captureStream(25); // 25 FPS
            } else if ('mozCaptureStream' in globalCanvas) {
                canvasMediaStream = globalCanvas.mozCaptureStream(25);
            } else if ('webkitCaptureStream' in globalCanvas) {
                canvasMediaStream = globalCanvas.webkitCaptureStream(25);
            }

            try {
                var mdStream = new MediaStream();
                mdStream.addTrack(getTracks(canvasMediaStream, 'video')[0]);
                canvasMediaStream = mdStream;
            } catch (e) {}

            if (!canvasMediaStream) {
                throw 'captureStream API are NOT available.';
            }

            // Note: Jan 18, 2016 status is that, 
            // Firefox MediaRecorder API can't record CanvasCaptureMediaStream object.
            mediaStreamRecorder = new MediaStreamRecorder(canvasMediaStream, {
                mimeType: config.mimeType || 'video/webm'
            });
            mediaStreamRecorder.record();
        } else {
            whammy.frames = [];
            lastTime = new Date().getTime();
            drawCanvasFrame();
        }

        if (config.initCallback) {
            config.initCallback();
        }
    };

    this.getWebPImages = function(callback) {
        if (htmlElement.nodeName.toLowerCase() !== 'canvas') {
            callback();
            return;
        }

        var framesLength = whammy.frames.length;
        whammy.frames.forEach(function(frame, idx) {
            var framesRemaining = framesLength - idx;
            if (!config.disableLogs) {
                console.log(framesRemaining + '/' + framesLength + ' frames remaining');
            }

            if (config.onEncodingCallback) {
                config.onEncodingCallback(framesRemaining, framesLength);
            }

            var webp = frame.image.toDataURL('image/webp', 1);
            whammy.frames[idx].image = webp;
        });

        if (!config.disableLogs) {
            console.log('Generating WebM');
        }

        callback();
    };

    /**
     * This method stops recording Canvas.
     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.
     * @method
     * @memberof CanvasRecorder
     * @example
     * recorder.stop(function(blob) {
     *     video.src = URL.createObjectURL(blob);
     * });
     */
    this.stop = function(callback) {
        isRecording = false;

        var that = this;

        if (isCanvasSupportsStreamCapturing && mediaStreamRecorder) {
            mediaStreamRecorder.stop(callback);
            return;
        }

        this.getWebPImages(function() {
            /**
             * @property {Blob} blob - Recorded frames in video/webm blob.
             * @memberof CanvasRecorder
             * @example
             * recorder.stop(function() {
             *     var blob = recorder.blob;
             * });
             */
            whammy.compile(function(blob) {
                if (!config.disableLogs) {
                    console.log('Recording finished!');
                }

                that.blob = blob;

                if (that.blob.forEach) {
                    that.blob = new Blob([], {
                        type: 'video/webm'
                    });
                }

                if (callback) {
                    callback(that.blob);
                }

                whammy.frames = [];
            });
        });
    };

    var isPausedRecording = false;

    /**
     * This method pauses the recording process.
     * @method
     * @memberof CanvasRecorder
     * @example
     * recorder.pause();
     */
    this.pause = function() {
        isPausedRecording = true;

        if (mediaStreamRecorder instanceof MediaStreamRecorder) {
            mediaStreamRecorder.pause();
            return;
        }
    };

    /**
     * This method resumes the recording process.
     * @method
     * @memberof CanvasRecorder
     * @example
     * recorder.resume();
     */
    this.resume = function() {
        isPausedRecording = false;

        if (mediaStreamRecorder instanceof MediaStreamRecorder) {
            mediaStreamRecorder.resume();
            return;
        }

        if (!isRecording) {
            this.record();
        }
    };

    /**
     * This method resets currently recorded data.
     * @method
     * @memberof CanvasRecorder
     * @example
     * recorder.clearRecordedData();
     */
    this.clearRecordedData = function() {
        if (isRecording) {
            this.stop(clearRecordedDataCB);
        }
        clearRecordedDataCB();
    };

    function clearRecordedDataCB() {
        whammy.frames = [];
        isRecording = false;
        isPausedRecording = false;
    }

    // for debugging
    this.name = 'CanvasRecorder';
    this.toString = function() {
        return this.name;
    };

    function cloneCanvas() {
        //create a new canvas
        var newCanvas = document.createElement('canvas');
        var context = newCanvas.getContext('2d');

        //set dimensions
        newCanvas.width = htmlElement.width;
        newCanvas.height = htmlElement.height;

        //apply the old canvas to the new one
        context.drawImage(htmlElement, 0, 0);

        //return the new canvas
        return newCanvas;
    }

    function drawCanvasFrame() {
        if (isPausedRecording) {
            lastTime = new Date().getTime();
            return setTimeout(drawCanvasFrame, 500);
        }

        if (htmlElement.nodeName.toLowerCase() === 'canvas') {
            var duration = new Date().getTime() - lastTime;
            // via #206, by Jack i.e. @Seymourr
            lastTime = new Date().getTime();

            whammy.frames.push({
                image: cloneCanvas(),
                duration: duration
            });

            if (isRecording) {
                setTimeout(drawCanvasFrame, config.frameInterval);
            }
            return;
        }

        html2canvas(htmlElement, {
            grabMouse: typeof config.showMousePointer === 'undefined' || config.showMousePointer,
            onrendered: function(canvas) {
                var duration = new Date().getTime() - lastTime;
                if (!duration) {
                    return setTimeout(drawCanvasFrame, config.frameInterval);
                }

                // via #206, by Jack i.e. @Seymourr
                lastTime = new Date().getTime();

                whammy.frames.push({
                    image: canvas.toDataURL('image/webp', 1),
                    duration: duration
                });

                if (isRecording) {
                    setTimeout(drawCanvasFrame, config.frameInterval);
                }
            }
        });
    }

    var lastTime = new Date().getTime();

    var whammy = new Whammy.Video(100);
}

if (typeof RecordRTC !== 'undefined') {
    RecordRTC.CanvasRecorder = CanvasRecorder;
}

// _________________
// WhammyRecorder.js

/**
 * WhammyRecorder is a standalone class used by {@link RecordRTC} to bring video recording in Chrome. It runs top over {@link Whammy}.
 * @summary Video recording feature in Chrome.
 * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
 * @author {@link https://MuazKhan.com|Muaz Khan}
 * @typedef WhammyRecorder
 * @class
 * @example
 * var recorder = new WhammyRecorder(mediaStream);
 * recorder.record();
 * recorder.stop(function(blob) {
 *     video.src = URL.createObjectURL(blob);
 * });
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
 * @param {object} config - {disableLogs: true, initCallback: function, video: HTMLVideoElement, etc.}
 */

function WhammyRecorder(mediaStream, config) {

    config = config || {};

    if (!config.frameInterval) {
        config.frameInterval = 10;
    }

    if (!config.disableLogs) {
        console.log('Using frames-interval:', config.frameInterval);
    }

    /**
     * This method records video.
     * @method
     * @memberof WhammyRecorder
     * @example
     * recorder.record();
     */
    this.record = function() {
        if (!config.width) {
            config.width = 320;
        }

        if (!config.height) {
            config.height = 240;
        }

        if (!config.video) {
            config.video = {
                width: config.width,
                height: config.height
            };
        }

        if (!config.canvas) {
            config.canvas = {
                width: config.width,
                height: config.height
            };
        }

        canvas.width = config.canvas.width || 320;
        canvas.height = config.canvas.height || 240;

        context = canvas.getContext('2d');

        // setting defaults
        if (config.video && config.video instanceof HTMLVideoElement) {
            video = config.video.cloneNode();

            if (config.initCallback) {
                config.initCallback();
            }
        } else {
            video = document.createElement('video');

            setSrcObject(mediaStream, video);

            video.onloadedmetadata = function() { // "onloadedmetadata" may NOT work in FF?
                if (config.initCallback) {
                    config.initCallback();
                }
            };

            video.width = config.video.width;
            video.height = config.video.height;
        }

        video.muted = true;
        video.play();

        lastTime = new Date().getTime();
        whammy = new Whammy.Video();

        if (!config.disableLogs) {
            console.log('canvas resolutions', canvas.width, '*', canvas.height);
            console.log('video width/height', video.width || canvas.width, '*', video.height || canvas.height);
        }

        drawFrames(config.frameInterval);
    };

    /**
     * Draw and push frames to Whammy
     * @param {integer} frameInterval - set minimum interval (in milliseconds) between each time we push a frame to Whammy
     */
    function drawFrames(frameInterval) {
        frameInterval = typeof frameInterval !== 'undefined' ? frameInterval : 10;

        var duration = new Date().getTime() - lastTime;
        if (!duration) {
            return setTimeout(drawFrames, frameInterval, frameInterval);
        }

        if (isPausedRecording) {
            lastTime = new Date().getTime();
            return setTimeout(drawFrames, 100);
        }

        // via #206, by Jack i.e. @Seymourr
        lastTime = new Date().getTime();

        if (video.paused) {
            // via: https://github.com/muaz-khan/WebRTC-Experiment/pull/316
            // Tweak for Android Chrome
            video.play();
        }

        context.drawImage(video, 0, 0, canvas.width, canvas.height);
        whammy.frames.push({
            duration: duration,
            image: canvas.toDataURL('image/webp')
        });

        if (!isStopDrawing) {
            setTimeout(drawFrames, frameInterval, frameInterval);
        }
    }

    function asyncLoop(o) {
        var i = -1,
            length = o.length;

        (function loop() {
            i++;
            if (i === length) {
                o.callback();
                return;
            }

            // "setTimeout" added by Jim McLeod
            setTimeout(function() {
                o.functionToLoop(loop, i);
            }, 1);
        })();
    }


    /**
     * remove black frames from the beginning to the specified frame
     * @param {Array} _frames - array of frames to be checked
     * @param {number} _framesToCheck - number of frame until check will be executed (-1 - will drop all frames until frame not matched will be found)
     * @param {number} _pixTolerance - 0 - very strict (only black pixel color) ; 1 - all
     * @param {number} _frameTolerance - 0 - very strict (only black frame color) ; 1 - all
     * @returns {Array} - array of frames
     */
    // pull#293 by @volodalexey
    function dropBlackFrames(_frames, _framesToCheck, _pixTolerance, _frameTolerance, callback) {
        var localCanvas = document.createElement('canvas');
        localCanvas.width = canvas.width;
        localCanvas.height = canvas.height;
        var context2d = localCanvas.getContext('2d');
        var resultFrames = [];

        var checkUntilNotBlack = _framesToCheck === -1;
        var endCheckFrame = (_framesToCheck && _framesToCheck > 0 && _framesToCheck <= _frames.length) ?
            _framesToCheck : _frames.length;
        var sampleColor = {
            r: 0,
            g: 0,
            b: 0
        };
        var maxColorDifference = Math.sqrt(
            Math.pow(255, 2) +
            Math.pow(255, 2) +
            Math.pow(255, 2)
        );
        var pixTolerance = _pixTolerance && _pixTolerance >= 0 && _pixTolerance <= 1 ? _pixTolerance : 0;
        var frameTolerance = _frameTolerance && _frameTolerance >= 0 && _frameTolerance <= 1 ? _frameTolerance : 0;
        var doNotCheckNext = false;

        asyncLoop({
            length: endCheckFrame,
            functionToLoop: function(loop, f) {
                var matchPixCount, endPixCheck, maxPixCount;

                var finishImage = function() {
                    if (!doNotCheckNext && maxPixCount - matchPixCount <= maxPixCount * frameTolerance) {
                        // console.log('removed black frame : ' + f + ' ; frame duration ' + _frames[f].duration);
                    } else {
                        // console.log('frame is passed : ' + f);
                        if (checkUntilNotBlack) {
                            doNotCheckNext = true;
                        }
                        resultFrames.push(_frames[f]);
                    }
                    loop();
                };

                if (!doNotCheckNext) {
                    var image = new Image();
                    image.onload = function() {
                        context2d.drawImage(image, 0, 0, canvas.width, canvas.height);
                        var imageData = context2d.getImageData(0, 0, canvas.width, canvas.height);
                        matchPixCount = 0;
                        endPixCheck = imageData.data.length;
                        maxPixCount = imageData.data.length / 4;

                        for (var pix = 0; pix < endPixCheck; pix += 4) {
                            var currentColor = {
                                r: imageData.data[pix],
                                g: imageData.data[pix + 1],
                                b: imageData.data[pix + 2]
                            };
                            var colorDifference = Math.sqrt(
                                Math.pow(currentColor.r - sampleColor.r, 2) +
                                Math.pow(currentColor.g - sampleColor.g, 2) +
                                Math.pow(currentColor.b - sampleColor.b, 2)
                            );
                            // difference in color it is difference in color vectors (r1,g1,b1) <=> (r2,g2,b2)
                            if (colorDifference <= maxColorDifference * pixTolerance) {
                                matchPixCount++;
                            }
                        }
                        finishImage();
                    };
                    image.src = _frames[f].image;
                } else {
                    finishImage();
                }
            },
            callback: function() {
                resultFrames = resultFrames.concat(_frames.slice(endCheckFrame));

                if (resultFrames.length <= 0) {
                    // at least one last frame should be available for next manipulation
                    // if total duration of all frames will be < 1000 than ffmpeg doesn't work well...
                    resultFrames.push(_frames[_frames.length - 1]);
                }
                callback(resultFrames);
            }
        });
    }

    var isStopDrawing = false;

    /**
     * This method stops recording video.
     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.
     * @method
     * @memberof WhammyRecorder
     * @example
     * recorder.stop(function(blob) {
     *     video.src = URL.createObjectURL(blob);
     * });
     */
    this.stop = function(callback) {
        callback = callback || function() {};

        isStopDrawing = true;

        var _this = this;
        // analyse of all frames takes some time!
        setTimeout(function() {
            // e.g. dropBlackFrames(frames, 10, 1, 1) - will cut all 10 frames
            // e.g. dropBlackFrames(frames, 10, 0.5, 0.5) - will analyse 10 frames
            // e.g. dropBlackFrames(frames, 10) === dropBlackFrames(frames, 10, 0, 0) - will analyse 10 frames with strict black color
            dropBlackFrames(whammy.frames, -1, null, null, function(frames) {
                whammy.frames = frames;

                // to display advertisement images!
                if (config.advertisement && config.advertisement.length) {
                    whammy.frames = config.advertisement.concat(whammy.frames);
                }

                /**
                 * @property {Blob} blob - Recorded frames in video/webm blob.
                 * @memberof WhammyRecorder
                 * @example
                 * recorder.stop(function() {
                 *     var blob = recorder.blob;
                 * });
                 */
                whammy.compile(function(blob) {
                    _this.blob = blob;

                    if (_this.blob.forEach) {
                        _this.blob = new Blob([], {
                            type: 'video/webm'
                        });
                    }

                    if (callback) {
                        callback(_this.blob);
                    }
                });
            });
        }, 10);
    };

    var isPausedRecording = false;

    /**
     * This method pauses the recording process.
     * @method
     * @memberof WhammyRecorder
     * @example
     * recorder.pause();
     */
    this.pause = function() {
        isPausedRecording = true;
    };

    /**
     * This method resumes the recording process.
     * @method
     * @memberof WhammyRecorder
     * @example
     * recorder.resume();
     */
    this.resume = function() {
        isPausedRecording = false;

        if (isStopDrawing) {
            this.record();
        }
    };

    /**
     * This method resets currently recorded data.
     * @method
     * @memberof WhammyRecorder
     * @example
     * recorder.clearRecordedData();
     */
    this.clearRecordedData = function() {
        if (!isStopDrawing) {
            this.stop(clearRecordedDataCB);
        }
        clearRecordedDataCB();
    };

    function clearRecordedDataCB() {
        whammy.frames = [];
        isStopDrawing = true;
        isPausedRecording = false;
    }

    // for debugging
    this.name = 'WhammyRecorder';
    this.toString = function() {
        return this.name;
    };

    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');

    var video;
    var lastTime;
    var whammy;
}

if (typeof RecordRTC !== 'undefined') {
    RecordRTC.WhammyRecorder = WhammyRecorder;
}

// https://github.com/antimatter15/whammy/blob/master/LICENSE
// _________
// Whammy.js

// todo: Firefox now supports webp for webm containers!
// their MediaRecorder implementation works well!
// should we provide an option to record via Whammy.js or MediaRecorder API is a better solution?

/**
 * Whammy is a standalone class used by {@link RecordRTC} to bring video recording in Chrome. It is written by {@link https://github.com/antimatter15|antimatter15}
 * @summary A real time javascript webm encoder based on a canvas hack.
 * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
 * @author {@link https://MuazKhan.com|Muaz Khan}
 * @typedef Whammy
 * @class
 * @example
 * var recorder = new Whammy().Video(15);
 * recorder.add(context || canvas || dataURL);
 * var output = recorder.compile();
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 */

var Whammy = (function() {
    // a more abstract-ish API

    function WhammyVideo(duration) {
        this.frames = [];
        this.duration = duration || 1;
        this.quality = 0.8;
    }

    /**
     * Pass Canvas or Context or image/webp(string) to {@link Whammy} encoder.
     * @method
     * @memberof Whammy
     * @example
     * recorder = new Whammy().Video(0.8, 100);
     * recorder.add(canvas || context || 'image/webp');
     * @param {string} frame - Canvas || Context || image/webp
     * @param {number} duration - Stick a duration (in milliseconds)
     */
    WhammyVideo.prototype.add = function(frame, duration) {
        if ('canvas' in frame) { //CanvasRenderingContext2D
            frame = frame.canvas;
        }

        if ('toDataURL' in frame) {
            frame = frame.toDataURL('image/webp', this.quality);
        }

        if (!(/^data:image\/webp;base64,/ig).test(frame)) {
            throw 'Input must be formatted properly as a base64 encoded DataURI of type image/webp';
        }
        this.frames.push({
            image: frame,
            duration: duration || this.duration
        });
    };

    function processInWebWorker(_function) {
        var blob = URL.createObjectURL(new Blob([_function.toString(),
            'this.onmessage =  function (eee) {' + _function.name + '(eee.data);}'
        ], {
            type: 'application/javascript'
        }));

        var worker = new Worker(blob);
        URL.revokeObjectURL(blob);
        return worker;
    }

    function whammyInWebWorker(frames) {
        function ArrayToWebM(frames) {
            var info = checkFrames(frames);
            if (!info) {
                return [];
            }

            var clusterMaxDuration = 30000;

            var EBML = [{
                'id': 0x1a45dfa3, // EBML
                'data': [{
                    'data': 1,
                    'id': 0x4286 // EBMLVersion
                }, {
                    'data': 1,
                    'id': 0x42f7 // EBMLReadVersion
                }, {
                    'data': 4,
                    'id': 0x42f2 // EBMLMaxIDLength
                }, {
                    'data': 8,
                    'id': 0x42f3 // EBMLMaxSizeLength
                }, {
                    'data': 'webm',
                    'id': 0x4282 // DocType
                }, {
                    'data': 2,
                    'id': 0x4287 // DocTypeVersion
                }, {
                    'data': 2,
                    'id': 0x4285 // DocTypeReadVersion
                }]
            }, {
                'id': 0x18538067, // Segment
                'data': [{
                    'id': 0x1549a966, // Info
                    'data': [{
                        'data': 1e6, //do things in millisecs (num of nanosecs for duration scale)
                        'id': 0x2ad7b1 // TimecodeScale
                    }, {
                        'data': 'whammy',
                        'id': 0x4d80 // MuxingApp
                    }, {
                        'data': 'whammy',
                        'id': 0x5741 // WritingApp
                    }, {
                        'data': doubleToString(info.duration),
                        'id': 0x4489 // Duration
                    }]
                }, {
                    'id': 0x1654ae6b, // Tracks
                    'data': [{
                        'id': 0xae, // TrackEntry
                        'data': [{
                            'data': 1,
                            'id': 0xd7 // TrackNumber
                        }, {
                            'data': 1,
                            'id': 0x73c5 // TrackUID
                        }, {
                            'data': 0,
                            'id': 0x9c // FlagLacing
                        }, {
                            'data': 'und',
                            'id': 0x22b59c // Language
                        }, {
                            'data': 'V_VP8',
                            'id': 0x86 // CodecID
                        }, {
                            'data': 'VP8',
                            'id': 0x258688 // CodecName
                        }, {
                            'data': 1,
                            'id': 0x83 // TrackType
                        }, {
                            'id': 0xe0, // Video
                            'data': [{
                                'data': info.width,
                                'id': 0xb0 // PixelWidth
                            }, {
                                'data': info.height,
                                'id': 0xba // PixelHeight
                            }]
                        }]
                    }]
                }]
            }];

            //Generate clusters (max duration)
            var frameNumber = 0;
            var clusterTimecode = 0;
            while (frameNumber < frames.length) {

                var clusterFrames = [];
                var clusterDuration = 0;
                do {
                    clusterFrames.push(frames[frameNumber]);
                    clusterDuration += frames[frameNumber].duration;
                    frameNumber++;
                } while (frameNumber < frames.length && clusterDuration < clusterMaxDuration);

                var clusterCounter = 0;
                var cluster = {
                    'id': 0x1f43b675, // Cluster
                    'data': getClusterData(clusterTimecode, clusterCounter, clusterFrames)
                }; //Add cluster to segment
                EBML[1].data.push(cluster);
                clusterTimecode += clusterDuration;
            }

            return generateEBML(EBML);
        }

        function getClusterData(clusterTimecode, clusterCounter, clusterFrames) {
            return [{
                'data': clusterTimecode,
                'id': 0xe7 // Timecode
            }].concat(clusterFrames.map(function(webp) {
                var block = makeSimpleBlock({
                    discardable: 0,
                    frame: webp.data.slice(4),
                    invisible: 0,
                    keyframe: 1,
                    lacing: 0,
                    trackNum: 1,
                    timecode: Math.round(clusterCounter)
                });
                clusterCounter += webp.duration;
                return {
                    data: block,
                    id: 0xa3
                };
            }));
        }

        // sums the lengths of all the frames and gets the duration

        function checkFrames(frames) {
            if (!frames[0]) {
                postMessage({
                    error: 'Something went wrong. Maybe WebP format is not supported in the current browser.'
                });
                return;
            }

            var width = frames[0].width,
                height = frames[0].height,
                duration = frames[0].duration;

            for (var i = 1; i < frames.length; i++) {
                duration += frames[i].duration;
            }
            return {
                duration: duration,
                width: width,
                height: height
            };
        }

        function numToBuffer(num) {
            var parts = [];
            while (num > 0) {
                parts.push(num & 0xff);
                num = num >> 8;
            }
            return new Uint8Array(parts.reverse());
        }

        function strToBuffer(str) {
            return new Uint8Array(str.split('').map(function(e) {
                return e.charCodeAt(0);
            }));
        }

        function bitsToBuffer(bits) {
            var data = [];
            var pad = (bits.length % 8) ? (new Array(1 + 8 - (bits.length % 8))).join('0') : '';
            bits = pad + bits;
            for (var i = 0; i < bits.length; i += 8) {
                data.push(parseInt(bits.substr(i, 8), 2));
            }
            return new Uint8Array(data);
        }

        function generateEBML(json) {
            var ebml = [];
            for (var i = 0; i < json.length; i++) {
                var data = json[i].data;

                if (typeof data === 'object') {
                    data = generateEBML(data);
                }

                if (typeof data === 'number') {
                    data = bitsToBuffer(data.toString(2));
                }

                if (typeof data === 'string') {
                    data = strToBuffer(data);
                }

                var len = data.size || data.byteLength || data.length;
                var zeroes = Math.ceil(Math.ceil(Math.log(len) / Math.log(2)) / 8);
                var sizeToString = len.toString(2);
                var padded = (new Array((zeroes * 7 + 7 + 1) - sizeToString.length)).join('0') + sizeToString;
                var size = (new Array(zeroes)).join('0') + '1' + padded;

                ebml.push(numToBuffer(json[i].id));
                ebml.push(bitsToBuffer(size));
                ebml.push(data);
            }

            return new Blob(ebml, {
                type: 'video/webm'
            });
        }

        function toBinStrOld(bits) {
            var data = '';
            var pad = (bits.length % 8) ? (new Array(1 + 8 - (bits.length % 8))).join('0') : '';
            bits = pad + bits;
            for (var i = 0; i < bits.length; i += 8) {
                data += String.fromCharCode(parseInt(bits.substr(i, 8), 2));
            }
            return data;
        }

        function makeSimpleBlock(data) {
            var flags = 0;

            if (data.keyframe) {
                flags |= 128;
            }

            if (data.invisible) {
                flags |= 8;
            }

            if (data.lacing) {
                flags |= (data.lacing << 1);
            }

            if (data.discardable) {
                flags |= 1;
            }

            if (data.trackNum > 127) {
                throw 'TrackNumber > 127 not supported';
            }

            var out = [data.trackNum | 0x80, data.timecode >> 8, data.timecode & 0xff, flags].map(function(e) {
                return String.fromCharCode(e);
            }).join('') + data.frame;

            return out;
        }

        function parseWebP(riff) {
            var VP8 = riff.RIFF[0].WEBP[0];

            var frameStart = VP8.indexOf('\x9d\x01\x2a'); // A VP8 keyframe starts with the 0x9d012a header
            for (var i = 0, c = []; i < 4; i++) {
                c[i] = VP8.charCodeAt(frameStart + 3 + i);
            }

            var width, height, tmp;

            //the code below is literally copied verbatim from the bitstream spec
            tmp = (c[1] << 8) | c[0];
            width = tmp & 0x3FFF;
            tmp = (c[3] << 8) | c[2];
            height = tmp & 0x3FFF;
            return {
                width: width,
                height: height,
                data: VP8,
                riff: riff
            };
        }

        function getStrLength(string, offset) {
            return parseInt(string.substr(offset + 4, 4).split('').map(function(i) {
                var unpadded = i.charCodeAt(0).toString(2);
                return (new Array(8 - unpadded.length + 1)).join('0') + unpadded;
            }).join(''), 2);
        }

        function parseRIFF(string) {
            var offset = 0;
            var chunks = {};

            while (offset < string.length) {
                var id = string.substr(offset, 4);
                var len = getStrLength(string, offset);
                var data = string.substr(offset + 4 + 4, len);
                offset += 4 + 4 + len;
                chunks[id] = chunks[id] || [];

                if (id === 'RIFF' || id === 'LIST') {
                    chunks[id].push(parseRIFF(data));
                } else {
                    chunks[id].push(data);
                }
            }
            return chunks;
        }

        function doubleToString(num) {
            return [].slice.call(
                new Uint8Array((new Float64Array([num])).buffer), 0).map(function(e) {
                return String.fromCharCode(e);
            }).reverse().join('');
        }

        var webm = new ArrayToWebM(frames.map(function(frame) {
            var webp = parseWebP(parseRIFF(atob(frame.image.slice(23))));
            webp.duration = frame.duration;
            return webp;
        }));

        postMessage(webm);
    }

    /**
     * Encodes frames in WebM container. It uses WebWorkinvoke to invoke 'ArrayToWebM' method.
     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.
     * @method
     * @memberof Whammy
     * @example
     * recorder = new Whammy().Video(0.8, 100);
     * recorder.compile(function(blob) {
     *    // blob.size - blob.type
     * });
     */
    WhammyVideo.prototype.compile = function(callback) {
        var webWorker = processInWebWorker(whammyInWebWorker);

        webWorker.onmessage = function(event) {
            if (event.data.error) {
                console.error(event.data.error);
                return;
            }
            callback(event.data);
        };

        webWorker.postMessage(this.frames);
    };

    return {
        /**
         * A more abstract-ish API.
         * @method
         * @memberof Whammy
         * @example
         * recorder = new Whammy().Video(0.8, 100);
         * @param {?number} speed - 0.8
         * @param {?number} quality - 100
         */
        Video: WhammyVideo
    };
})();

if (typeof RecordRTC !== 'undefined') {
    RecordRTC.Whammy = Whammy;
}

// ______________ (indexed-db)
// DiskStorage.js

/**
 * DiskStorage is a standalone object used by {@link RecordRTC} to store recorded blobs in IndexedDB storage.
 * @summary Writing blobs into IndexedDB.
 * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
 * @author {@link https://MuazKhan.com|Muaz Khan}
 * @example
 * DiskStorage.Store({
 *     audioBlob: yourAudioBlob,
 *     videoBlob: yourVideoBlob,
 *     gifBlob  : yourGifBlob
 * });
 * DiskStorage.Fetch(function(dataURL, type) {
 *     if(type === 'audioBlob') { }
 *     if(type === 'videoBlob') { }
 *     if(type === 'gifBlob')   { }
 * });
 * // DiskStorage.dataStoreName = 'recordRTC';
 * // DiskStorage.onError = function(error) { };
 * @property {function} init - This method must be called once to initialize IndexedDB ObjectStore. Though, it is auto-used internally.
 * @property {function} Fetch - This method fetches stored blobs from IndexedDB.
 * @property {function} Store - This method stores blobs in IndexedDB.
 * @property {function} onError - This function is invoked for any known/unknown error.
 * @property {string} dataStoreName - Name of the ObjectStore created in IndexedDB storage.
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 */


var DiskStorage = {
    /**
     * This method must be called once to initialize IndexedDB ObjectStore. Though, it is auto-used internally.
     * @method
     * @memberof DiskStorage
     * @internal
     * @example
     * DiskStorage.init();
     */
    init: function() {
        var self = this;

        if (typeof indexedDB === 'undefined' || typeof indexedDB.open === 'undefined') {
            console.error('IndexedDB API are not available in this browser.');
            return;
        }

        var dbVersion = 1;
        var dbName = this.dbName || location.href.replace(/\/|:|#|%|\.|\[|\]/g, ''),
            db;
        var request = indexedDB.open(dbName, dbVersion);

        function createObjectStore(dataBase) {
            dataBase.createObjectStore(self.dataStoreName);
        }

        function putInDB() {
            var transaction = db.transaction([self.dataStoreName], 'readwrite');

            if (self.videoBlob) {
                transaction.objectStore(self.dataStoreName).put(self.videoBlob, 'videoBlob');
            }

            if (self.gifBlob) {
                transaction.objectStore(self.dataStoreName).put(self.gifBlob, 'gifBlob');
            }

            if (self.audioBlob) {
                transaction.objectStore(self.dataStoreName).put(self.audioBlob, 'audioBlob');
            }

            function getFromStore(portionName) {
                transaction.objectStore(self.dataStoreName).get(portionName).onsuccess = function(event) {
                    if (self.callback) {
                        self.callback(event.target.result, portionName);
                    }
                };
            }

            getFromStore('audioBlob');
            getFromStore('videoBlob');
            getFromStore('gifBlob');
        }

        request.onerror = self.onError;

        request.onsuccess = function() {
            db = request.result;
            db.onerror = self.onError;

            if (db.setVersion) {
                if (db.version !== dbVersion) {
                    var setVersion = db.setVersion(dbVersion);
                    setVersion.onsuccess = function() {
                        createObjectStore(db);
                        putInDB();
                    };
                } else {
                    putInDB();
                }
            } else {
                putInDB();
            }
        };
        request.onupgradeneeded = function(event) {
            createObjectStore(event.target.result);
        };
    },
    /**
     * This method fetches stored blobs from IndexedDB.
     * @method
     * @memberof DiskStorage
     * @internal
     * @example
     * DiskStorage.Fetch(function(dataURL, type) {
     *     if(type === 'audioBlob') { }
     *     if(type === 'videoBlob') { }
     *     if(type === 'gifBlob')   { }
     * });
     */
    Fetch: function(callback) {
        this.callback = callback;
        this.init();

        return this;
    },
    /**
     * This method stores blobs in IndexedDB.
     * @method
     * @memberof DiskStorage
     * @internal
     * @example
     * DiskStorage.Store({
     *     audioBlob: yourAudioBlob,
     *     videoBlob: yourVideoBlob,
     *     gifBlob  : yourGifBlob
     * });
     */
    Store: function(config) {
        this.audioBlob = config.audioBlob;
        this.videoBlob = config.videoBlob;
        this.gifBlob = config.gifBlob;

        this.init();

        return this;
    },
    /**
     * This function is invoked for any known/unknown error.
     * @method
     * @memberof DiskStorage
     * @internal
     * @example
     * DiskStorage.onError = function(error){
     *     alerot( JSON.stringify(error) );
     * };
     */
    onError: function(error) {
        console.error(JSON.stringify(error, null, '\t'));
    },

    /**
     * @property {string} dataStoreName - Name of the ObjectStore created in IndexedDB storage.
     * @memberof DiskStorage
     * @internal
     * @example
     * DiskStorage.dataStoreName = 'recordRTC';
     */
    dataStoreName: 'recordRTC',
    dbName: null
};

if (typeof RecordRTC !== 'undefined') {
    RecordRTC.DiskStorage = DiskStorage;
}

// ______________
// GifRecorder.js

/**
 * GifRecorder is standalone calss used by {@link RecordRTC} to record video or canvas into animated gif.
 * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
 * @author {@link https://MuazKhan.com|Muaz Khan}
 * @typedef GifRecorder
 * @class
 * @example
 * var recorder = new GifRecorder(mediaStream || canvas || context, { onGifPreview: function, onGifRecordingStarted: function, width: 1280, height: 720, frameRate: 200, quality: 10 });
 * recorder.record();
 * recorder.stop(function(blob) {
 *     img.src = URL.createObjectURL(blob);
 * });
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 * @param {MediaStream} mediaStream - MediaStream object or HTMLCanvasElement or CanvasRenderingContext2D.
 * @param {object} config - {disableLogs:true, initCallback: function, width: 320, height: 240, frameRate: 200, quality: 10}
 */

function GifRecorder(mediaStream, config) {
    if (typeof GIFEncoder === 'undefined') {
        var script = document.createElement('script');
        script.src = 'https://www.webrtc-experiment.com/gif-recorder.js';
        (document.body || document.documentElement).appendChild(script);
    }

    config = config || {};

    var isHTMLObject = mediaStream instanceof CanvasRenderingContext2D || mediaStream instanceof HTMLCanvasElement;

    /**
     * This method records MediaStream.
     * @method
     * @memberof GifRecorder
     * @example
     * recorder.record();
     */
    this.record = function() {
        if (typeof GIFEncoder === 'undefined') {
            setTimeout(self.record, 1000);
            return;
        }

        if (!isLoadedMetaData) {
            setTimeout(self.record, 1000);
            return;
        }

        if (!isHTMLObject) {
            if (!config.width) {
                config.width = video.offsetWidth || 320;
            }

            if (!config.height) {
                config.height = video.offsetHeight || 240;
            }

            if (!config.video) {
                config.video = {
                    width: config.width,
                    height: config.height
                };
            }

            if (!config.canvas) {
                config.canvas = {
                    width: config.width,
                    height: config.height
                };
            }

            canvas.width = config.canvas.width || 320;
            canvas.height = config.canvas.height || 240;

            video.width = config.video.width || 320;
            video.height = config.video.height || 240;
        }

        // external library to record as GIF images
        gifEncoder = new GIFEncoder();

        // void setRepeat(int iter) 
        // Sets the number of times the set of GIF frames should be played. 
        // Default is 1; 0 means play indefinitely.
        gifEncoder.setRepeat(0);

        // void setFrameRate(Number fps) 
        // Sets frame rate in frames per second. 
        // Equivalent to setDelay(1000/fps).
        // Using "setDelay" instead of "setFrameRate"
        gifEncoder.setDelay(config.frameRate || 200);

        // void setQuality(int quality) 
        // Sets quality of color quantization (conversion of images to the 
        // maximum 256 colors allowed by the GIF specification). 
        // Lower values (minimum = 1) produce better colors, 
        // but slow processing significantly. 10 is the default, 
        // and produces good color mapping at reasonable speeds. 
        // Values greater than 20 do not yield significant improvements in speed.
        gifEncoder.setQuality(config.quality || 10);

        // Boolean start() 
        // This writes the GIF Header and returns false if it fails.
        gifEncoder.start();

        if (typeof config.onGifRecordingStarted === 'function') {
            config.onGifRecordingStarted();
        }

        startTime = Date.now();

        function drawVideoFrame(time) {
            if (self.clearedRecordedData === true) {
                return;
            }

            if (isPausedRecording) {
                return setTimeout(function() {
                    drawVideoFrame(time);
                }, 100);
            }

            lastAnimationFrame = requestAnimationFrame(drawVideoFrame);

            if (typeof lastFrameTime === undefined) {
                lastFrameTime = time;
            }

            // ~10 fps
            if (time - lastFrameTime < 90) {
                return;
            }

            if (!isHTMLObject && video.paused) {
                // via: https://github.com/muaz-khan/WebRTC-Experiment/pull/316
                // Tweak for Android Chrome
                video.play();
            }

            if (!isHTMLObject) {
                context.drawImage(video, 0, 0, canvas.width, canvas.height);
            }

            if (config.onGifPreview) {
                config.onGifPreview(canvas.toDataURL('image/png'));
            }

            gifEncoder.addFrame(context);
            lastFrameTime = time;
        }

        lastAnimationFrame = requestAnimationFrame(drawVideoFrame);

        if (config.initCallback) {
            config.initCallback();
        }
    };

    /**
     * This method stops recording MediaStream.
     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.
     * @method
     * @memberof GifRecorder
     * @example
     * recorder.stop(function(blob) {
     *     img.src = URL.createObjectURL(blob);
     * });
     */
    this.stop = function(callback) {
        callback = callback || function() {};

        if (lastAnimationFrame) {
            cancelAnimationFrame(lastAnimationFrame);
        }

        endTime = Date.now();

        /**
         * @property {Blob} blob - The recorded blob object.
         * @memberof GifRecorder
         * @example
         * recorder.stop(function(){
         *     var blob = recorder.blob;
         * });
         */
        this.blob = new Blob([new Uint8Array(gifEncoder.stream().bin)], {
            type: 'image/gif'
        });

        callback(this.blob);

        // bug: find a way to clear old recorded blobs
        gifEncoder.stream().bin = [];
    };

    var isPausedRecording = false;

    /**
     * This method pauses the recording process.
     * @method
     * @memberof GifRecorder
     * @example
     * recorder.pause();
     */
    this.pause = function() {
        isPausedRecording = true;
    };

    /**
     * This method resumes the recording process.
     * @method
     * @memberof GifRecorder
     * @example
     * recorder.resume();
     */
    this.resume = function() {
        isPausedRecording = false;
    };

    /**
     * This method resets currently recorded data.
     * @method
     * @memberof GifRecorder
     * @example
     * recorder.clearRecordedData();
     */
    this.clearRecordedData = function() {
        self.clearedRecordedData = true;
        clearRecordedDataCB();
    };

    function clearRecordedDataCB() {
        if (gifEncoder) {
            gifEncoder.stream().bin = [];
        }
    }

    // for debugging
    this.name = 'GifRecorder';
    this.toString = function() {
        return this.name;
    };

    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');

    if (isHTMLObject) {
        if (mediaStream instanceof CanvasRenderingContext2D) {
            context = mediaStream;
            canvas = context.canvas;
        } else if (mediaStream instanceof HTMLCanvasElement) {
            context = mediaStream.getContext('2d');
            canvas = mediaStream;
        }
    }

    var isLoadedMetaData = true;

    if (!isHTMLObject) {
        var video = document.createElement('video');
        video.muted = true;
        video.autoplay = true;
        video.playsInline = true;

        isLoadedMetaData = false;
        video.onloadedmetadata = function() {
            isLoadedMetaData = true;
        };

        setSrcObject(mediaStream, video);

        video.play();
    }

    var lastAnimationFrame = null;
    var startTime, endTime, lastFrameTime;

    var gifEncoder;

    var self = this;
}

if (typeof RecordRTC !== 'undefined') {
    RecordRTC.GifRecorder = GifRecorder;
}

// Last time updated: 2019-06-21 4:09:42 AM UTC

// ________________________
// MultiStreamsMixer v1.2.2

// Open-Sourced: https://github.com/muaz-khan/MultiStreamsMixer

// --------------------------------------------------
// Muaz Khan     - www.MuazKhan.com
// MIT License   - www.WebRTC-Experiment.com/licence
// --------------------------------------------------

function MultiStreamsMixer(arrayOfMediaStreams, elementClass) {

    var browserFakeUserAgent = 'Fake/5.0 (FakeOS) AppleWebKit/123 (KHTML, like Gecko) Fake/12.3.4567.89 Fake/123.45';

    (function(that) {
        if (typeof RecordRTC !== 'undefined') {
            return;
        }

        if (!that) {
            return;
        }

        if (typeof window !== 'undefined') {
            return;
        }

        if (typeof global === 'undefined') {
            return;
        }

        global.navigator = {
            userAgent: browserFakeUserAgent,
            getUserMedia: function() {}
        };

        if (!global.console) {
            global.console = {};
        }

        if (typeof global.console.log === 'undefined' || typeof global.console.error === 'undefined') {
            global.console.error = global.console.log = global.console.log || function() {
                console.log(arguments);
            };
        }

        if (typeof document === 'undefined') {
            /*global document:true */
            that.document = {
                documentElement: {
                    appendChild: function() {
                        return '';
                    }
                }
            };

            document.createElement = document.captureStream = document.mozCaptureStream = function() {
                var obj = {
                    getContext: function() {
                        return obj;
                    },
                    play: function() {},
                    pause: function() {},
                    drawImage: function() {},
                    toDataURL: function() {
                        return '';
                    },
                    style: {}
                };
                return obj;
            };

            that.HTMLVideoElement = function() {};
        }

        if (typeof location === 'undefined') {
            /*global location:true */
            that.location = {
                protocol: 'file:',
                href: '',
                hash: ''
            };
        }

        if (typeof screen === 'undefined') {
            /*global screen:true */
            that.screen = {
                width: 0,
                height: 0
            };
        }

        if (typeof URL === 'undefined') {
            /*global screen:true */
            that.URL = {
                createObjectURL: function() {
                    return '';
                },
                revokeObjectURL: function() {
                    return '';
                }
            };
        }

        /*global window:true */
        that.window = global;
    })(typeof global !== 'undefined' ? global : null);

    // requires: chrome://flags/#enable-experimental-web-platform-features

    elementClass = elementClass || 'multi-streams-mixer';

    var videos = [];
    var isStopDrawingFrames = false;

    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');
    canvas.style.opacity = 0;
    canvas.style.position = 'absolute';
    canvas.style.zIndex = -1;
    canvas.style.top = '-1000em';
    canvas.style.left = '-1000em';
    canvas.className = elementClass;
    (document.body || document.documentElement).appendChild(canvas);

    this.disableLogs = false;
    this.frameInterval = 10;

    this.width = 360;
    this.height = 240;

    // use gain node to prevent echo
    this.useGainNode = true;

    var self = this;

    // _____________________________
    // Cross-Browser-Declarations.js

    // WebAudio API representer
    var AudioContext = window.AudioContext;

    if (typeof AudioContext === 'undefined') {
        if (typeof webkitAudioContext !== 'undefined') {
            /*global AudioContext:true */
            AudioContext = webkitAudioContext;
        }

        if (typeof mozAudioContext !== 'undefined') {
            /*global AudioContext:true */
            AudioContext = mozAudioContext;
        }
    }

    /*jshint -W079 */
    var URL = window.URL;

    if (typeof URL === 'undefined' && typeof webkitURL !== 'undefined') {
        /*global URL:true */
        URL = webkitURL;
    }

    if (typeof navigator !== 'undefined' && typeof navigator.getUserMedia === 'undefined') { // maybe window.navigator?
        if (typeof navigator.webkitGetUserMedia !== 'undefined') {
            navigator.getUserMedia = navigator.webkitGetUserMedia;
        }

        if (typeof navigator.mozGetUserMedia !== 'undefined') {
            navigator.getUserMedia = navigator.mozGetUserMedia;
        }
    }

    var MediaStream = window.MediaStream;

    if (typeof MediaStream === 'undefined' && typeof webkitMediaStream !== 'undefined') {
        MediaStream = webkitMediaStream;
    }

    /*global MediaStream:true */
    if (typeof MediaStream !== 'undefined') {
        // override "stop" method for all browsers
        if (typeof MediaStream.prototype.stop === 'undefined') {
            MediaStream.prototype.stop = function() {
                this.getTracks().forEach(function(track) {
                    track.stop();
                });
            };
        }
    }

    var Storage = {};

    if (typeof AudioContext !== 'undefined') {
        Storage.AudioContext = AudioContext;
    } else if (typeof webkitAudioContext !== 'undefined') {
        Storage.AudioContext = webkitAudioContext;
    }

    function setSrcObject(stream, element) {
        if ('srcObject' in element) {
            element.srcObject = stream;
        } else if ('mozSrcObject' in element) {
            element.mozSrcObject = stream;
        } else {
            element.srcObject = stream;
        }
    }

    this.startDrawingFrames = function() {
        drawVideosToCanvas();
    };

    function drawVideosToCanvas() {
        if (isStopDrawingFrames) {
            return;
        }

        var videosLength = videos.length;

        var fullcanvas = false;
        var remaining = [];
        videos.forEach(function(video) {
            if (!video.stream) {
                video.stream = {};
            }

            if (video.stream.fullcanvas) {
                fullcanvas = video;
            } else {
                // todo: video.stream.active or video.stream.live to fix blank frames issues?
                remaining.push(video);
            }
        });

        if (fullcanvas) {
            canvas.width = fullcanvas.stream.width;
            canvas.height = fullcanvas.stream.height;
        } else if (remaining.length) {
            canvas.width = videosLength > 1 ? remaining[0].width * 2 : remaining[0].width;

            var height = 1;
            if (videosLength === 3 || videosLength === 4) {
                height = 2;
            }
            if (videosLength === 5 || videosLength === 6) {
                height = 3;
            }
            if (videosLength === 7 || videosLength === 8) {
                height = 4;
            }
            if (videosLength === 9 || videosLength === 10) {
                height = 5;
            }
            canvas.height = remaining[0].height * height;
        } else {
            canvas.width = self.width || 360;
            canvas.height = self.height || 240;
        }

        if (fullcanvas && fullcanvas instanceof HTMLVideoElement) {
            drawImage(fullcanvas);
        }

        remaining.forEach(function(video, idx) {
            drawImage(video, idx);
        });

        setTimeout(drawVideosToCanvas, self.frameInterval);
    }

    function drawImage(video, idx) {
        if (isStopDrawingFrames) {
            return;
        }

        var x = 0;
        var y = 0;
        var width = video.width;
        var height = video.height;

        if (idx === 1) {
            x = video.width;
        }

        if (idx === 2) {
            y = video.height;
        }

        if (idx === 3) {
            x = video.width;
            y = video.height;
        }

        if (idx === 4) {
            y = video.height * 2;
        }

        if (idx === 5) {
            x = video.width;
            y = video.height * 2;
        }

        if (idx === 6) {
            y = video.height * 3;
        }

        if (idx === 7) {
            x = video.width;
            y = video.height * 3;
        }

        if (typeof video.stream.left !== 'undefined') {
            x = video.stream.left;
        }

        if (typeof video.stream.top !== 'undefined') {
            y = video.stream.top;
        }

        if (typeof video.stream.width !== 'undefined') {
            width = video.stream.width;
        }

        if (typeof video.stream.height !== 'undefined') {
            height = video.stream.height;
        }

        context.drawImage(video, x, y, width, height);

        if (typeof video.stream.onRender === 'function') {
            video.stream.onRender(context, x, y, width, height, idx);
        }
    }

    function getMixedStream() {
        isStopDrawingFrames = false;
        var mixedVideoStream = getMixedVideoStream();

        var mixedAudioStream = getMixedAudioStream();
        if (mixedAudioStream) {
            mixedAudioStream.getTracks().filter(function(t) {
                return t.kind === 'audio';
            }).forEach(function(track) {
                mixedVideoStream.addTrack(track);
            });
        }

        var fullcanvas;
        arrayOfMediaStreams.forEach(function(stream) {
            if (stream.fullcanvas) {
                fullcanvas = true;
            }
        });

        // mixedVideoStream.prototype.appendStreams = appendStreams;
        // mixedVideoStream.prototype.resetVideoStreams = resetVideoStreams;
        // mixedVideoStream.prototype.clearRecordedData = clearRecordedData;

        return mixedVideoStream;
    }

    function getMixedVideoStream() {
        resetVideoStreams();

        var capturedStream;

        if ('captureStream' in canvas) {
            capturedStream = canvas.captureStream();
        } else if ('mozCaptureStream' in canvas) {
            capturedStream = canvas.mozCaptureStream();
        } else if (!self.disableLogs) {
            console.error('Upgrade to latest Chrome or otherwise enable this flag: chrome://flags/#enable-experimental-web-platform-features');
        }

        var videoStream = new MediaStream();

        capturedStream.getTracks().filter(function(t) {
            return t.kind === 'video';
        }).forEach(function(track) {
            videoStream.addTrack(track);
        });

        canvas.stream = videoStream;

        return videoStream;
    }

    function getMixedAudioStream() {
        // via: @pehrsons
        if (!Storage.AudioContextConstructor) {
            Storage.AudioContextConstructor = new Storage.AudioContext();
        }

        self.audioContext = Storage.AudioContextConstructor;

        self.audioSources = [];

        if (self.useGainNode === true) {
            self.gainNode = self.audioContext.createGain();
            self.gainNode.connect(self.audioContext.destination);
            self.gainNode.gain.value = 0; // don't hear self
        }

        var audioTracksLength = 0;
        arrayOfMediaStreams.forEach(function(stream) {
            if (!stream.getTracks().filter(function(t) {
                    return t.kind === 'audio';
                }).length) {
                return;
            }

            audioTracksLength++;

            var audioSource = self.audioContext.createMediaStreamSource(stream);

            if (self.useGainNode === true) {
                audioSource.connect(self.gainNode);
            }

            self.audioSources.push(audioSource);
        });

        if (!audioTracksLength) {
            // because "self.audioContext" is not initialized
            // that's why we've to ignore rest of the code
            return;
        }

        self.audioDestination = self.audioContext.createMediaStreamDestination();
        self.audioSources.forEach(function(audioSource) {
            audioSource.connect(self.audioDestination);
        });
        return self.audioDestination.stream;
    }

    function getVideo(stream) {
        var video = document.createElement('video');

        setSrcObject(stream, video);

        video.className = elementClass;

        video.muted = true;
        video.volume = 0;

        video.width = stream.width || self.width || 360;
        video.height = stream.height || self.height || 240;

        video.play();

        return video;
    }

    this.appendStreams = function(streams) {
        if (!streams) {
            throw 'First parameter is required.';
        }

        if (!(streams instanceof Array)) {
            streams = [streams];
        }

        streams.forEach(function(stream) {
            var newStream = new MediaStream();

            if (stream.getTracks().filter(function(t) {
                    return t.kind === 'video';
                }).length) {
                var video = getVideo(stream);
                video.stream = stream;
                videos.push(video);

                newStream.addTrack(stream.getTracks().filter(function(t) {
                    return t.kind === 'video';
                })[0]);
            }

            if (stream.getTracks().filter(function(t) {
                    return t.kind === 'audio';
                }).length) {
                var audioSource = self.audioContext.createMediaStreamSource(stream);
                self.audioDestination = self.audioContext.createMediaStreamDestination();
                audioSource.connect(self.audioDestination);

                newStream.addTrack(self.audioDestination.stream.getTracks().filter(function(t) {
                    return t.kind === 'audio';
                })[0]);
            }

            arrayOfMediaStreams.push(newStream);
        });
    };

    this.releaseStreams = function() {
        videos = [];
        isStopDrawingFrames = true;

        if (self.gainNode) {
            self.gainNode.disconnect();
            self.gainNode = null;
        }

        if (self.audioSources.length) {
            self.audioSources.forEach(function(source) {
                source.disconnect();
            });
            self.audioSources = [];
        }

        if (self.audioDestination) {
            self.audioDestination.disconnect();
            self.audioDestination = null;
        }

        if (self.audioContext) {
            self.audioContext.close();
        }

        self.audioContext = null;

        context.clearRect(0, 0, canvas.width, canvas.height);

        if (canvas.stream) {
            canvas.stream.stop();
            canvas.stream = null;
        }
    };

    this.resetVideoStreams = function(streams) {
        if (streams && !(streams instanceof Array)) {
            streams = [streams];
        }

        resetVideoStreams(streams);
    };

    function resetVideoStreams(streams) {
        videos = [];
        streams = streams || arrayOfMediaStreams;

        // via: @adrian-ber
        streams.forEach(function(stream) {
            if (!stream.getTracks().filter(function(t) {
                    return t.kind === 'video';
                }).length) {
                return;
            }

            var video = getVideo(stream);
            video.stream = stream;
            videos.push(video);
        });
    }

    // for debugging
    this.name = 'MultiStreamsMixer';
    this.toString = function() {
        return this.name;
    };

    this.getMixedStream = getMixedStream;

}

if (typeof RecordRTC === 'undefined') {
    if (true /* && !!module.exports*/ ) {
        module.exports = MultiStreamsMixer;
    }

    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
            return MultiStreamsMixer;
        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
}

// ______________________
// MultiStreamRecorder.js

/*
 * Video conference recording, using captureStream API along with WebAudio and Canvas2D API.
 */

/**
 * MultiStreamRecorder can record multiple videos in single container.
 * @summary Multi-videos recorder.
 * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
 * @author {@link https://MuazKhan.com|Muaz Khan}
 * @typedef MultiStreamRecorder
 * @class
 * @example
 * var options = {
 *     mimeType: 'video/webm'
 * }
 * var recorder = new MultiStreamRecorder(ArrayOfMediaStreams, options);
 * recorder.record();
 * recorder.stop(function(blob) {
 *     video.src = URL.createObjectURL(blob);
 *
 *     // or
 *     var blob = recorder.blob;
 * });
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 * @param {MediaStreams} mediaStreams - Array of MediaStreams.
 * @param {object} config - {disableLogs:true, frameInterval: 1, mimeType: "video/webm"}
 */

function MultiStreamRecorder(arrayOfMediaStreams, options) {
    arrayOfMediaStreams = arrayOfMediaStreams || [];
    var self = this;

    var mixer;
    var mediaRecorder;

    options = options || {
        elementClass: 'multi-streams-mixer',
        mimeType: 'video/webm',
        video: {
            width: 360,
            height: 240
        }
    };

    if (!options.frameInterval) {
        options.frameInterval = 10;
    }

    if (!options.video) {
        options.video = {};
    }

    if (!options.video.width) {
        options.video.width = 360;
    }

    if (!options.video.height) {
        options.video.height = 240;
    }

    /**
     * This method records all MediaStreams.
     * @method
     * @memberof MultiStreamRecorder
     * @example
     * recorder.record();
     */
    this.record = function() {
        // github/muaz-khan/MultiStreamsMixer
        mixer = new MultiStreamsMixer(arrayOfMediaStreams, options.elementClass || 'multi-streams-mixer');

        if (getAllVideoTracks().length) {
            mixer.frameInterval = options.frameInterval || 10;
            mixer.width = options.video.width || 360;
            mixer.height = options.video.height || 240;
            mixer.startDrawingFrames();
        }

        if (options.previewStream && typeof options.previewStream === 'function') {
            options.previewStream(mixer.getMixedStream());
        }

        // record using MediaRecorder API
        mediaRecorder = new MediaStreamRecorder(mixer.getMixedStream(), options);
        mediaRecorder.record();
    };

    function getAllVideoTracks() {
        var tracks = [];
        arrayOfMediaStreams.forEach(function(stream) {
            getTracks(stream, 'video').forEach(function(track) {
                tracks.push(track);
            });
        });
        return tracks;
    }

    /**
     * This method stops recording MediaStream.
     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.
     * @method
     * @memberof MultiStreamRecorder
     * @example
     * recorder.stop(function(blob) {
     *     video.src = URL.createObjectURL(blob);
     * });
     */
    this.stop = function(callback) {
        if (!mediaRecorder) {
            return;
        }

        mediaRecorder.stop(function(blob) {
            self.blob = blob;

            callback(blob);

            self.clearRecordedData();
        });
    };

    /**
     * This method pauses the recording process.
     * @method
     * @memberof MultiStreamRecorder
     * @example
     * recorder.pause();
     */
    this.pause = function() {
        if (mediaRecorder) {
            mediaRecorder.pause();
        }
    };

    /**
     * This method resumes the recording process.
     * @method
     * @memberof MultiStreamRecorder
     * @example
     * recorder.resume();
     */
    this.resume = function() {
        if (mediaRecorder) {
            mediaRecorder.resume();
        }
    };

    /**
     * This method resets currently recorded data.
     * @method
     * @memberof MultiStreamRecorder
     * @example
     * recorder.clearRecordedData();
     */
    this.clearRecordedData = function() {
        if (mediaRecorder) {
            mediaRecorder.clearRecordedData();
            mediaRecorder = null;
        }

        if (mixer) {
            mixer.releaseStreams();
            mixer = null;
        }
    };

    /**
     * Add extra media-streams to existing recordings.
     * @method
     * @memberof MultiStreamRecorder
     * @param {MediaStreams} mediaStreams - Array of MediaStreams
     * @example
     * recorder.addStreams([newAudioStream, newVideoStream]);
     */
    this.addStreams = function(streams) {
        if (!streams) {
            throw 'First parameter is required.';
        }

        if (!(streams instanceof Array)) {
            streams = [streams];
        }

        arrayOfMediaStreams.concat(streams);

        if (!mediaRecorder || !mixer) {
            return;
        }

        mixer.appendStreams(streams);

        if (options.previewStream && typeof options.previewStream === 'function') {
            options.previewStream(mixer.getMixedStream());
        }
    };

    /**
     * Reset videos during live recording. Replace old videos e.g. replace cameras with full-screen.
     * @method
     * @memberof MultiStreamRecorder
     * @param {MediaStreams} mediaStreams - Array of MediaStreams
     * @example
     * recorder.resetVideoStreams([newVideo1, newVideo2]);
     */
    this.resetVideoStreams = function(streams) {
        if (!mixer) {
            return;
        }

        if (streams && !(streams instanceof Array)) {
            streams = [streams];
        }

        mixer.resetVideoStreams(streams);
    };

    /**
     * Returns MultiStreamsMixer
     * @method
     * @memberof MultiStreamRecorder
     * @example
     * let mixer = recorder.getMixer();
     * mixer.appendStreams([newStream]);
     */
    this.getMixer = function() {
        return mixer;
    };

    // for debugging
    this.name = 'MultiStreamRecorder';
    this.toString = function() {
        return this.name;
    };
}

if (typeof RecordRTC !== 'undefined') {
    RecordRTC.MultiStreamRecorder = MultiStreamRecorder;
}

// _____________________
// RecordRTC.promises.js

/**
 * RecordRTCPromisesHandler adds promises support in {@link RecordRTC}. Try a {@link https://github.com/muaz-khan/RecordRTC/blob/master/simple-demos/RecordRTCPromisesHandler.html|demo here}
 * @summary Promises for {@link RecordRTC}
 * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
 * @author {@link https://MuazKhan.com|Muaz Khan}
 * @typedef RecordRTCPromisesHandler
 * @class
 * @example
 * var recorder = new RecordRTCPromisesHandler(mediaStream, options);
 * recorder.startRecording()
 *         .then(successCB)
 *         .catch(errorCB);
 * // Note: You can access all RecordRTC API using "recorder.recordRTC" e.g. 
 * recorder.recordRTC.onStateChanged = function(state) {};
 * recorder.recordRTC.setRecordingDuration(5000);
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 * @param {MediaStream} mediaStream - Single media-stream object, array of media-streams, html-canvas-element, etc.
 * @param {object} config - {type:"video", recorderType: MediaStreamRecorder, disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, video: HTMLVideoElement, etc.}
 * @throws Will throw an error if "new" keyword is not used to initiate "RecordRTCPromisesHandler". Also throws error if first argument "MediaStream" is missing.
 * @requires {@link RecordRTC}
 */

function RecordRTCPromisesHandler(mediaStream, options) {
    if (!this) {
        throw 'Use "new RecordRTCPromisesHandler()"';
    }

    if (typeof mediaStream === 'undefined') {
        throw 'First argument "MediaStream" is required.';
    }

    var self = this;

    /**
     * @property {Blob} blob - Access/reach the native {@link RecordRTC} object.
     * @memberof RecordRTCPromisesHandler
     * @example
     * let internal = recorder.recordRTC.getInternalRecorder();
     * alert(internal instanceof MediaStreamRecorder);
     * recorder.recordRTC.onStateChanged = function(state) {};
     */
    self.recordRTC = new RecordRTC(mediaStream, options);

    /**
     * This method records MediaStream.
     * @method
     * @memberof RecordRTCPromisesHandler
     * @example
     * recorder.startRecording()
     *         .then(successCB)
     *         .catch(errorCB);
     */
    this.startRecording = function() {
        return new Promise(function(resolve, reject) {
            try {
                self.recordRTC.startRecording();
                resolve();
            } catch (e) {
                reject(e);
            }
        });
    };

    /**
     * This method stops the recording.
     * @method
     * @memberof RecordRTCPromisesHandler
     * @example
     * recorder.stopRecording().then(function() {
     *     var blob = recorder.getBlob();
     * }).catch(errorCB);
     */
    this.stopRecording = function() {
        return new Promise(function(resolve, reject) {
            try {
                self.recordRTC.stopRecording(function(url) {
                    self.blob = self.recordRTC.getBlob();

                    if (!self.blob || !self.blob.size) {
                        reject('Empty blob.', self.blob);
                        return;
                    }

                    resolve(url);
                });
            } catch (e) {
                reject(e);
            }
        });
    };

    /**
     * This method pauses the recording. You can resume recording using "resumeRecording" method.
     * @method
     * @memberof RecordRTCPromisesHandler
     * @example
     * recorder.pauseRecording()
     *         .then(successCB)
     *         .catch(errorCB);
     */
    this.pauseRecording = function() {
        return new Promise(function(resolve, reject) {
            try {
                self.recordRTC.pauseRecording();
                resolve();
            } catch (e) {
                reject(e);
            }
        });
    };

    /**
     * This method resumes the recording.
     * @method
     * @memberof RecordRTCPromisesHandler
     * @example
     * recorder.resumeRecording()
     *         .then(successCB)
     *         .catch(errorCB);
     */
    this.resumeRecording = function() {
        return new Promise(function(resolve, reject) {
            try {
                self.recordRTC.resumeRecording();
                resolve();
            } catch (e) {
                reject(e);
            }
        });
    };

    /**
     * This method returns data-url for the recorded blob.
     * @method
     * @memberof RecordRTCPromisesHandler
     * @example
     * recorder.stopRecording().then(function() {
     *     recorder.getDataURL().then(function(dataURL) {
     *         window.open(dataURL);
     *     }).catch(errorCB);;
     * }).catch(errorCB);
     */
    this.getDataURL = function(callback) {
        return new Promise(function(resolve, reject) {
            try {
                self.recordRTC.getDataURL(function(dataURL) {
                    resolve(dataURL);
                });
            } catch (e) {
                reject(e);
            }
        });
    };

    /**
     * This method returns the recorded blob.
     * @method
     * @memberof RecordRTCPromisesHandler
     * @example
     * recorder.stopRecording().then(function() {
     *     recorder.getBlob().then(function(blob) {})
     * }).catch(errorCB);
     */
    this.getBlob = function() {
        return new Promise(function(resolve, reject) {
            try {
                resolve(self.recordRTC.getBlob());
            } catch (e) {
                reject(e);
            }
        });
    };

    /**
     * This method returns the internal recording object.
     * @method
     * @memberof RecordRTCPromisesHandler
     * @example
     * let internalRecorder = await recorder.getInternalRecorder();
     * if(internalRecorder instanceof MultiStreamRecorder) {
     *     internalRecorder.addStreams([newAudioStream]);
     *     internalRecorder.resetVideoStreams([screenStream]);
     * }
     * @returns {Object} 
     */
    this.getInternalRecorder = function() {
        return new Promise(function(resolve, reject) {
            try {
                resolve(self.recordRTC.getInternalRecorder());
            } catch (e) {
                reject(e);
            }
        });
    };

    /**
     * This method resets the recorder. So that you can reuse single recorder instance many times.
     * @method
     * @memberof RecordRTCPromisesHandler
     * @example
     * await recorder.reset();
     * recorder.startRecording(); // record again
     */
    this.reset = function() {
        return new Promise(function(resolve, reject) {
            try {
                resolve(self.recordRTC.reset());
            } catch (e) {
                reject(e);
            }
        });
    };

    /**
     * Destroy RecordRTC instance. Clear all recorders and objects.
     * @method
     * @memberof RecordRTCPromisesHandler
     * @example
     * recorder.destroy().then(successCB).catch(errorCB);
     */
    this.destroy = function() {
        return new Promise(function(resolve, reject) {
            try {
                resolve(self.recordRTC.destroy());
            } catch (e) {
                reject(e);
            }
        });
    };

    /**
     * Get recorder's readonly state.
     * @method
     * @memberof RecordRTCPromisesHandler
     * @example
     * let state = await recorder.getState();
     * // or
     * recorder.getState().then(state => { console.log(state); })
     * @returns {String} Returns recording state.
     */
    this.getState = function() {
        return new Promise(function(resolve, reject) {
            try {
                resolve(self.recordRTC.getState());
            } catch (e) {
                reject(e);
            }
        });
    };

    /**
     * @property {Blob} blob - Recorded data as "Blob" object.
     * @memberof RecordRTCPromisesHandler
     * @example
     * await recorder.stopRecording();
     * let blob = recorder.getBlob(); // or "recorder.recordRTC.blob"
     * invokeSaveAsDialog(blob);
     */
    this.blob = null;

    /**
     * RecordRTC version number
     * @property {String} version - Release version number.
     * @memberof RecordRTCPromisesHandler
     * @static
     * @readonly
     * @example
     * alert(recorder.version);
     */
    this.version = '5.6.2';
}

if (typeof RecordRTC !== 'undefined') {
    RecordRTC.RecordRTCPromisesHandler = RecordRTCPromisesHandler;
}

// ______________________
// WebAssemblyRecorder.js

/**
 * WebAssemblyRecorder lets you create webm videos in JavaScript via WebAssembly. The library consumes raw RGBA32 buffers (4 bytes per pixel) and turns them into a webm video with the given framerate and quality. This makes it compatible out-of-the-box with ImageData from a CANVAS. With realtime mode you can also use webm-wasm for streaming webm videos.
 * @summary Video recording feature in Chrome, Firefox and maybe Edge.
 * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
 * @author {@link https://MuazKhan.com|Muaz Khan}
 * @typedef WebAssemblyRecorder
 * @class
 * @example
 * var recorder = new WebAssemblyRecorder(mediaStream);
 * recorder.record();
 * recorder.stop(function(blob) {
 *     video.src = URL.createObjectURL(blob);
 * });
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
 * @param {object} config - {webAssemblyPath:'webm-wasm.wasm',workerPath: 'webm-worker.js', frameRate: 30, width: 1920, height: 1080, bitrate: 1024, realtime: true}
 */
function WebAssemblyRecorder(stream, config) {
    // based on: github.com/GoogleChromeLabs/webm-wasm

    if (typeof ReadableStream === 'undefined' || typeof WritableStream === 'undefined') {
        // because it fixes readable/writable streams issues
        console.error('Following polyfill is strongly recommended: https://unpkg.com/@mattiasbuelens/web-streams-polyfill/dist/polyfill.min.js');
    }

    config = config || {};

    config.width = config.width || 640;
    config.height = config.height || 480;
    config.frameRate = config.frameRate || 30;
    config.bitrate = config.bitrate || 1200;
    config.realtime = config.realtime || true;

    function createBufferURL(buffer, type) {
        return URL.createObjectURL(new Blob([buffer], {
            type: type || ''
        }));
    }

    var finished;

    function cameraStream() {
        return new ReadableStream({
            start: function(controller) {
                var cvs = document.createElement('canvas');
                var video = document.createElement('video');
                var first = true;
                video.srcObject = stream;
                video.muted = true;
                video.height = config.height;
                video.width = config.width;
                video.volume = 0;
                video.onplaying = function() {
                    cvs.width = config.width;
                    cvs.height = config.height;
                    var ctx = cvs.getContext('2d');
                    var frameTimeout = 1000 / config.frameRate;
                    var cameraTimer = setInterval(function f() {
                        if (finished) {
                            clearInterval(cameraTimer);
                            controller.close();
                        }

                        if (first) {
                            first = false;
                            if (config.onVideoProcessStarted) {
                                config.onVideoProcessStarted();
                            }
                        }

                        ctx.drawImage(video, 0, 0);
                        if (controller._controlledReadableStream.state !== 'closed') {
                            try {
                                controller.enqueue(
                                    ctx.getImageData(0, 0, config.width, config.height)
                                );
                            } catch (e) {}
                        }
                    }, frameTimeout);
                };
                video.play();
            }
        });
    }

    var worker;

    function startRecording(stream, buffer) {
        if (!config.workerPath && !buffer) {
            finished = false;

            // is it safe to use @latest ?

            fetch(
                'https://unpkg.com/webm-wasm@latest/dist/webm-worker.js'
            ).then(function(r) {
                r.arrayBuffer().then(function(buffer) {
                    startRecording(stream, buffer);
                });
            });
            return;
        }

        if (!config.workerPath && buffer instanceof ArrayBuffer) {
            var blob = new Blob([buffer], {
                type: 'text/javascript'
            });
            config.workerPath = URL.createObjectURL(blob);
        }

        if (!config.workerPath) {
            console.error('workerPath parameter is missing.');
        }

        worker = new Worker(config.workerPath);

        worker.postMessage(config.webAssemblyPath || 'https://unpkg.com/webm-wasm@latest/dist/webm-wasm.wasm');
        worker.addEventListener('message', function(event) {
            if (event.data === 'READY') {
                worker.postMessage({
                    width: config.width,
                    height: config.height,
                    bitrate: config.bitrate || 1200,
                    timebaseDen: config.frameRate || 30,
                    realtime: config.realtime
                });

                cameraStream().pipeTo(new WritableStream({
                    write: function(image) {
                        if (finished) {
                            console.error('Got image, but recorder is finished!');
                            return;
                        }

                        worker.postMessage(image.data.buffer, [image.data.buffer]);
                    }
                }));
            } else if (!!event.data) {
                if (!isPaused) {
                    arrayOfBuffers.push(event.data);
                }
            }
        });
    }

    /**
     * This method records video.
     * @method
     * @memberof WebAssemblyRecorder
     * @example
     * recorder.record();
     */
    this.record = function() {
        arrayOfBuffers = [];
        isPaused = false;
        this.blob = null;
        startRecording(stream);

        if (typeof config.initCallback === 'function') {
            config.initCallback();
        }
    };

    var isPaused;

    /**
     * This method pauses the recording process.
     * @method
     * @memberof WebAssemblyRecorder
     * @example
     * recorder.pause();
     */
    this.pause = function() {
        isPaused = true;
    };

    /**
     * This method resumes the recording process.
     * @method
     * @memberof WebAssemblyRecorder
     * @example
     * recorder.resume();
     */
    this.resume = function() {
        isPaused = false;
    };

    function terminate(callback) {
        if (!worker) {
            if (callback) {
                callback();
            }

            return;
        }

        // Wait for null event data to indicate that the encoding is complete
        worker.addEventListener('message', function(event) {
            if (event.data === null) {
                worker.terminate();
                worker = null;

                if (callback) {
                    callback();
                }
            }
        });

        worker.postMessage(null);
    }

    var arrayOfBuffers = [];

    /**
     * This method stops recording video.
     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.
     * @method
     * @memberof WebAssemblyRecorder
     * @example
     * recorder.stop(function(blob) {
     *     video.src = URL.createObjectURL(blob);
     * });
     */
    this.stop = function(callback) {
        finished = true;

        var recorder = this;

        terminate(function() {
            recorder.blob = new Blob(arrayOfBuffers, {
                type: 'video/webm'
            });

            callback(recorder.blob);
        });
    };

    // for debugging
    this.name = 'WebAssemblyRecorder';
    this.toString = function() {
        return this.name;
    };

    /**
     * This method resets currently recorded data.
     * @method
     * @memberof WebAssemblyRecorder
     * @example
     * recorder.clearRecordedData();
     */
    this.clearRecordedData = function() {
        arrayOfBuffers = [];
        isPaused = false;
        this.blob = null;

        // todo: if recording-ON then STOP it first
    };

    /**
     * @property {Blob} blob - The recorded blob object.
     * @memberof WebAssemblyRecorder
     * @example
     * recorder.stop(function(){
     *     var blob = recorder.blob;
     * });
     */
    this.blob = null;
}

if (typeof RecordRTC !== 'undefined') {
    RecordRTC.WebAssemblyRecorder = WebAssemblyRecorder;
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("DuR2"), __webpack_require__("W2nU")))

/***/ }),

/***/ "peeZ":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "s+aQ":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "sFoK":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "sY2q":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "vwWJ":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("LfR4");
var $Object = __webpack_require__("iANj").Object;
module.exports = function getOwnPropertyNames(it) {
  return $Object.getOwnPropertyNames(it);
};


/***/ }),

/***/ "w+Fn":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "wA+2":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "yE1H":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ })

});
//# sourceMappingURL=1.d783650aa0a600d28185.js.map